<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neural Memory Interface</title>
<style>
  /* ═══════════════════════════════════════════
     RESET & BASE
     ═══════════════════════════════════════════ */
  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    /* ── Text ── */
    --t-faint: rgba(255,255,255,0.2);
    --t-muted: rgba(255,255,255,0.3);
    --t-secondary: rgba(255,255,255,0.5);
    --t-primary: rgba(255,255,255,0.7);
    --t-bright: rgba(255,255,255,0.9);
    /* ── Surfaces ── */
    --s-transparent: transparent;
    --s-subtle: rgba(255,255,255,0.04);
    --s-light: rgba(255,255,255,0.06);
    --s-medium: rgba(255,255,255,0.10);
    --s-hover: rgba(255,255,255,0.08);
    --s-active: rgba(255,255,255,0.14);
    --s-panel: rgba(28,28,30,0.85);
    /* ── Borders ── */
    --b-subtle: rgba(255,255,255,0.06);
    --b-light: rgba(255,255,255,0.10);
    --b-hover: rgba(255,255,255,0.16);
    --b-visible: rgba(255,255,255,0.22);
    /* ── Accents ── */
    --accent-blue: #4FC3F7;
    --accent-blue-bg: rgba(79,195,247,0.10);
    --accent-blue-border: rgba(79,195,247,0.25);
    --accent-gold: rgba(255,215,0,0.85);
    --accent-gold-bg: rgba(255,215,0,0.10);
    --accent-gold-border: rgba(255,215,0,0.22);
    --accent-red: #FF5252;
    --accent-red-bg: rgba(255,82,82,0.15);
    --accent-red-hover: rgba(255,82,82,0.30);
    /* ── Radii ── */
    --r-pill: 20px;
    --r-button: 10px;
    --r-card: 8px;
    --r-circle: 50%;
    --r-small: 6px;
    /* ── Font sizes ── */
    --fs-xs: 10px;
    --fs-sm: 11px;
    --fs-md: 12px;
    --fs-base: 13px;
    --fs-lg: 14px;
    /* ── Transitions ── */
    --ease: 0.2s ease;
  }

  body {
    background: #000000;
    color: #e0e0e0;
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', system-ui, sans-serif;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
  }

  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: rgba(255,255,255,0.03); }
  ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 3px; }

  /* ═══════════════════════════════════════════
     GLASSMORPHISM BASE
     ═══════════════════════════════════════════ */
  .glass {
    background: rgba(28, 28, 30, 0.72);
    backdrop-filter: blur(40px) saturate(1.4);
    -webkit-backdrop-filter: blur(40px) saturate(1.4);
    border: 1px solid rgba(255, 255, 255, 0.06);
    border-radius: 14px;
    box-shadow: 0 2px 20px rgba(0, 0, 0, 0.4), inset 0 0.5px 0 rgba(255, 255, 255, 0.05);
  }

  /* Resizable panels now use JavaScript-based viewport clamping */
  .resizable {
    overflow-y: auto;
    box-sizing: border-box;
  }

  /* ═══════════════════════════════════════════
     GRAPH CONTAINER
     ═══════════════════════════════════════════ */
  #graph-container {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 1;
  }

  /* ═══════════════════════════════════════════
     TITLE BAR (top-left)
     ═══════════════════════════════════════════ */
  #title-bar {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 100;
    padding: 14px 22px;
    display: flex;
    align-items: center;
    gap: 14px;
  }

  .pin-btn {
    background: none;
    border: 1px solid rgba(255,255,255,0.12);
    cursor: pointer;
    width: 26px;
    height: 26px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: all 0.2s;
    padding: 0;
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 11;
    opacity: 0;
  }
  .pin-btn svg {
    width: 14px;
    height: 14px;
    stroke: rgba(255,255,255,0.35);
    fill: none;
    stroke-width: 2;
    transition: all 0.2s;
    transform: rotate(45deg);
  }
  .resizable:hover .pin-btn { opacity: 1; }
  .pin-btn:hover {
    background: rgba(255,255,255,0.08);
    border-color: rgba(255,255,255,0.2);
  }
  .pin-btn:hover svg { stroke: rgba(255,255,255,0.6); }
  .pin-btn.pinned {
    opacity: 1;
    background: rgba(255,255,255,0.1);
    border-color: rgba(255,255,255,0.25);
  }
  .pin-btn.pinned svg {
    stroke: rgba(255,255,255,0.7);
    fill: rgba(255,255,255,0.15);
    transform: rotate(0deg);
  }

  #detail-panel .pin-btn { right: 86px; top: 14px; }

  #title-bar h1 {
    font-size: 14px;
    font-weight: 600;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.65);
  }

  #reset-positions-btn {
    background: rgba(255, 255, 255, 0.06);
    border: 1px solid rgba(255, 255, 255, 0.08);
    color: rgba(255, 255, 255, 0.45);
    font-size: 12px;
    font-weight: 500;
    letter-spacing: 0.05em;
    padding: 6px 14px;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
  }
  #reset-positions-btn:hover {
    background: rgba(255, 255, 255, 0.1);
    color: rgba(255, 255, 255, 0.8);
    border-color: rgba(255, 255, 255, 0.15);
  }
  #reset-positions-btn:active {
    background: rgba(255, 255, 255, 0.14);
    transform: scale(0.96);
  }

  /* ═══════════════════════════════════════════
     HELP BUTTON + MODAL
     ═══════════════════════════════════════════ */
  #help-btn {
    background: rgba(255, 255, 255, 0.04);
    border: 1px solid rgba(255, 255, 255, 0.06);
    color: rgba(255, 255, 255, 0.3);
    font-size: 15px;
    font-weight: 600;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    flex-shrink: 0;
  }
  #help-btn:hover {
    background: rgba(255, 255, 255, 0.08);
    color: rgba(255, 255, 255, 0.6);
    border-color: rgba(255, 255, 255, 0.12);
  }

  #help-overlay {
    position: fixed;
    inset: 0;
    z-index: 500;
    background: rgba(0, 0, 0, 0.6);
    display: none;
    align-items: center;
    justify-content: center;
    animation: helpFadeIn 0.15s ease-out;
  }
  #help-overlay.open { display: flex; }

  @keyframes helpFadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  #help-modal {
    width: 480px;
    max-height: calc(100vh - 80px);
    overflow-y: auto;
    padding: 28px 30px;
    animation: helpSlideIn 0.2s ease-out;
  }

  @keyframes helpSlideIn {
    from { opacity: 0; transform: translateY(10px) scale(0.98); }
    to { opacity: 1; transform: translateY(0) scale(1); }
  }

  #help-modal h2 {
    font-size: 14px;
    font-weight: 600;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.55);
    margin-bottom: 20px;
  }

  .help-section {
    margin-bottom: 20px;
  }

  .help-section-title {
    font-size: 12px;
    font-weight: 600;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.3);
    margin-bottom: 10px;
    padding-bottom: 6px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.04);
  }

  .help-row {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    padding: 5px 0;
  }

  .help-keys {
    display: flex;
    gap: 4px;
    flex-shrink: 0;
  }

  .help-key {
    font-family: 'SF Mono', 'Cascadia Code', 'Consolas', monospace;
    font-size: 12px;
    font-weight: 500;
    color: rgba(255, 255, 255, 0.7);
    background: rgba(255, 255, 255, 0.06);
    border: 1px solid rgba(255, 255, 255, 0.06);
    border-radius: 5px;
    padding: 2px 8px;
    white-space: nowrap;
  }

  .help-desc {
    font-size: 13px;
    color: rgba(255, 255, 255, 0.45);
    text-align: right;
    flex: 1;
    margin-left: 16px;
  }

  #help-close {
    position: absolute;
    top: 14px;
    right: 14px;
    background: rgba(255, 255, 255, 0.06);
    border: none;
    color: rgba(255, 255, 255, 0.3);
    cursor: pointer;
    font-size: 18px;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s;
  }
  #help-close:hover {
    color: rgba(255, 255, 255, 0.7);
    background: rgba(255, 255, 255, 0.1);
  }

  /* ═══════════════════════════════════════════
     BOOKMARKS
     ═══════════════════════════════════════════ */
  /* ── Toolbar buttons (shared) ── */
  .toolbar-btn {
    background: var(--s-panel);
    border: 1px solid var(--b-subtle);
    color: var(--t-secondary);
    font-size: var(--fs-base);
    font-weight: 500;
    font-family: inherit;
    letter-spacing: 0.02em;
    padding: 8px 14px;
    border-radius: var(--r-button);
    cursor: pointer;
    transition: all var(--ease);
    white-space: nowrap;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    gap: 7px;
    position: relative;
  }
  .toolbar-btn:hover {
    background: rgba(40,40,44,0.92);
    color: var(--t-primary);
    border-color: var(--b-hover);
  }
  .toolbar-btn:active { transform: scale(0.97); }
  .toolbar-btn.active {
    background: rgba(40,40,44,0.95);
    color: var(--t-primary);
    border-color: var(--b-hover);
  }
  .toolbar-btn svg {
    width: 14px; height: 14px;
    fill: none;
    stroke: currentColor;
    stroke-width: 1.8;
    stroke-linejoin: round;
    flex-shrink: 0;
  }

  /* ── Count badges (shared) ── */
  .count-badge {
    font-size: var(--fs-xs);
    font-weight: 600;
    padding: 1px 6px;
    border-radius: var(--r-pill);
    min-width: 16px;
    text-align: center;
    line-height: 1.5;
  }
  .count-badge:empty { display: none; }
  .count-badge--gold {
    background: var(--accent-gold-bg);
    color: var(--accent-gold);
  }
  .count-badge--blue {
    background: var(--accent-blue-bg);
    color: var(--accent-blue);
  }
  .count-badge--muted {
    background: var(--s-light);
    color: var(--t-secondary);
  }

  /* ── Dropdown panels (shared) ── */
  .dropdown-panel {
    position: absolute;
    top: 100%;
    right: 0;
    margin-top: 8px;
    z-index: 101;
    width: 340px;
    padding: 12px;
    display: none;
    animation: dropdownFadeIn 0.15s ease-out;
  }
  .dropdown-panel.open { display: block; }
  @keyframes dropdownFadeIn {
    from { opacity: 0; transform: translateY(-6px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .dropdown-empty {
    text-align: center;
    color: var(--t-faint);
    font-size: var(--fs-md);
    padding: 20px 10px;
    line-height: 1.7;
  }

  /* ── Dropdown list items (shared) ── */
  .dropdown-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 10px;
    border-radius: var(--r-card);
    cursor: pointer;
    transition: background 0.15s;
  }
  .dropdown-item:hover { background: var(--s-hover); }
  .dropdown-item-dot {
    width: 8px; height: 8px;
    border-radius: var(--r-circle);
    flex-shrink: 0;
  }
  .dropdown-item-text {
    flex: 1;
    min-width: 0;
  }
  .dropdown-item-title {
    font-size: var(--fs-md);
    font-weight: 500;
    color: var(--t-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .dropdown-item:hover .dropdown-item-title { color: var(--t-primary); }
  .dropdown-item-sub {
    font-size: var(--fs-xs);
    color: var(--t-faint);
    text-transform: uppercase;
    letter-spacing: 0.4px;
    margin-top: 1px;
  }

  /* ── Icon buttons (shared) ── circular action buttons in panels ── */
  .icon-btn {
    width: 28px; height: 28px;
    border-radius: var(--r-circle);
    background: var(--s-subtle);
    border: 1px solid var(--b-subtle);
    color: var(--t-muted);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all var(--ease);
    flex-shrink: 0;
    font-size: var(--fs-lg);
    line-height: 1;
    padding: 0;
  }
  .icon-btn:hover {
    background: var(--s-hover);
    color: var(--t-primary);
    border-color: var(--b-light);
  }
  .icon-btn svg {
    width: 14px; height: 14px;
    stroke: currentColor;
    stroke-width: 1.8;
    fill: none;
    transition: fill var(--ease), stroke var(--ease);
  }
  .icon-btn--danger:hover {
    background: var(--accent-red-bg);
    color: var(--accent-red);
    border-color: rgba(255,82,82,0.2);
  }
  .icon-btn--gold:hover {
    background: var(--accent-gold-bg);
    color: var(--accent-gold);
    border-color: var(--accent-gold-border);
  }
  .icon-btn--gold.active {
    background: var(--accent-gold-bg);
    color: var(--accent-gold);
    border-color: var(--accent-gold-border);
  }
  .icon-btn--gold.active svg.filled { fill: currentColor; }

  /* ── Action buttons (shared) ── solid clickable actions ── */
  .action-btn {
    font-size: var(--fs-md);
    font-weight: 500;
    font-family: inherit;
    padding: 6px 14px;
    border-radius: var(--r-small);
    border: 1px solid var(--b-subtle);
    cursor: pointer;
    transition: all var(--ease);
    white-space: nowrap;
  }
  .action-btn--primary {
    background: var(--s-medium);
    color: var(--t-primary);
  }
  .action-btn--primary:hover {
    background: var(--s-active);
    color: var(--t-bright);
  }
  .action-btn--primary:disabled {
    opacity: 0.3;
    cursor: not-allowed;
  }
  .action-btn--ghost {
    background: var(--s-transparent);
    color: var(--t-muted);
    border-color: transparent;
  }
  .action-btn--ghost:hover {
    background: var(--s-hover);
    color: var(--t-primary);
  }
  .action-btn--danger {
    background: var(--accent-red-bg);
    color: var(--accent-red);
    border-color: rgba(255,82,82,0.12);
  }
  .action-btn--danger:hover {
    background: var(--accent-red-hover);
  }

  /* ── Pill badges (shared) ── small info pills ── */
  .pill-badge {
    font-size: var(--fs-xs);
    font-weight: 500;
    padding: 2px 8px;
    border-radius: var(--r-pill);
    background: var(--s-subtle);
    color: var(--t-muted);
    line-height: 1.5;
  }
  .pill-badge--blue {
    background: var(--accent-blue-bg);
    color: rgba(100,180,255,0.6);
  }

  /* ═══════════════════════════════════════════
     LAYOUTS PANEL
     ═══════════════════════════════════════════ */
  /* layouts-btn and layouts-panel now use shared .toolbar-btn and .dropdown-panel */

  .preset-save-bar {
    display: flex;
    gap: 6px;
    margin-bottom: 10px;
  }
  .preset-save-bar input {
    flex: 1;
    background: var(--s-subtle);
    border: 1px solid var(--b-subtle);
    border-radius: var(--r-small);
    padding: 6px 10px;
    color: var(--t-bright);
    font-size: var(--fs-md);
    font-family: inherit;
    outline: none;
    transition: border-color var(--ease);
  }
  .preset-save-bar input::placeholder {
    color: var(--t-faint);
  }
  .preset-save-bar input:focus {
    border-color: var(--b-hover);
  }
  .preset-save-bar button {
    background: var(--s-medium);
    border: 1px solid var(--b-subtle);
    color: var(--t-secondary);
    font-size: var(--fs-md);
    font-weight: 500;
    font-family: inherit;
    padding: 6px 12px;
    border-radius: var(--r-small);
    cursor: pointer;
    transition: all var(--ease);
    white-space: nowrap;
  }
  .preset-save-bar button:hover {
    background: var(--s-active);
    color: var(--t-bright);
    border-color: var(--b-hover);
  }

  .preset-list {
    max-height: 240px;
    overflow-y: auto;
  }

  .preset-row {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 7px 10px;
    border-radius: var(--r-card);
    cursor: pointer;
    transition: background 0.15s;
    position: relative;
  }
  .preset-row:hover { background: var(--s-hover); }
  .preset-row.active { background: var(--s-medium); }

  .preset-name {
    flex: 1;
    font-size: var(--fs-md);
    color: var(--t-secondary);
    font-weight: 500;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .preset-row:hover .preset-name { color: var(--t-primary); }
  .preset-row.active .preset-name { color: var(--t-bright); }

  .preset-badge {
    font-size: var(--fs-xs);
    font-weight: 500;
    color: var(--t-muted);
    background: var(--s-subtle);
    padding: 2px 8px;
    border-radius: var(--r-pill);
    flex-shrink: 0;
  }

  .preset-date {
    font-size: var(--fs-xs);
    color: var(--t-faint);
    flex-shrink: 0;
  }

  .preset-delete {
    background: none;
    border: none;
    color: var(--t-faint);
    font-size: var(--fs-lg);
    cursor: pointer;
    padding: 0 2px;
    line-height: 1;
    opacity: 0;
    transition: all 0.15s;
    flex-shrink: 0;
  }
  .preset-row:hover .preset-delete { opacity: 1; }
  .preset-delete:hover { color: var(--accent-red); }

  .preset-empty {
    text-align: center;
    padding: 18px 8px;
    font-size: var(--fs-md);
    color: var(--t-faint);
    letter-spacing: 0.02em;
    line-height: 1.7;
  }

  .preset-divider {
    height: 1px;
    background: rgba(255,255,255,0.06);
    margin: 6px 0;
  }
  .preset-row.builtin .preset-name {
    color: rgba(255,255,255,0.5);
    font-style: italic;
  }
  .preset-row.builtin.active .preset-name {
    color: rgba(255,255,255,0.85);
  }
  .preset-row.builtin .preset-badge {
    background: var(--accent-blue-bg);
    color: rgba(100,180,255,0.6);
    font-size: var(--fs-xs);
  }
  .preset-warning {
    font-size: 12px;
    color: rgba(255, 180, 0, 0.6);
    padding: 4px 0 2px;
    text-align: center;
    display: none;
  }
  .preset-warning.visible { display: block; }

  .status-dot {
    width: 10px; height: 10px;
    border-radius: 50%;
    background: #555;
    transition: background 0.5s;
  }
  .status-dot.connected { background: #64FFDA; box-shadow: 0 0 8px #64FFDA; }
  .status-dot.error { background: #FF5252; box-shadow: 0 0 8px #FF5252; }

  /* ═══════════════════════════════════════════
     SEARCH BAR (top-center)
     ═══════════════════════════════════════════ */
  #search-container {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  #search-wrapper {
    position: relative;
    width: 420px;
    border-radius: 14px;
    padding: 1.5px;
    background: rgba(255,255,255,0.08);
    transition: all 0.3s;
    box-shadow: 0 1px 12px rgba(0,0,0,0.3);
  }

  #search-wrapper.focused {
    background: conic-gradient(from var(--search-angle, 0deg),
      rgba(255,255,255,0.25), rgba(255,255,255,0.08), rgba(255,255,255,0.20), rgba(255,255,255,0.06), rgba(255,255,255,0.25));
    animation: rotateGradient 4s linear infinite;
  }

  @property --search-angle {
    syntax: '<angle>';
    initial-value: 0deg;
    inherits: false;
  }

  @keyframes rotateGradient {
    to { --search-angle: 360deg; }
  }

  #search-input {
    width: 100%;
    padding: 11px 44px 11px 16px;
    background: rgba(28, 28, 30, 0.85);
    border: none;
    border-radius: 12px;
    color: rgba(255, 255, 255, 0.9);
    font-size: 15px;
    font-weight: 400;
    outline: none;
    letter-spacing: 0.01em;
  }

  #search-input::placeholder {
    color: rgba(255,255,255,0.25);
    letter-spacing: 0.04em;
    font-weight: 400;
  }

  #search-badge {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    background: var(--s-medium);
    color: var(--t-primary);
    font-size: var(--fs-xs);
    font-weight: 600;
    padding: 2px 8px;
    border-radius: var(--r-pill);
    opacity: 0;
    transition: opacity 0.3s;
  }
  #search-badge.visible { opacity: 1; }

  #search-clear {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: var(--t-muted);
    cursor: pointer;
    font-size: var(--fs-lg);
    display: none;
    padding: 4px 8px;
    transition: color 0.15s;
  }
  #search-clear:hover { color: var(--t-bright); }

  /* ═══════════════════════════════════════════
     RESIZE HANDLES
     ═══════════════════════════════════════════ */
  .resize-handle {
    position: absolute;
    z-index: 10;
    opacity: 0;
    transition: opacity 0.2s;
  }
  .resizable:hover .resize-handle,
  .resize-handle.active { opacity: 1; }

  .resize-handle-r   { right: 0; top: 0; width: 6px; height: 100%; cursor: ew-resize; }
  .resize-handle-l   { left: 0; top: 0; width: 6px; height: 100%; cursor: ew-resize; }
  .resize-handle-b   { bottom: 0; left: 0; height: 6px; width: 100%; cursor: ns-resize; }
  .resize-handle-t   { top: 0; left: 0; height: 6px; width: 100%; cursor: ns-resize; }
  .resize-handle-br  { right: 0; bottom: 0; width: 14px; height: 14px; cursor: nwse-resize; }
  .resize-handle-bl  { left: 0; bottom: 0; width: 14px; height: 14px; cursor: nesw-resize; }
  .resize-handle-tr  { right: 0; top: 0; width: 14px; height: 14px; cursor: nesw-resize; }
  .resize-handle-tl  { left: 0; top: 0; width: 14px; height: 14px; cursor: nwse-resize; }

  /* Drag handle (top bar of panels) */
  .drag-handle {
    cursor: grab;
    padding: 6px 0 4px 0;
    margin: -4px 0 6px 0;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .locked .drag-handle { cursor: default; pointer-events: none; }
  .locked .resize-handle { display: none; }
  .drag-handle:active { cursor: grabbing; }
  .drag-handle .drag-grip {
    width: 32px;
    height: 4px;
    border-radius: 2px;
    background: rgba(255,255,255,0.08);
    transition: background 0.2s;
  }
  .resizable:hover .drag-grip { background: rgba(255,255,255,0.14); }

  .dragging { transition: none !important; }

  /* ═══════════════════════════════════════════
     CATEGORY SIDEBAR (left)
     ═══════════════════════════════════════════ */
  #category-sidebar {
    position: fixed;
    top: 80px;
    left: 20px;
    z-index: 100;
    padding: 14px;
    max-height: calc(100vh - 120px);
    overflow-y: auto;
    width: 220px;
    min-width: 160px;
    min-height: 100px;
  }

  #sidebar-title {
    font-size: 12px;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    color: rgba(255,255,255,0.45);
    margin-bottom: 14px;
    padding: 0 4px;
    padding-right: 34px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .sidebar-title-actions {
    display: flex;
    gap: 2px;
  }
  #category-clear-btn,
  #category-select-all-btn {
    background: none;
    border: none;
    color: var(--t-muted);
    font-size: var(--fs-xs);
    font-family: inherit;
    font-weight: 500;
    cursor: pointer;
    padding: 3px 7px;
    border-radius: var(--r-small);
    letter-spacing: 0.03em;
    transition: all 0.15s;
  }
  #category-clear-btn:hover,
  #category-select-all-btn:hover {
    color: var(--t-secondary);
    background: var(--s-hover);
  }

  .category-chip {
    display: flex;
    align-items: center;
    gap: 11px;
    padding: 8px 10px;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    margin-bottom: 2px;
    user-select: none;
  }

  .category-chip:hover { background: rgba(255,255,255,0.05); }
  .category-chip.inactive { opacity: 0.25; }
  .category-chip.drag-source {
    opacity: 0.25;
    background: rgba(255,255,255,0.02);
    transition: none;
  }
  .category-chip.drag-over-above {
    box-shadow: 0 -1px 0 0 rgba(255,255,255,0.35);
  }
  .category-chip.drag-over-below {
    box-shadow: 0 1px 0 0 rgba(255,255,255,0.35);
  }
  .category-chip {
    cursor: grab;
  }
  .category-chip:active { cursor: grabbing; }
  .category-chip .category-grip {
    display: none;
  }

  .category-dot {
    width: 12px; height: 12px;
    border-radius: 50%;
    flex-shrink: 0;
    box-shadow: 0 0 4px currentColor;
    cursor: pointer;
    transition: transform 0.15s, box-shadow 0.15s;
  }
  .category-dot:hover {
    transform: scale(1.4);
    box-shadow: 0 0 8px currentColor;
  }

  /* Cluster headers */
  .category-cluster-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px 10px 6px 10px;
    margin-top: 16px;
    margin-bottom: 4px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: rgba(255,255,255,0.5);
    border-left-width: 3px;
    border-left-style: solid;
    padding-left: 12px;
  }
  .category-cluster-header:first-child {
    margin-top: 0;
  }
  .category-cluster-header.inactive {
    opacity: 0.25;
  }
  .category-cluster-header {
    cursor: pointer;
  }
  .cluster-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
    cursor: pointer;
    transition: transform 0.15s;
  }
  .cluster-dot:hover {
    transform: scale(1.3);
  }
  .cluster-name {
    flex: 1;
  }
  .cluster-actions {
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.2s;
  }
  .category-cluster-header:hover .cluster-actions {
    opacity: 1;
  }
  .cluster-edit-btn,
  .cluster-delete-btn {
    background: rgba(255,255,255,0.1);
    border: none;
    color: rgba(255,255,255,0.6);
    width: 20px;
    height: 20px;
    border-radius: 3px;
    cursor: pointer;
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
  }
  .cluster-edit-btn:hover {
    background: rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.9);
  }
  .cluster-delete-btn:hover {
    background: rgba(220,38,38,0.2);
    color: rgb(239,68,68);
  }
  .cluster-empty-hint {
    margin-left: 20px;
    padding: 6px 12px;
    font-size: 10px;
    color: rgba(255,255,255,0.25);
    font-style: italic;
    border: 1px dashed rgba(255,255,255,0.1);
    border-radius: 4px;
    text-align: center;
    margin-bottom: 4px;
  }
  .drag-over-cluster {
    background: rgba(59,130,246,0.15);
    border-left-width: 4px;
    transform: translateX(2px);
    transition: all 0.15s;
  }

  /* Child categories (indented) */
  .category-chip-child {
    margin-left: 20px;
    opacity: 0.95;
  }

  .color-edit-picker {
    padding: 8px 10px;
    margin: 2px 0 4px;
    background: rgba(30, 30, 34, 0.95);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 10px;
    animation: colorPickerIn 0.12s ease-out;
  }
  @keyframes colorPickerIn {
    from { opacity: 0; transform: translateY(-4px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .color-edit-picker .color-swatch-row {
    margin-bottom: 0;
  }
  .color-edit-picker .color-swatch {
    width: 22px; height: 22px;
  }
  .color-edit-reset {
    background: none;
    border: none;
    color: rgba(255,255,255,0.3);
    font-size: 12px;
    cursor: pointer;
    padding: 4px 0 0;
    transition: color 0.15s;
    width: 100%;
    text-align: center;
  }
  .color-edit-reset:hover { color: rgba(255,255,255,0.7); }

  .category-label {
    font-size: 15px;
    font-weight: 500;
    color: rgba(255,255,255,0.7);
    flex: 1;
  }

  .category-count {
    font-size: 14px;
    font-weight: 500;
    color: rgba(255,255,255,0.3);
    min-width: 18px;
    text-align: right;
  }

  .category-chip .category-delete {
    display: none;
    background: none;
    border: none;
    color: var(--t-muted);
    font-size: 15px;
    cursor: pointer;
    padding: 0;
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
    flex-shrink: 0;
    margin-left: auto;
    transition: color 0.15s;
  }
  .category-chip:hover .category-delete { display: block; }
  .category-chip .category-delete:hover { color: var(--accent-red); }

  .category-desc-editor {
    padding: 6px 10px 8px;
    margin: 2px 0 4px;
    background: rgba(30, 30, 34, 0.95);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 10px;
    animation: colorPickerIn 0.12s ease-out;
  }
  .category-desc-editor label {
    font-size: 12px;
    color: rgba(255,255,255,0.3);
    display: block;
    margin-bottom: 4px;
  }
  .category-desc-editor textarea {
    width: 100%;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 6px;
    color: rgba(255,255,255,0.8);
    font-size: 15px;
    font-family: inherit;
    padding: 6px 8px;
    resize: vertical;
    min-height: 36px;
    max-height: 80px;
    outline: none;
    transition: border-color 0.15s;
  }
  .category-desc-editor textarea:focus {
    border-color: rgba(255,255,255,0.2);
  }
  .category-desc-actions {
    display: flex;
    gap: 6px;
    margin-top: 6px;
    justify-content: flex-end;
  }
  .category-desc-actions button {
    font-size: var(--fs-sm);
    font-family: inherit;
    font-weight: 500;
    padding: 4px 12px;
    border-radius: var(--r-small);
    border: 1px solid var(--b-subtle);
    cursor: pointer;
    transition: all var(--ease);
  }
  .desc-save-btn {
    background: var(--s-medium);
    color: var(--t-primary);
  }
  .desc-save-btn:hover { background: var(--s-active); color: var(--t-bright); }
  .desc-cancel-btn {
    background: none;
    color: var(--t-muted);
    border-color: transparent;
  }
  .desc-cancel-btn:hover { color: var(--t-secondary); background: var(--s-hover); }

  .category-label {
    cursor: default;
  }
  .category-label .cat-edit-icon {
    display: none;
    font-size: 13px;
    margin-left: 5px;
    opacity: 0.45;
    vertical-align: middle;
    cursor: pointer;
    transition: opacity 0.15s;
  }
  .category-chip:hover .category-label .cat-edit-icon {
    display: inline;
  }
  .category-label .cat-edit-icon:hover {
    opacity: 0.8;
  }

  #category-add-btn,
  #category-add-parent-btn {
    border-radius: var(--r-card);
    border: 1px dashed var(--b-light);
    background: var(--s-subtle);
    color: var(--t-muted);
    font-size: var(--fs-sm);
    font-weight: 500;
    font-family: inherit;
    letter-spacing: 0.3px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    transition: all var(--ease);
    padding: 7px 0;
  }
  #category-add-btn:hover,
  #category-add-parent-btn:hover {
    background: var(--s-hover);
    border-color: var(--b-visible);
    color: var(--t-primary);
    border-style: solid;
  }
  #category-add-btn svg,
  #category-add-parent-btn svg {
    width: 13px; height: 13px;
    stroke: currentColor;
    stroke-width: 2;
    fill: none;
  }

  #category-create-form {
    display: none;
    padding: 10px;
    margin-top: 8px;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 10px;
  }
  #category-create-form[data-mode="parent"] #cat-parent-select {
    display: none;
  }
  #category-create-form.open { display: block; }

  .category-create-input {
    width: 100%;
    background: var(--s-subtle);
    border: 1px solid var(--b-subtle);
    border-radius: var(--r-small);
    padding: 7px 10px;
    color: var(--t-bright);
    font-size: var(--fs-base);
    outline: none;
    margin-bottom: 6px;
    transition: border-color var(--ease);
    font-family: inherit;
  }
  .category-create-input::placeholder { color: var(--t-faint); }
  .category-create-input:focus { border-color: var(--b-hover); }
  .category-create-input.invalid { border-color: rgba(255,82,82,0.5); }

  .color-swatch-row {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    margin-bottom: 8px;
  }

  .color-swatch {
    width: 24px; height: 24px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all 0.15s;
    padding: 0;
  }
  .color-swatch:hover { transform: scale(1.15); }
  .color-swatch.selected { border-color: rgba(255,255,255,0.8); transform: scale(1.15); }

  .category-form-actions {
    display: flex;
    gap: 6px;
  }
  .category-form-actions button {
    flex: 1;
    padding: 6px 0;
    border-radius: var(--r-small);
    font-size: var(--fs-md);
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    transition: all var(--ease);
    border: 1px solid var(--b-subtle);
  }
  .category-form-btn-create {
    background: var(--s-medium);
    color: var(--t-primary);
  }
  .category-form-btn-create:hover {
    background: var(--s-active);
    color: var(--t-bright);
  }
  .category-form-btn-create:disabled {
    opacity: 0.3;
    cursor: not-allowed;
  }
  .category-form-btn-cancel {
    background: var(--s-transparent);
    color: var(--t-muted);
    border-color: transparent;
  }
  .category-form-btn-cancel:hover {
    background: var(--s-hover);
    color: var(--t-primary);
  }

  .category-form-error {
    font-size: 12px;
    color: #FF5252;
    margin-bottom: 6px;
    min-height: 14px;
  }

  .category-reassign-bar {
    padding: 8px;
    margin-top: 4px;
    background: rgba(255,82,82,0.08);
    border: 1px solid rgba(255,82,82,0.15);
    border-radius: 8px;
    font-size: 12px;
    color: rgba(255,255,255,0.6);
  }
  .category-reassign-bar select {
    width: 100%;
    margin: 6px 0;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 6px;
    padding: 5px 8px;
    color: rgba(255,255,255,0.8);
    font-size: 13px;
    outline: none;
  }
  .category-reassign-bar select option {
    background: #1c1c1e;
    color: #e0e0e0;
  }
  .category-reassign-actions {
    display: flex;
    gap: 6px;
    margin-top: 6px;
  }
  .category-reassign-actions button {
    flex: 1;
    padding: 5px 0;
    border-radius: var(--r-small);
    font-size: var(--fs-md);
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    border: 1px solid var(--b-subtle);
    transition: all var(--ease);
  }
  .reassign-confirm {
    background: var(--accent-red-bg);
    color: var(--accent-red);
    border-color: rgba(255,82,82,0.12);
  }
  .reassign-confirm:hover {
    background: var(--accent-red-hover);
  }
  .reassign-cancel-btn {
    background: var(--s-transparent);
    color: var(--t-muted);
    border-color: transparent;
  }
  .reassign-cancel-btn:hover {
    background: var(--s-hover);
    color: var(--t-primary);
  }

  /* ═══════════════════════════════════════════
     DETAIL PANEL (right, slide-in)
     ═══════════════════════════════════════════ */
  #detail-panel {
    position: fixed;
    top: 20px;
    right: -520px;
    z-index: 100;
    width: 400px;
    min-width: 280px;
    min-height: 200px;
    max-height: calc(100vh - 60px);
    overflow-y: auto;
    padding: 24px;
    transition: right 0.4s cubic-bezier(0.22, 1, 0.36, 1);
  }

  #detail-panel.open { right: 20px; }
  #detail-panel.resizing { transition: none; }

  /* Detail panel icon button positioning */
  #detail-bookmark-btn {
    position: absolute;
    top: 14px;
    right: 50px;
    z-index: 5;
  }

  #detail-close {
    position: absolute;
    top: 14px;
    right: 14px;
    background: var(--s-subtle);
    border: 1px solid var(--b-subtle);
    color: var(--t-muted);
    cursor: pointer;
    font-size: var(--fs-lg);
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: var(--r-circle);
    transition: all var(--ease);
  }
  #detail-close:hover { color: var(--t-bright); background: var(--s-hover); border-color: var(--b-light); }

  #detail-focus-btn {
    background: var(--s-subtle);
    border: 1px solid var(--b-subtle);
    color: var(--t-muted);
    cursor: pointer;
    font-size: var(--fs-xs);
    font-weight: 500;
    font-family: inherit;
    letter-spacing: 0.3px;
    padding: 4px 10px;
    display: flex;
    align-items: center;
    gap: 5px;
    border-radius: var(--r-small);
    transition: all var(--ease);
    white-space: nowrap;
    flex-shrink: 0;
  }
  #detail-focus-btn:hover { color: var(--t-primary); background: var(--s-hover); border-color: var(--b-hover); }
  #detail-focus-btn.active {
    color: var(--accent-blue);
    background: var(--accent-blue-bg);
    border-color: var(--accent-blue-border);
  }
  #detail-focus-btn.active:hover {
    background: rgba(79,195,247,0.18);
  }

  #detail-category {
    font-size: 12px;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    margin-bottom: 8px;
    position: relative;
  }

  #detail-category-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  #detail-category-label {
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }
  #detail-change-cat-btn {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 3px 10px;
    border: 1px solid var(--b-light);
    border-radius: var(--r-pill);
    background: var(--s-subtle);
    color: var(--t-secondary);
    font-size: var(--fs-xs);
    font-family: inherit;
    cursor: pointer;
    transition: all var(--ease);
    letter-spacing: normal;
    text-transform: none;
  }
  #detail-change-cat-btn:hover {
    background: var(--s-medium);
    color: var(--t-bright);
    border-color: var(--b-hover);
  }
  #detail-change-cat-btn svg {
    width: 10px; height: 10px;
    fill: none;
    stroke: currentColor;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  /* ── Category change modal ── */
  .cat-change-modal {
    min-width: 380px;
    max-width: 440px;
    max-height: 480px;
    display: flex;
    flex-direction: column;
  }
  .cat-change-modal-title {
    font-size: var(--fs-md);
    color: var(--t-secondary);
    margin-bottom: 4px;
  }
  .cat-change-modal-current {
    font-size: var(--fs-base);
    font-weight: 600;
    color: var(--t-bright);
    margin-bottom: 14px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .cat-change-modal-current .cat-dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
    box-shadow: 0 0 4px currentColor;
  }
  .cat-change-modal-list {
    overflow-y: auto;
    max-height: 300px;
    padding: 2px;
  }
  .cat-modal-option {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.12s;
    font-size: var(--fs-base);
    color: var(--t-primary);
    text-transform: none;
    letter-spacing: normal;
  }
  .cat-modal-option:hover {
    background: var(--s-hover);
    color: var(--t-bright);
  }
  .cat-modal-option.active {
    background: var(--accent-blue-bg);
    border: 1px solid var(--accent-blue-border);
    color: var(--t-bright);
  }
  .cat-modal-option .cat-opt-dot {
    width: 10px; height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
    box-shadow: 0 0 4px currentColor;
  }
  .cat-modal-option .cat-opt-name {
    flex: 1;
    min-width: 0;
  }
  .cat-modal-option .cat-opt-desc {
    font-size: var(--fs-xs);
    color: var(--t-muted);
    max-width: 180px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  #detail-importance-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 16px;
  }
  #detail-importance {
    font-size: 14px;
    color: #FFD700;
    letter-spacing: 1px;
  }

  #detail-content {
    font-size: 14px;
    line-height: 1.7;
    color: rgba(255,255,255,0.7);
    margin-bottom: 20px;
    word-break: break-word;
  }

  /* Paragraphs */
  #detail-content p {
    margin: 0 0 10px 0;
  }
  #detail-content p:last-child { margin-bottom: 0; }

  /* H2 — main section */
  #detail-content .mc-h2 {
    font-size: 16px;
    font-weight: 600;
    color: rgba(255,255,255,0.92);
    margin: 0 0 12px 0;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
    letter-spacing: -0.01em;
  }
  #detail-content .mc-h2:first-child { margin-top: 0; }

  /* H3 — subsection */
  #detail-content .mc-h3 {
    font-size: 14px;
    font-weight: 600;
    color: rgba(255,255,255,0.75);
    margin: 16px 0 6px 0;
    letter-spacing: 0.01em;
  }
  #detail-content .mc-h3:first-child { margin-top: 0; }

  /* H4+ / plain heading */
  #detail-content .mc-h4 {
    font-size: 13px;
    font-weight: 600;
    color: rgba(255,255,255,0.6);
    margin: 12px 0 4px 0;
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }

  /* Inline code */
  #detail-content code {
    font-family: 'SF Mono', 'Cascadia Code', 'Consolas', monospace;
    font-size: 14.5px;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.04);
    border-radius: 5px;
    padding: 2px 7px;
    color: rgba(255,255,255,0.75);
    word-break: break-all;
  }

  /* Code block */
  #detail-content .mc-codeblock {
    font-family: 'SF Mono', 'Cascadia Code', 'Consolas', monospace;
    font-size: 14.5px;
    line-height: 1.6;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.04);
    border-radius: 10px;
    padding: 12px 14px;
    margin: 8px 0 12px 0;
    color: rgba(255,255,255,0.6);
    overflow-x: auto;
    white-space: pre;
  }

  /* Bold */
  #detail-content strong {
    font-weight: 600;
    color: rgba(255,255,255,0.88);
  }

  /* Lists */
  #detail-content ul {
    margin: 4px 0 12px 0;
    padding: 0;
    list-style: none;
  }

  #detail-content li {
    position: relative;
    padding-left: 16px;
    margin-bottom: 5px;
    color: rgba(255,255,255,0.65);
    font-size: 15.5px;
    line-height: 1.65;
  }

  #detail-content li::before {
    content: '';
    position: absolute;
    left: 2px;
    top: 8px;
    width: 5px;
    height: 5px;
    border-radius: 50%;
    background: rgba(255,255,255,0.2);
  }

  /* Key-value description after em dash or colon in list */
  #detail-content li .kv-desc {
    color: rgba(255,255,255,0.4);
    font-weight: 400;
  }

  /* Divider */
  #detail-content .mc-divider {
    height: 1px;
    background: rgba(255,255,255,0.05);
    margin: 14px 0;
  }

  /* Key: Value standalone */
  #detail-content .mc-kv {
    margin-bottom: 4px;
    font-size: 15.5px;
    line-height: 1.65;
  }
  #detail-content .mc-kv-key {
    color: rgba(255,255,255,0.4);
    font-weight: 500;
  }
  #detail-content .mc-kv-val {
    color: rgba(255,255,255,0.75);
  }

  /* ── Content Edit Button ── */
  .content-edit-wrap {
    position: relative;
  }
  .content-edit-btn {
    position: absolute;
    top: -2px;
    right: 0;
    width: 28px;
    height: 28px;
    border: 1px solid var(--b-subtle);
    border-radius: var(--r-small);
    background: var(--s-subtle);
    color: var(--t-muted);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity var(--ease), background var(--ease), color var(--ease);
    z-index: 2;
  }
  .content-edit-wrap:hover .content-edit-btn,
  .content-edit-btn:focus { opacity: 1; }
  .content-edit-btn:hover {
    background: var(--s-medium);
    color: var(--t-primary);
    border-color: var(--b-hover);
  }
  .content-edit-btn svg { width: 14px; height: 14px; }

  /* ── Markdown Editor ── */
  .md-editor-wrap {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 20px;
  }
  .md-toolbar {
    display: flex;
    gap: 4px;
    padding: 4px;
    background: var(--s-subtle);
    border: 1px solid var(--b-subtle);
    border-radius: var(--r-card);
  }
  .md-toolbar button {
    padding: 5px 10px;
    border: 1px solid transparent;
    border-radius: var(--r-small);
    background: transparent;
    color: var(--t-secondary);
    font-size: var(--fs-md);
    font-weight: 600;
    font-family: inherit;
    cursor: pointer;
    transition: all var(--ease);
    line-height: 1;
  }
  .md-toolbar button:hover {
    background: var(--s-medium);
    color: var(--t-bright);
    border-color: var(--b-light);
  }
  .md-toolbar button.active {
    background: var(--accent-blue-bg);
    color: var(--accent-blue);
    border-color: var(--accent-blue-border);
  }
  .md-textarea {
    width: 100%;
    min-height: 180px;
    padding: 12px 14px;
    background: rgba(0,0,0,0.3);
    border: 1px solid var(--b-light);
    border-radius: var(--r-card);
    color: var(--t-primary);
    font-family: 'SF Mono', 'Cascadia Code', 'Consolas', monospace;
    font-size: 13px;
    line-height: 1.6;
    resize: vertical;
    outline: none;
    transition: border-color var(--ease);
  }
  .md-textarea:focus {
    border-color: var(--accent-blue-border);
  }
  .md-editor-actions {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
  }
  .md-editor-actions button {
    padding: 6px 16px;
    border-radius: var(--r-small);
    font-size: var(--fs-md);
    font-weight: 500;
    cursor: pointer;
    transition: all var(--ease);
    border: 1px solid;
  }
  .md-btn-cancel {
    background: transparent;
    border-color: var(--b-light) !important;
    color: var(--t-secondary);
  }
  .md-btn-cancel:hover {
    background: var(--s-hover);
    color: var(--t-primary);
  }
  .md-btn-save {
    background: var(--accent-blue-bg);
    border-color: var(--accent-blue-border) !important;
    color: var(--accent-blue);
  }
  .md-btn-save:hover {
    background: rgba(79,195,247,0.2);
  }

  .detail-section {
    margin-bottom: 16px;
  }

  .detail-label {
    font-size: 11px;
    font-weight: 600;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: rgba(255,255,255,0.3);
    margin-bottom: 8px;
  }

  .tag-chips {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .tag-chip {
    font-size: var(--fs-sm);
    font-weight: 500;
    padding: 4px 10px;
    border-radius: var(--r-pill);
    background: var(--s-light);
    color: var(--t-secondary);
    border: 1px solid var(--b-subtle);
    display: inline-flex;
    align-items: center;
    gap: 0;
    cursor: default;
    transition: all 0.2s;
    position: relative;
  }
  .tag-chip:hover {
    border-color: var(--b-light);
  }
  .tag-chip .tag-remove {
    display: none;
    margin-left: 6px;
    color: var(--t-muted);
    font-size: 13px;
    line-height: 1;
    cursor: pointer;
    transition: color 0.15s;
  }
  .tag-chip:hover .tag-remove { display: inline; }
  .tag-chip .tag-remove:hover { color: var(--accent-red); }

  /* Tag delete confirmation modal */
  .tag-delete-overlay {
    position: fixed;
    inset: 0;
    z-index: 300;
    background: rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    animation: tagModalFadeIn 0.15s ease-out;
  }
  @keyframes tagModalFadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  .tag-delete-modal {
    background: rgba(24,24,26,0.95);
    border: 1px solid var(--b-light);
    border-radius: 14px;
    padding: 22px 28px;
    text-align: center;
    min-width: 260px;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    box-shadow: 0 8px 40px rgba(0,0,0,0.5);
    animation: tagModalScaleIn 0.15s ease-out;
  }
  @keyframes tagModalScaleIn {
    from { opacity: 0; transform: scale(0.95); }
    to { opacity: 1; transform: scale(1); }
  }
  .tag-delete-modal-title {
    font-size: var(--fs-md);
    color: var(--t-secondary);
    margin-bottom: 6px;
  }
  .tag-delete-modal-tag {
    font-size: var(--fs-base);
    font-weight: 600;
    color: var(--t-bright);
    margin-bottom: 18px;
  }
  .tag-delete-modal-actions {
    display: flex;
    gap: 8px;
    justify-content: center;
  }
  .tag-delete-modal-actions button {
    font-size: var(--fs-sm);
    font-weight: 500;
    font-family: inherit;
    padding: 7px 22px;
    border-radius: var(--r-card);
    border: 1px solid var(--b-subtle);
    cursor: pointer;
    transition: all var(--ease);
  }
  .modal-select {
    width: 100%;
    margin-bottom: 16px;
    background: #1a1a1c;
    border: 1px solid var(--b-light);
    border-radius: var(--r-small);
    padding: 8px 10px;
    color: var(--t-bright);
    font-size: var(--fs-md);
    font-family: inherit;
    outline: none;
    appearance: none;
    -webkit-appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='rgba(255,255,255,0.3)' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 10px center;
    padding-right: 28px;
    cursor: pointer;
    transition: border-color var(--ease);
  }
  .modal-select:focus {
    border-color: var(--b-hover);
  }
  .modal-select option {
    background: #1a1a1c;
    color: #e0e0e0;
    padding: 6px;
  }

  /* ── Settings Modal ── */
  .settings-modal {
    width: 460px;
    max-width: 90vw;
    padding: 24px;
  }
  .settings-modal h3 {
    font-size: 15px;
    font-weight: 600;
    color: var(--t-bright);
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .settings-field {
    margin-bottom: 16px;
  }
  .settings-field label {
    display: block;
    font-size: var(--fs-sm);
    font-weight: 500;
    color: var(--t-primary);
    margin-bottom: 5px;
  }
  .settings-field .settings-hint {
    font-size: var(--fs-xs);
    color: var(--t-muted);
    margin-top: 3px;
  }
  .settings-key-row {
    display: flex;
    gap: 6px;
    align-items: center;
  }
  .settings-key-row input {
    flex: 1;
    font-size: var(--fs-md);
    font-family: 'SF Mono', 'Consolas', monospace;
    padding: 7px 10px;
    border-radius: var(--r-small);
    background: var(--s-subtle);
    color: var(--t-bright);
    border: 1px solid var(--b-light);
    outline: none;
    transition: border-color var(--ease);
  }
  .settings-key-row input:focus {
    border-color: var(--accent-blue-border);
  }
  .settings-key-row input::placeholder {
    color: var(--t-muted);
    font-family: 'SF Mono', 'Consolas', monospace;
  }
  .settings-toggle-vis {
    width: 32px;
    height: 32px;
    border-radius: var(--r-small);
    background: var(--s-subtle);
    border: 1px solid var(--b-light);
    color: var(--t-muted);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: all var(--ease);
  }
  .settings-toggle-vis:hover {
    background: var(--s-hover);
    color: var(--t-primary);
    border-color: var(--b-hover);
  }
  .settings-toggle-vis svg {
    width: 14px;
    height: 14px;
    stroke: currentColor;
    stroke-width: 2;
    fill: none;
  }
  .settings-status {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: var(--fs-sm);
    color: var(--t-secondary);
    margin-bottom: 16px;
    padding: 8px 10px;
    background: var(--s-subtle);
    border-radius: var(--r-small);
    border: 1px solid var(--b-subtle);
  }
  .settings-status-dot {
    width: 8px;
    height: 8px;
    border-radius: var(--r-circle);
    flex-shrink: 0;
  }
  .settings-status-dot.connected { background: #4caf50; box-shadow: 0 0 6px rgba(76,175,80,0.5); }
  .settings-status-dot.disconnected { background: var(--accent-red); box-shadow: 0 0 6px rgba(255,82,82,0.4); }
  .settings-restart-notice {
    margin-top: 12px;
    padding: 10px 12px;
    background: rgba(255,215,0,0.08);
    border: 1px solid rgba(255,215,0,0.2);
    border-radius: var(--r-small);
    font-size: var(--fs-sm);
    color: var(--accent-gold);
    display: none;
  }
  .settings-actions {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    margin-top: 20px;
  }
  .settings-actions button {
    font-family: inherit;
    font-size: var(--fs-md);
    font-weight: 500;
    padding: 7px 18px;
    border-radius: var(--r-card);
    cursor: pointer;
    transition: all var(--ease);
  }
  .settings-btn-cancel {
    background: var(--s-subtle);
    border: 1px solid var(--b-light);
    color: var(--t-secondary);
  }
  .settings-btn-cancel:hover {
    background: var(--s-hover);
    color: var(--t-primary);
  }
  .settings-btn-save {
    background: var(--accent-blue-bg);
    border: 1px solid var(--accent-blue-border);
    color: var(--accent-blue);
  }
  .settings-btn-save:hover {
    background: rgba(79,195,247,0.18);
  }
  #settings-btn {
    border-radius: var(--r-card);
    border: 1px dashed var(--b-light);
    background: var(--s-subtle);
    color: var(--t-muted);
    font-size: var(--fs-sm);
    font-weight: 500;
    font-family: inherit;
    letter-spacing: 0.3px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    transition: all var(--ease);
    padding: 7px 0;
  }
  #settings-btn:hover {
    background: var(--s-hover);
    border-color: var(--b-visible);
    color: var(--t-primary);
    border-style: solid;
  }
  #settings-btn svg {
    width: 13px;
    height: 13px;
    stroke: currentColor;
    stroke-width: 2;
    fill: none;
  }

  .tag-add-input {
    font-size: var(--fs-sm);
    font-weight: 500;
    padding: 3px 10px;
    border-radius: var(--r-pill);
    background: var(--s-subtle);
    color: var(--t-secondary);
    border: 1px dashed var(--b-light);
    outline: none;
    width: 90px;
    transition: all var(--ease);
    font-family: inherit;
  }
  .tag-add-input::placeholder {
    color: var(--t-faint);
  }
  .tag-add-input:focus {
    border-color: var(--b-visible);
    background: var(--s-hover);
    width: 120px;
  }

  .detail-meta {
    font-size: 15px;
    color: rgba(255,255,255,0.3);
    line-height: 1.9;
  }

  .detail-meta span { color: rgba(255,255,255,0.55); font-weight: 500; }

  .detail-meta-row {
    display: flex;
    justify-content: space-between;
    padding: 3px 0;
    border-bottom: 1px solid rgba(255,255,255,0.03);
  }

  .detail-meta-row:last-child { border-bottom: none; }

  .meta-copy-btn {
    background: none;
    border: 1px solid transparent;
    color: var(--t-muted);
    cursor: pointer;
    padding: 2px 5px;
    border-radius: var(--r-small);
    font-size: var(--fs-xs);
    margin-left: 6px;
    transition: all var(--ease);
    line-height: 1;
  }
  .meta-copy-btn:hover {
    color: var(--t-primary);
    background: var(--s-hover);
    border-color: var(--b-light);
  }
  .meta-copy-btn.copied {
    color: var(--accent-blue);
  }

  #detail-delete-btn {
    display: block;
    width: 100%;
    margin-top: 16px;
    padding: 7px 0;
    background: rgba(255, 82, 82, 0.08);
    border: 1px solid rgba(255, 82, 82, 0.15);
    border-radius: 8px;
    color: rgba(255, 82, 82, 0.6);
    font-size: 15px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    letter-spacing: 0.03em;
  }
  #detail-delete-btn:hover {
    background: rgba(255, 82, 82, 0.15);
    border-color: rgba(255, 82, 82, 0.3);
    color: #FF5252;
  }
  .detail-delete-confirm {
    display: flex;
    gap: 8px;
    margin-top: 8px;
    align-items: center;
  }
  .detail-delete-confirm span {
    font-size: var(--fs-md);
    color: rgba(255,82,82,0.7);
    flex: 1;
  }
  .detail-delete-confirm button {
    font-size: var(--fs-sm);
    font-weight: 500;
    font-family: inherit;
    padding: 5px 14px;
    border-radius: var(--r-small);
    border: 1px solid var(--b-subtle);
    cursor: pointer;
    transition: all var(--ease);
  }
  .delete-confirm-yes {
    background: var(--accent-red-bg);
    color: var(--accent-red);
    border-color: rgba(255,82,82,0.12);
  }
  .delete-confirm-yes:hover {
    background: var(--accent-red-hover);
  }
  .delete-confirm-no {
    background: var(--s-subtle);
    color: var(--t-muted);
  }
  .delete-confirm-no:hover {
    background: var(--s-hover);
    color: var(--t-primary);
  }

  /* ═══════════════════════════════════════════
     STATS BAR (bottom)
     ═══════════════════════════════════════════ */
  #stats-bar {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    padding: 8px 22px;
    display: flex;
    align-items: center;
    gap: 20px;
    font-size: 13px;
    font-weight: 500;
    color: rgba(255,255,255,0.35);
    letter-spacing: 0.03em;
  }

  .stat-value { color: rgba(255,255,255,0.6); font-weight: 600; }

  .stat-divider {
    width: 1px;
    height: 14px;
    background: rgba(255,255,255,0.08);
  }

  /* ═══════════════════════════════════════════
     LOADING STATE
     ═══════════════════════════════════════════ */
  #loading-overlay {
    position: fixed;
    inset: 0;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: #000000;
    transition: opacity 0.8s;
  }

  #loading-overlay.hidden {
    opacity: 0;
    pointer-events: none;
  }

  #loading-text {
    font-size: 15px;
    font-weight: 500;
    letter-spacing: 0.4em;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.45);
    animation: pulse 2.5s ease-in-out infinite;
  }

  #loading-sub {
    font-size: 15px;
    font-weight: 400;
    color: rgba(255,255,255,0.15);
    margin-top: 12px;
    letter-spacing: 0.1em;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.4; }
    50% { opacity: 1; }
  }

  /* ═══════════════════════════════════════════
     TOOLTIP
     ═══════════════════════════════════════════ */
  #tooltip {
    position: fixed;
    z-index: 200;
    padding: 10px 18px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.15s;
    font-size: 15px;
    max-width: 320px;
  }

  #tooltip.visible { opacity: 1; }
  #tooltip-category { font-size: 13px; letter-spacing: 0.15em; text-transform: uppercase; }
  #tooltip-preview { color: rgba(255,255,255,0.6); margin-top: 5px; font-size: 14px; line-height: 1.45; }
  #tooltip-importance { color: #FFD700; font-size: 14px; margin-top: 4px; }
</style>
</head>
<body>

<!-- Loading -->
<div id="loading-overlay">
  <div id="loading-text">Connecting</div>
  <div id="loading-sub">Initializing neural pathways...</div>
</div>

<!-- Tooltip -->
<div id="tooltip" class="glass">
  <div id="tooltip-category"></div>
  <div id="tooltip-preview"></div>
  <div id="tooltip-importance"></div>
</div>

<!-- Title Bar -->
<div id="title-bar" class="glass">
  <div class="status-dot" id="status-dot"></div>
  <h1>Neural Memory Interface</h1>
  <button id="reset-positions-btn">Reset Layout</button>
  <button id="help-btn" title="Keyboard shortcuts">?</button>
</div>

<!-- Help Modal -->
<div id="help-overlay">
  <div id="help-modal" class="glass" style="position:relative;">
    <button id="help-close">&times;</button>
    <h2>Controls</h2>

    <div class="help-section">
      <div class="help-section-title">Keyboard</div>
      <div class="help-row"><div class="help-keys"><span class="help-key">/</span></div><span class="help-desc">Focus search</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Esc</span></div><span class="help-desc">Close panel / clear search</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Enter</span></div><span class="help-desc">Save layout (when naming)</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">?</span></div><span class="help-desc">Toggle this help</span></div>
    </div>

    <div class="help-section">
      <div class="help-section-title">Mouse &mdash; Graph</div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Click</span><span class="help-key">Node</span></div><span class="help-desc">Select &amp; inspect memory</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Drag</span><span class="help-key">Node</span></div><span class="help-desc">Move &amp; pin node in place</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Hover</span><span class="help-key">Node</span></div><span class="help-desc">Show tooltip preview</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Click</span><span class="help-key">Background</span></div><span class="help-desc">Deselect / close detail panel</span></div>
    </div>

    <div class="help-section">
      <div class="help-section-title">Mouse &mdash; Camera (Orbit)</div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Left Drag</span></div><span class="help-desc">Rotate camera</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Right Drag</span></div><span class="help-desc">Pan camera</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Scroll</span></div><span class="help-desc">Zoom in / out</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Move</span></div><span class="help-desc">Repel nearby background particles</span></div>
    </div>

    <div class="help-section">
      <div class="help-section-title">Panels</div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Drag</span><span class="help-key">Grip</span></div><span class="help-desc">Move panel</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Drag</span><span class="help-key">Edge</span></div><span class="help-desc">Resize panel</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Pin</span><span class="help-key">&#x1F4CC;</span></div><span class="help-desc">Lock panel position &amp; size</span></div>
    </div>

    <div class="help-section">
      <div class="help-section-title">Sidebar</div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Click</span><span class="help-key">Category</span></div><span class="help-desc">Toggle category visibility</span></div>
    </div>
  </div>
</div>

<!-- Search + Layouts -->
<div id="search-container">
  <div id="search-wrapper">
    <input type="text" id="search-input" placeholder="Search memories..." autocomplete="off" spellcheck="false">
    <span id="search-badge"></span>
    <button id="search-clear">&times;</button>
  </div>
  <div style="position:relative">
    <button id="bookmarks-btn" class="toolbar-btn"><svg viewBox="0 0 24 24"><path d="M5 5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16l-7-4-7 4V5z"/></svg>Bookmarks<span class="count-badge count-badge--gold" id="bookmark-count"></span></button>
    <div id="bookmarks-panel" class="glass dropdown-panel">
      <div id="bookmarks-list"></div>
    </div>
  </div>
  <button id="layouts-btn" class="toolbar-btn">Layouts</button>
  <!-- Layouts Panel -->
  <div id="layouts-panel" class="glass dropdown-panel">
    <div class="preset-save-bar">
      <input type="text" id="preset-name-input" placeholder="Layout name..." autocomplete="off" spellcheck="false" maxlength="40">
      <button id="preset-save-btn">Save</button>
    </div>
    <div class="preset-warning" id="preset-warning">No pinned nodes to save</div>
    <div class="preset-list" id="preset-list"></div>
  </div>
</div>

<!-- Category Sidebar -->
<div id="category-sidebar" class="glass resizable">
  <div class="resize-handle resize-handle-t" data-resize="t"></div>
  <div class="resize-handle resize-handle-b" data-resize="b"></div>
  <div class="resize-handle resize-handle-l" data-resize="l"></div>
  <div class="resize-handle resize-handle-r" data-resize="r"></div>
  <div class="resize-handle resize-handle-tl" data-resize="tl"></div>
  <div class="resize-handle resize-handle-tr" data-resize="tr"></div>
  <div class="resize-handle resize-handle-bl" data-resize="bl"></div>
  <div class="resize-handle resize-handle-br" data-resize="br"></div>
  <button class="pin-btn" data-pin="category-sidebar" title="Pin panel"><svg viewBox="0 0 24 24"><path d="M9 4v4.5L7.5 10H6v2h4v7l2 1 2-1v-7h4v-2h-1.5L15 8.5V4H9z" stroke-linejoin="round" stroke-linecap="round"/></svg></button>
  <div class="drag-handle" data-drag="category-sidebar"><div class="drag-grip"></div></div>
  <div id="sidebar-title"><span>Categories</span><span class="sidebar-title-actions"><button id="category-select-all-btn" title="Select all categories">All</button><button id="category-clear-btn" title="Deselect all categories">None</button></span></div>
  <div id="category-list"></div>
  <div style="display:flex;gap:8px;padding:0 12px;margin-bottom:8px;">
    <button id="category-add-btn" style="flex:1;" title="Add category"><svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>Category</button>
    <button id="category-add-parent-btn" style="flex:1;" title="Add parent category"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>Parent</button>
  </div>
  <div style="display:flex;gap:8px;padding:0 12px;margin-bottom:8px;">
    <button id="settings-btn" style="flex:1;" title="Settings"><svg viewBox="0 0 24 24"><path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>Settings</button>
  </div>
  <div id="category-create-form" data-mode="child">
    <div id="cat-form-title" style="font-weight:600;padding:8px 12px 4px;color:#aaa;font-size:11px;text-transform:uppercase;letter-spacing:0.5px;">Create Category</div>
    <input class="category-create-input" id="cat-name-input" placeholder="category-name" maxlength="30" spellcheck="false">
    <input class="category-create-input" id="cat-desc-input" placeholder="Short description...">
    <select class="modal-select" id="cat-parent-select">
      <option value="">(None - standalone category)</option>
    </select>
    <div class="color-swatch-row" id="color-swatch-row"></div>
    <div class="category-form-error" id="cat-form-error"></div>
    <div class="category-form-actions">
      <button class="category-form-btn-cancel" id="cat-form-cancel">Cancel</button>
      <button class="category-form-btn-create" id="cat-form-create" disabled>Create</button>
    </div>
  </div>
</div>

<!-- Detail Panel -->
<div id="detail-panel" class="glass resizable">
  <div class="resize-handle resize-handle-t" data-resize="t"></div>
  <div class="resize-handle resize-handle-b" data-resize="b"></div>
  <div class="resize-handle resize-handle-l" data-resize="l"></div>
  <div class="resize-handle resize-handle-r" data-resize="r"></div>
  <div class="resize-handle resize-handle-tl" data-resize="tl"></div>
  <div class="resize-handle resize-handle-tr" data-resize="tr"></div>
  <div class="resize-handle resize-handle-bl" data-resize="bl"></div>
  <div class="resize-handle resize-handle-br" data-resize="br"></div>
  <button class="pin-btn" data-pin="detail-panel" title="Pin panel"><svg viewBox="0 0 24 24"><path d="M9 4v4.5L7.5 10H6v2h4v7l2 1 2-1v-7h4v-2h-1.5L15 8.5V4H9z" stroke-linejoin="round" stroke-linecap="round"/></svg></button>
  <div class="drag-handle" data-drag="detail-panel"><div class="drag-grip"></div></div>
  <button id="detail-bookmark-btn" class="icon-btn icon-btn--gold" title="Bookmark this memory"><svg viewBox="0 0 24 24" fill="none"><path d="M5 5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16l-7-4-7 4V5z"/></svg></button>
  <button id="detail-close">&times;</button>
  <div id="detail-category"><div id="detail-category-row"><span id="detail-category-label"></span><button id="detail-change-cat-btn"><svg viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"/></svg>Change</button></div></div>
  <div id="detail-importance-row">
    <div id="detail-importance"></div>
    <button id="detail-focus-btn" title="Show only linked memories">Show Linked</button>
  </div>
  <div class="content-edit-wrap">
    <button id="content-edit-btn" class="content-edit-btn" title="Edit content"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg></button>
    <div id="detail-content"></div>
  </div>
  <div id="detail-tags" class="detail-section">
    <div class="detail-label">Tags</div>
    <div class="tag-chips" id="detail-tag-chips"></div>
  </div>
  <div id="detail-meta" class="detail-section">
    <div class="detail-label">Metadata</div>
    <div class="detail-meta" id="detail-meta-content"></div>
  </div>
  <div id="detail-files" class="detail-section" style="display:none">
    <div class="detail-label">Related Files</div>
    <div class="detail-meta" id="detail-files-content"></div>
  </div>
  <div id="detail-delete-zone"></div>
</div>

<!-- Stats Bar -->
<div id="stats-bar" class="glass">
  <div>Memories: <span class="stat-value" id="stat-total">0</span></div>
  <div class="stat-divider"></div>
  <div>Visible: <span class="stat-value" id="stat-visible">0</span></div>
  <div class="stat-divider"></div>
  <div>Links: <span class="stat-value" id="stat-links">0</span></div>
  <div class="stat-divider"></div>
  <div id="stat-search-status"></div>
</div>

<!-- Graph -->
<div id="graph-container"></div>

<script type="module">
// ═══════════════════════════════════════════
// IMPORTS (all ESM, pinned Three.js version)
// ═══════════════════════════════════════════
import * as THREE from 'https://esm.sh/three@0.169.0';
import ForceGraph3D from 'https://esm.sh/3d-force-graph@1.73.4?deps=three@0.169.0';
import { UnrealBloomPass } from 'https://esm.sh/three@0.169.0/examples/jsm/postprocessing/UnrealBloomPass.js';
import TWEEN from 'https://esm.sh/@tweenjs/tween.js@23.1.3';

// ═══════════════════════════════════════════
// CONSTANTS
// ═══════════════════════════════════════════
const DEFAULT_COLOR = '#888888';

const COLOR_PALETTE = [
  '#5B9BD5', '#70AD47', '#FFC000', '#ED7D31', '#44C8F5',
  '#A5A5A5', '#448AFF', '#FF6B9D', '#FFD700', '#E040FB',
  '#00BFA5', '#FF6E40', '#7C4DFF', '#18FFFF', '#EEFF41',
  '#F4511E', '#69F0AE', '#EA80FC', '#FFD740', '#40C4FF',
  '#B2FF59', '#00E5FF', '#B388FF', '#FF5252', '#D32F2F',
  '#64FFDA', '#536DFE', '#FF4081',
];

// All known category names (fetched from server)
let allCategoryNames = [];
let categoryDescriptions = {};

function catColor(category) {
  // 1. User override from localStorage (highest priority)
  try {
    const overrides = JSON.parse(localStorage.getItem('neural-category-colors') || '{}');
    if (overrides[category]) return overrides[category];
  } catch {}
  // 2. Backend color from category metadata
  if (categoryMetadata[category]?.color) {
    return categoryMetadata[category].color;
  }
  // 3. Index-based from palette (deterministic — same position = same color)
  const idx = allCategoryNames.indexOf(category);
  if (idx >= 0) return COLOR_PALETTE[idx % COLOR_PALETTE.length];
  // 4. Hash-based fallback for unknown categories
  let hash = 0;
  for (let i = 0; i < category.length; i++) hash = ((hash << 5) - hash + category.charCodeAt(i)) | 0;
  return COLOR_PALETTE[Math.abs(hash) % COLOR_PALETTE.length];
}

function importanceToRadius(importance) {
  return 2 + (importance - 1) * 0.5; // 2 to 6.5
}

function truncate(str, len) {
  if (!str) return '';
  return str.length > len ? str.slice(0, len) + '...' : str;
}

// ═══════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════
let allNodes = [];
let allLinks = [];
let activeCategories = new Set();
let selectedNodeId = null;
let hoveredNodeId = null;
let focusedNodeId = null;
let searchResults = null; // null = no search, Set of IDs = search active
let graph = null;
let bgLayers = []; // multiple particle layers
let particleBasePositions = []; // original positions for mouse interaction
let animFrameId = null;
let mouse3D = new THREE.Vector3(0, 0, 0); // projected mouse position in 3D
let mouseScreen = { x: 0, y: 0 };
let raycaster = new THREE.Raycaster();

// ═══════════════════════════════════════════
// DOM REFS
// ═══════════════════════════════════════════
const $loading = document.getElementById('loading-overlay');
const $statusDot = document.getElementById('status-dot');
const $searchInput = document.getElementById('search-input');
const $searchWrapper = document.getElementById('search-wrapper');
const $searchBadge = document.getElementById('search-badge');
const $searchClear = document.getElementById('search-clear');
const $categoryList = document.getElementById('category-list');
const $detailPanel = document.getElementById('detail-panel');
const $statTotal = document.getElementById('stat-total');
const $statVisible = document.getElementById('stat-visible');
const $statLinks = document.getElementById('stat-links');
const $statSearch = document.getElementById('stat-search-status');
const $tooltip = document.getElementById('tooltip');

document.getElementById('category-clear-btn').addEventListener('click', () => {
  activeCategories.clear();
  document.querySelectorAll('.category-chip').forEach(c => c.classList.add('inactive'));
  applyGraphData();
  updateStats();
});

document.getElementById('category-select-all-btn').addEventListener('click', () => {
  const presentCats = new Set(allNodes.map(n => n.payload.category));
  activeCategories = new Set([...presentCats, ...allCategoryNames]);
  document.querySelectorAll('.category-chip').forEach(c => c.classList.remove('inactive'));
  applyGraphData();
  updateStats();
});

// ═══════════════════════════════════════════
// GRAPH INIT
// ═══════════════════════════════════════════
async function init() {
  try {
    // Fetch all memories
    const res = await fetch('/api/memories');
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();

    allNodes = data.nodes;
    allLinks = data.links;

    $statusDot.classList.add('connected');
    $statTotal.textContent = allNodes.length;

    // Fetch category definitions from server
    await fetchCategories();

    // Discover all categories present
    const presentCats = new Set(allNodes.map(n => n.payload.category));
    activeCategories = new Set([...presentCats, ...allCategoryNames]);

    buildCategorySidebar(presentCats);
    buildGraph();
    updateStats();

    // Restore last selected memory
    const savedNodeId = localStorage.getItem('neural-selected-node');
    if (savedNodeId) {
      const savedNode = allNodes.find(n => n.id === savedNodeId);
      if (savedNode) {
        selectedNodeId = savedNodeId;
        showDetailPanel(savedNode);
      }
    }

    // Fade out loading
    setTimeout(() => $loading.classList.add('hidden'), 400);

  } catch (err) {
    console.error('Init error:', err);
    $statusDot.classList.add('error');
    document.getElementById('loading-text').textContent = 'Connection Failed';
    document.getElementById('loading-sub').textContent = err.message;
  }
}

function buildGraph() {
  const container = document.getElementById('graph-container');

  graph = ForceGraph3D({ controlType: 'orbit' })(container)
    .backgroundColor('#000000')
    .showNavInfo(false)
    .nodeId('id')
    .nodeLabel(() => '') // We use custom tooltip
    .nodeThreeObject(createNodeObject)
    .nodeThreeObjectExtend(false)
    .linkSource('source')
    .linkTarget('target')
    .linkColor(link => {
      const sourceNode = allNodes.find(n => n.id === (link.source.id || link.source));
      return sourceNode ? catColor(sourceNode.payload.category) : '#333';
    })
    .linkOpacity(0.12)
    .linkWidth(0)
    .linkCurvature(link => 0.15 + link.strength * 0.1)
    .linkCurveRotation(link => {
      // Deterministic rotation per link so curves don't all bow the same way
      const sid = typeof link.source === 'object' ? link.source.id : link.source;
      let h = 0;
      for (let i = 0; i < sid.length; i++) h = ((h << 5) - h + sid.charCodeAt(i)) | 0;
      return (h % 628) / 100;
    })
    .linkThreeObjectExtend(true)
    .linkThreeObject(link => {
      const sourceNode = allNodes.find(n => n.id === (link.source.id || link.source));
      const color = new THREE.Color(sourceNode ? catColor(sourceNode.payload.category) : '#333');
      const width = 0.15 + link.strength * 0.5;

      // Glow tube — a stretched sprite along the link direction
      const mat = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.08 + link.strength * 0.12,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      const geo = new THREE.CylinderGeometry(width * 0.5, width * 0.5, 1, 16, 1, true);
      geo.translate(0, 0.5, 0);
      geo.rotateX(Math.PI / 2);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.userData.isLinkGlow = true;
      mesh.userData.strength = link.strength;
      mesh.userData.baseOpacity = 0.08 + link.strength * 0.12;
      mesh.userData.phase = Math.random() * Math.PI * 2;
      return mesh;
    })
    .linkPositionUpdate((obj, { start, end }, link) => {
      if (!obj.userData.isLinkGlow) return;
      const dx = end.x - start.x, dy = end.y - start.y, dz = end.z - start.z;
      const len = Math.sqrt(dx * dx + dy * dy + dz * dz);
      obj.position.set(start.x, start.y, start.z);
      obj.lookAt(end.x, end.y, end.z);
      obj.scale.set(1, 1, len);
    })
    .linkDirectionalParticles(0)
    .onNodeHover(handleNodeHover)
    .onNodeClick(handleNodeClick)
    .onBackgroundClick(handleBackgroundClick)
    .onNodeDragEnd(node => {
      // Pin node at its dropped position
      node.fx = node.x;
      node.fy = node.y;
      node.fz = node.z;
    })
    .warmupTicks(80)
    .cooldownTicks(200)
    .d3AlphaDecay(0.02)
    .d3VelocityDecay(0.3);

  // Force configuration
  graph.d3Force('charge').strength(-120);
  graph.d3Force('link').distance(link => 60 / (link.strength + 0.1));

  // Enable hardware acceleration and performance optimizations
  const renderer = graph.renderer();
  if (renderer) {
    renderer.antialias = true;
    renderer.powerPreference = 'high-performance';
    renderer.precision = 'highp';

    // Enable hardware acceleration features
    const gl = renderer.getContext();
    if (gl) {
      gl.enable(gl.DEPTH_TEST);
      gl.enable(gl.CULL_FACE);
    }

    // Optimize rendering
    renderer.sortObjects = false; // Skip sorting for better performance
    renderer.info.autoReset = false; // Manual reset for perf monitoring
  }

  // Apply data
  applyGraphData();

  // Add bloom post-processing — strong glow for living nodes
  const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    0.8,   // strength — subtle glow, prevents blobbing on tight clusters
    0.4,   // radius — tighter bloom spread
    0.25   // threshold — only brighter elements bloom
  );
  graph.postProcessingComposer().addPass(bloomPass);

  // Add background particles + mouse tracking
  addBackgroundParticles();
  setupMouseTracking();

  // Start animation loop
  animate();
}

// Cached nebula sprite textures per color (organic, asymmetric)
const _glowTexCache = {};

// Simplex-ish 2D noise (fast, good enough for texture gen)
function _hash2D(x, y) {
  let h = (x * 374761393 + y * 668265263 + 1013904223) | 0;
  h = ((h >> 13) ^ h) * 1274126177;
  return ((h >> 16) ^ h) & 0x7fffffff;
}
function _smoothNoise(x, y) {
  const ix = Math.floor(x), iy = Math.floor(y);
  const fx = x - ix, fy = y - iy;
  const sx = fx * fx * (3 - 2 * fx), sy = fy * fy * (3 - 2 * fy);
  const n00 = _hash2D(ix, iy) / 0x7fffffff;
  const n10 = _hash2D(ix + 1, iy) / 0x7fffffff;
  const n01 = _hash2D(ix, iy + 1) / 0x7fffffff;
  const n11 = _hash2D(ix + 1, iy + 1) / 0x7fffffff;
  return n00 * (1 - sx) * (1 - sy) + n10 * sx * (1 - sy) + n01 * (1 - sx) * sy + n11 * sx * sy;
}
function fbmNoise(x, y, octaves = 4) {
  let val = 0, amp = 0.5, freq = 1;
  for (let i = 0; i < octaves; i++) {
    val += amp * _smoothNoise(x * freq, y * freq);
    amp *= 0.5;
    freq *= 2.1;
  }
  return val;
}

function getGlowTexture(hexColor, seed, texSize) {
  const key = hexColor.getHexString() + '_' + (seed || 0);
  if (_glowTexCache[key]) return _glowTexCache[key];

  const size = texSize || 128;
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  const c = size / 2;
  const rr = hexColor.r * 180, gg = hexColor.g * 180, bb = hexColor.b * 180;
  const s = seed || 0;

  const imgData = ctx.createImageData(size, size);
  const d = imgData.data;

  for (let py = 0; py < size; py++) {
    for (let px = 0; px < size; px++) {
      const dx = (px - c) / c;
      const dy = (py - c) / c;
      const dist = Math.sqrt(dx * dx + dy * dy);

      // Base radial falloff (smooth, nebula-like)
      let alpha = 0;
      if (dist < 1) {
        const r2 = dist * dist;
        alpha = Math.exp(-r2 * 3.5) * 0.95;

        // Organic noise distortion — breaks the perfect circle
        const nx = dx * 3.2 + s * 7.3;
        const ny = dy * 3.2 + s * 13.1;
        const noise = fbmNoise(nx, ny, 4);
        // Warp alpha by noise — creates wisps and tendrils
        alpha *= 0.4 + noise * 1.2;
        // Secondary large-scale structure
        const bigNoise = fbmNoise(dx * 1.5 + s * 3.7, dy * 1.5 + s * 9.2, 2);
        alpha *= 0.6 + bigNoise * 0.8;

        // Soft edge clamp
        if (dist > 0.7) alpha *= (1 - (dist - 0.7) / 0.3);
      }

      alpha = Math.max(0, Math.min(1, alpha));

      const idx = (py * size + px) * 4;
      d[idx]     = rr * alpha | 0;
      d[idx + 1] = gg * alpha | 0;
      d[idx + 2] = bb * alpha | 0;
      d[idx + 3] = alpha * 255 | 0;
    }
  }

  ctx.putImageData(imgData, 0, 0);

  const tex = new THREE.CanvasTexture(canvas);
  tex.needsUpdate = true;
  _glowTexCache[key] = tex;
  return tex;
}

// Link glow texture — soft horizontal streak for tube-like links
let _linkGlowTex = null;
function getLinkGlowTexture() {
  if (_linkGlowTex) return _linkGlowTex;
  const w = 64, h = 16;
  const canvas = document.createElement('canvas');
  canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext('2d');
  const grad = ctx.createLinearGradient(0, 0, 0, h);
  grad.addColorStop(0, 'rgba(255,255,255,0)');
  grad.addColorStop(0.35, 'rgba(255,255,255,0.12)');
  grad.addColorStop(0.5, 'rgba(255,255,255,0.4)');
  grad.addColorStop(0.65, 'rgba(255,255,255,0.12)');
  grad.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, w, h);
  _linkGlowTex = new THREE.CanvasTexture(canvas);
  _linkGlowTex.wrapS = THREE.RepeatWrapping;
  _linkGlowTex.needsUpdate = true;
  return _linkGlowTex;
}

// Orbiter texture — soft glowing dot
const _orbiterTexCache = {};
function getOrbiterTexture(hexColor) {
  const key = hexColor.getHexString();
  if (_orbiterTexCache[key]) return _orbiterTexCache[key];
  const size = 64;
  const canvas = document.createElement('canvas');
  canvas.width = size; canvas.height = size;
  const ctx = canvas.getContext('2d');
  const c = size / 2;
  const r = hexColor.r * 255 | 0, g = hexColor.g * 255 | 0, b = hexColor.b * 255 | 0;
  const grad = ctx.createRadialGradient(c, c, 0, c, c, c);
  grad.addColorStop(0, `rgba(${r},${g},${b},1)`);
  grad.addColorStop(0.15, `rgba(${r},${g},${b},0.7)`);
  grad.addColorStop(0.4, `rgba(${r},${g},${b},0.2)`);
  grad.addColorStop(0.7, `rgba(${r},${g},${b},0.05)`);
  grad.addColorStop(1, `rgba(${r},${g},${b},0)`);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, size, size);
  const tex = new THREE.CanvasTexture(canvas);
  tex.needsUpdate = true;
  _orbiterTexCache[key] = tex;
  return tex;
}

// Per-node seed counter for unique nebula textures
let _nodeSeedCounter = 0;

function createNodeObject(node) {
  const color = catColor(node.payload.category);
  const importance = node.payload.importance || 5;
  const radius = importanceToRadius(importance);
  const hex = new THREE.Color(color);
  const seed = _nodeSeedCounter++;

  const group = new THREE.Group();

  // Darken the color for nodes
  const darkHex = hex.clone().multiplyScalar(0.55);

  // Small core sphere — slightly irregular
  const coreGeo = new THREE.SphereGeometry(radius * 0.35, 12, 12);
  const coreMat = new THREE.MeshBasicMaterial({
    color: darkHex.clone().multiplyScalar(1.4),
    transparent: true,
    opacity: 0.85,
    depthWrite: false,
  });
  const core = new THREE.Mesh(coreGeo, coreMat);
  group.add(core);

  // Invisible hitbox sphere — extends into inner bloom for easier clicking
  const hitboxGeo = new THREE.SphereGeometry(radius * 1.8, 8, 8);
  const hitboxMat = new THREE.MeshBasicMaterial({
    transparent: true,
    opacity: 0,
    depthWrite: false,
  });
  const hitbox = new THREE.Mesh(hitboxGeo, hitboxMat);
  group.add(hitbox);

  // Primary nebula cloud — unique organic texture per node
  const glowTex = getGlowTexture(darkHex, seed);
  const spriteScale = radius * 6;
  const spriteMat = new THREE.SpriteMaterial({
    map: glowTex,
    transparent: true,
    opacity: 0.6,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
  });
  const sprite = new THREE.Sprite(spriteMat);
  sprite.scale.set(spriteScale, spriteScale, 1);
  sprite.raycast = () => {}; // no hit detection on clouds
  group.add(sprite);

  // Second cloud layer — different seed, offset and rotated for depth
  const glowTex2 = getGlowTexture(darkHex.clone().multiplyScalar(0.7), seed + 500);
  const cloud2Mat = new THREE.SpriteMaterial({
    map: glowTex2,
    transparent: true,
    opacity: 0.3,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    rotation: (seed * 1.7) % (Math.PI * 2),
  });
  const cloud2 = new THREE.Sprite(cloud2Mat);
  cloud2.scale.set(spriteScale * 1.3, spriteScale * 1.3, 1);
  cloud2.position.set(radius * 0.3, radius * -0.2, 0);
  cloud2.raycast = () => {};
  group.add(cloud2);

  // Outer haze — wide, faint envelope
  const hazeTex = getGlowTexture(darkHex.clone().multiplyScalar(0.5), seed + 1000);
  const hazeMat = new THREE.SpriteMaterial({
    map: hazeTex,
    transparent: true,
    opacity: 0.12,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    rotation: (seed * 2.3) % (Math.PI * 2),
  });
  const haze = new THREE.Sprite(hazeMat);
  haze.scale.set(spriteScale * 2.0, spriteScale * 2.0, 1);
  haze.raycast = () => {};
  group.add(haze);

  // Selection orbiters — synapse-style firing dots on multiple orbit rings
  const orbiters = [];
  const orbTex = getOrbiterTexture(hex);
  const orbTexDim = getOrbiterTexture(hex.clone().multiplyScalar(0.5));
  // Inner ring: small, fast sparks. Outer ring: larger, slower pulses. Halo: faint, wide drifters.
  const orbDefs = [
    // Inner ring — tight, zippy sparks
    { ring: 2.8, speed: 1.4,  size: 0.7,  tiltX:  0.4, tiltZ: -0.3, phase: 0,      fireFreq: 3.2, dim: false },
    { ring: 3.0, speed: 1.1,  size: 0.6,  tiltX: -0.6, tiltZ:  0.2, phase: 1.2,    fireFreq: 4.1, dim: false },
    { ring: 2.6, speed: 1.7,  size: 0.5,  tiltX:  0.2, tiltZ:  0.7, phase: 2.5,    fireFreq: 2.8, dim: true  },
    // Mid ring — primary orbiters
    { ring: 4.0, speed: 0.7,  size: 1.1,  tiltX:  0.3, tiltZ: -0.2, phase: 0.5,    fireFreq: 2.0, dim: false },
    { ring: 4.2, speed: 0.55, size: 1.0,  tiltX: -0.5, tiltZ:  0.1, phase: 2.1,    fireFreq: 1.6, dim: false },
    { ring: 3.8, speed: 0.85, size: 0.9,  tiltX:  0.1, tiltZ:  0.6, phase: 3.8,    fireFreq: 2.5, dim: false },
    // Outer halo — wide, faint, drifting
    { ring: 5.5, speed: 0.35, size: 1.4,  tiltX: -0.2, tiltZ: -0.5, phase: 1.0,    fireFreq: 1.2, dim: true  },
    { ring: 6.0, speed: 0.25, size: 1.6,  tiltX:  0.5, tiltZ:  0.3, phase: 4.0,    fireFreq: 0.9, dim: true  },
  ];
  for (let i = 0; i < orbDefs.length; i++) {
    const def = orbDefs[i];
    const mat = new THREE.SpriteMaterial({
      map: def.dim ? orbTexDim : orbTex,
      transparent: true,
      opacity: 0,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    });
    const s = new THREE.Sprite(mat);
    s.scale.set(radius * def.size, radius * def.size, 1);
    s.raycast = () => {};
    s.userData._orbDef = def;
    group.add(s);
    orbiters.push(s);
  }

  // Store refs
  group.userData.nodeId = node.id;
  group.userData.sphere = core;
  group.userData.sprite = sprite;
  group.userData.cloud2 = cloud2;
  group.userData.haze = haze;
  group.userData.orbiters = orbiters;
  group.userData.baseRadius = radius;
  group.userData.baseSpriteOpacity = 0.6;
  group.userData.baseCloud2Opacity = 0.3;
  group.userData.baseHazeOpacity = 0.12;
  group.userData.baseCoreOpacity = 0.85;
  group.userData.category = node.payload.category;
  group.userData.phase = Math.random() * Math.PI * 2;
  group.userData.importance = importance;
  group.userData.seed = seed;

  return group;
}

function createParticleTexture() {
  const size = 64;
  const canvas = document.createElement('canvas');
  canvas.width = size; canvas.height = size;
  const ctx = canvas.getContext('2d');
  const c = size / 2;
  const grad = ctx.createRadialGradient(c, c, 0, c, c, c);
  grad.addColorStop(0, 'rgba(255,255,255,1)');
  grad.addColorStop(0.12, 'rgba(255,255,255,0.7)');
  grad.addColorStop(0.35, 'rgba(255,255,255,0.2)');
  grad.addColorStop(0.65, 'rgba(255,255,255,0.03)');
  grad.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, size, size);
  const tex = new THREE.CanvasTexture(canvas);
  tex.needsUpdate = true;
  return tex;
}

// Per-particle velocity arrays
let particleVelocities = [];

function addBackgroundParticles() {
  const particleTex = createParticleTexture();

  // Dense, bright particle field — visible and reactive
  const layers = [
    { count: 4000, spread: 1200, size: 2.0,  color: 0x334466, opacity: 0.35, speed: 0.003 },
    { count: 4000, spread: 800,  size: 3.2,  color: 0x446688, opacity: 0.5,  speed: 0.005 },
    { count: 3000, spread: 500,  size: 4.5,  color: 0x5577aa, opacity: 0.55, speed: 0.008 },
    { count: 1200, spread: 400,  size: 6.5,  color: 0x6688bb, opacity: 0.4,  speed: 0.012 },
    { count: 400,  spread: 600,  size: 9.0,  color: 0x7799cc, opacity: 0.2,  speed: 0.004 },
  ];

  bgLayers = [];
  particleBasePositions = [];
  particleVelocities = [];

  layers.forEach((cfg, layerIdx) => {
    const positions = new Float32Array(cfg.count * 3);
    const basePos = new Float32Array(cfg.count * 3);
    const velocities = new Float32Array(cfg.count * 3);

    for (let i = 0; i < cfg.count; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const u = Math.random();
      const r = cfg.spread * (0.05 + Math.pow(u, 0.7) * 0.95);
      const x = r * Math.sin(phi) * Math.cos(theta);
      const y = r * Math.sin(phi) * Math.sin(theta);
      const z = r * Math.cos(phi);
      positions[i * 3]     = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;
      basePos[i * 3]       = x;
      basePos[i * 3 + 1]   = y;
      basePos[i * 3 + 2]   = z;
      velocities[i * 3]     = 0;
      velocities[i * 3 + 1] = 0;
      velocities[i * 3 + 2] = 0;
    }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    const mat = new THREE.PointsMaterial({
      color: cfg.color,
      size: cfg.size,
      map: particleTex,
      transparent: true,
      opacity: cfg.opacity,
      sizeAttenuation: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });

    const points = new THREE.Points(geo, mat);
    points.userData.layerIdx = layerIdx;
    points.userData.speed = cfg.speed;
    points.userData.spread = cfg.spread;

    graph.scene().add(points);
    bgLayers.push(points);
    particleBasePositions.push(basePos);
    particleVelocities.push(velocities);
  });
}

// Mouse tracking — project screen coords into 3D for particle interaction
function setupMouseTracking() {
  const container = document.getElementById('graph-container');

  container.addEventListener('mousemove', (e) => {
    mouseScreen.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouseScreen.y = -(e.clientY / window.innerHeight) * 2 + 1;

    // Project mouse into 3D scene at z=0 plane
    if (graph) {
      const camera = graph.camera();
      raycaster.setFromCamera(new THREE.Vector2(mouseScreen.x, mouseScreen.y), camera);
      const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
      const intersect = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, intersect);
      if (intersect) {
        mouse3D.copy(intersect);
      }
    }
  });
}

// ═══════════════════════════════════════════
// ANIMATION LOOP
// ═══════════════════════════════════════════
function animate() {
  animFrameId = requestAnimationFrame(animate);
  const time = performance.now() * 0.001;

  TWEEN.update();

  // Animate particles — momentum physics + mouse repulsion
  const MOUSE_RADIUS = 250;
  const PUSH_FORCE = 12;
  const SPRING = 0.008;
  const DAMPING = 0.92;

  bgLayers.forEach((layer, layerIdx) => {
    const speed = layer.userData.speed;

    // Gentle layer rotation
    layer.rotation.y = time * speed;
    layer.rotation.x = Math.sin(time * speed * 0.5 + layerIdx) * 0.06;

    const posAttr = layer.geometry.getAttribute('position');
    const basePos = particleBasePositions[layerIdx];
    const vel = particleVelocities[layerIdx];
    const positions = posAttr.array;

    // Mouse in layer local space
    const invMatrix = layer.matrixWorld.clone().invert();
    const localMouse = mouse3D.clone().applyMatrix4(invMatrix);

    for (let i = 0; i < posAttr.count; i++) {
      const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;

      // Vector from mouse to particle
      const dx = positions[ix] - localMouse.x;
      const dy = positions[iy] - localMouse.y;
      const dz = positions[iz] - localMouse.z;
      const distSq = dx * dx + dy * dy + dz * dz;
      const dist = Math.sqrt(distSq);

      // Mouse repulsion — inverse-square falloff for natural feel
      if (dist < MOUSE_RADIUS && dist > 1) {
        const falloff = 1 - dist / MOUSE_RADIUS;
        const force = PUSH_FORCE * falloff * falloff;
        const invDist = 1 / dist;
        vel[ix] += dx * invDist * force;
        vel[iy] += dy * invDist * force;
        vel[iz] += dz * invDist * force;
      }

      // Spring force back to home position
      vel[ix] += (basePos[ix] - positions[ix]) * SPRING;
      vel[iy] += (basePos[iy] - positions[iy]) * SPRING;
      vel[iz] += (basePos[iz] - positions[iz]) * SPRING;

      // Damping (friction)
      vel[ix] *= DAMPING;
      vel[iy] *= DAMPING;
      vel[iz] *= DAMPING;

      // Integrate position
      positions[ix] += vel[ix];
      positions[iy] += vel[iy];
      positions[iz] += vel[iz];
    }

    posAttr.needsUpdate = true;
  });

  // Node animation
  if (graph) {
    const scene = graph.scene();
    scene.traverse(obj => {
      if (!obj.userData || !obj.userData.nodeId) return;

      const core = obj.userData.sphere;
      if (!core) return;
      const sprite = obj.userData.sprite;
      const cloud2 = obj.userData.cloud2;
      const haze = obj.userData.haze;

      const phase = obj.userData.phase;
      const imp = obj.userData.importance || 5;
      const baseR = obj.userData.baseRadius;
      const seed = obj.userData.seed || 0;

      // Organic breathing — layered sine waves for non-repeating feel
      const breatheSpeed = 0.7 + imp * 0.08;
      const breatheAmp = 0.03 + imp * 0.006;
      const breathe = 1
        + Math.sin(time * breatheSpeed + phase) * breatheAmp
        + Math.sin(time * breatheSpeed * 0.37 + phase * 2.1) * breatheAmp * 0.5;

      // Gas cloud pulsing — multi-frequency wobble
      const gasPulse = 1
        + Math.sin(time * 0.6 + phase * 1.3) * 0.05
        + Math.sin(time * 1.3 + phase * 0.7) * 0.03
        + Math.sin(time * 0.23 + phase * 3.1) * 0.04;

      let targetCore = obj.userData.baseCoreOpacity;
      let targetSprite = obj.userData.baseSpriteOpacity;
      let targetCloud2 = obj.userData.baseCloud2Opacity;
      let targetHaze = obj.userData.baseHazeOpacity;

      // Search state
      if (searchResults !== null) {
        if (searchResults.has(obj.userData.nodeId)) {
          targetCore = 1;
          targetSprite = 1;
          targetCloud2 = 0.6;
          targetHaze = 0.4;
        } else {
          targetCore = 0.08;
          targetSprite = 0.06;
          targetCloud2 = 0.02;
          targetHaze = 0.01;
        }
      }

      // Category filter
      if (!activeCategories.has(obj.userData.category)) {
        targetCore = 0;
        targetSprite = 0;
        targetCloud2 = 0;
        targetHaze = 0;
      }

      // Hovered — bright flare + scale pop
      const isHovered = obj.userData.nodeId === hoveredNodeId;
      if (isHovered) {
        targetCore = 1;
        targetSprite = 1;
        targetCloud2 = 0.7;
        targetHaze = 0.55;
      }

      // Selected — bright flare up (brighter than hover/search)
      const isSelected = obj.userData.nodeId === selectedNodeId;
      if (isSelected) {
        targetCore = 1;
        targetSprite = 1.25;  // Over-bright for glow
        targetCloud2 = 0.85;
        targetHaze = 0.75;
      }

      // Selection orbiters — synapse firing dots on multiple rings
      const orbiters = obj.userData.orbiters;
      if (orbiters) {
        const baseR2 = obj.userData.baseRadius;
        for (let oi = 0; oi < orbiters.length; oi++) {
          const orb = orbiters[oi];
          const def = orb.userData._orbDef;
          if (!def) continue;

          // Synapse fire — periodic brightness burst
          const fireWave = Math.sin(time * def.fireFreq + def.phase * 2.7 + oi);
          const isFiring = fireWave > 0.3;
          const fireIntensity = isFiring ? Math.pow((fireWave - 0.3) / 0.7, 0.5) : 0;

          // Base opacity: dim orbiters are fainter
          const baseOpacity = def.dim ? 0.25 : 0.55;
          const fireBoost = fireIntensity * (def.dim ? 0.4 : 0.6);
          const targetOrbOpacity = isSelected ? (baseOpacity + fireBoost) : 0;
          orb.material.opacity += (targetOrbOpacity - orb.material.opacity) * 0.1;

          if (isSelected || orb.material.opacity > 0.01) {
            const oR = baseR2 * def.ring;
            // Slight orbit radius wobble during fire
            const wobble = 1 + fireIntensity * 0.12 * Math.sin(time * 5 + oi);
            const angle = time * def.speed + phase + def.phase;
            const x = Math.cos(angle) * oR * wobble;
            const y = Math.sin(angle) * oR * Math.cos(def.tiltX) * wobble;
            const z = Math.sin(angle) * oR * Math.sin(def.tiltZ);
            orb.position.set(x, y, z);

            // Size: pulses bigger during fire
            const sizeBase = baseR2 * def.size;
            const sizePulse = 1 + Math.sin(time * 3 + oi * 1.7) * 0.15;
            const fireSwell = 1 + fireIntensity * 0.5;
            const s = sizeBase * sizePulse * fireSwell;
            orb.scale.set(s, s, 1);
          }
        }
      }

      // Lerp core
      core.material.opacity += (targetCore - core.material.opacity) * 0.08;

      // Primary cloud — slow rotation + opacity pulse
      if (sprite) {
        sprite.material.rotation += 0.0004 + (seed % 7) * 0.00005;
        const spriteTarget = targetSprite * (1 + Math.sin(time * 1.5 + phase) * 0.12);
        sprite.material.opacity += (spriteTarget - sprite.material.opacity) * 0.06;
        const s = baseR * 6 * gasPulse;
        sprite.scale.set(s, s, 1);
      }

      // Second cloud layer — counter-rotate for depth
      if (cloud2) {
        cloud2.material.rotation -= 0.0003 + (seed % 5) * 0.00004;
        const c2Target = targetCloud2 * (1 + Math.sin(time * 0.9 + phase * 1.7) * 0.18);
        cloud2.material.opacity += (c2Target - cloud2.material.opacity) * 0.05;
        const c2s = baseR * 6 * 1.3 * gasPulse * breathe;
        cloud2.scale.set(c2s, c2s, 1);
      }

      // Outer haze — very slow drift
      if (haze) {
        haze.material.rotation += 0.00015;
        haze.material.opacity += (targetHaze - haze.material.opacity) * 0.03;
        const h = baseR * 6 * 2.0 * gasPulse * breathe;
        haze.scale.set(h, h, 1);
      }

      // Breathing scale on the group + hover/selection pop
      let scaleMultiplier = 1;
      if (isSelected) scaleMultiplier = 1.55;  // Selected: biggest
      else if (isHovered) scaleMultiplier = 1.35;  // Hover: medium pop
      const targetScale = breathe * scaleMultiplier;
      // Smooth lerp so the pop animates in/out
      if (!obj.userData._currentScale) obj.userData._currentScale = 1;
      obj.userData._currentScale += (targetScale - obj.userData._currentScale) * 0.12;
      obj.scale.setScalar(obj.userData._currentScale);

    });

    // Link glow pulse — subtle breathing on each tube
    scene.traverse(obj => {
      if (!obj.userData || !obj.userData.isLinkGlow) return;
      const base = obj.userData.baseOpacity;
      const ph = obj.userData.phase;
      const str = obj.userData.strength;
      // Slow sine pulse — stronger links pulse more visibly
      const pulse = 1 + Math.sin(time * 0.8 + ph) * 0.3 * str
                      + Math.sin(time * 0.31 + ph * 2.3) * 0.15;
      obj.material.opacity = base * pulse;
    });
  }
}

// ═══════════════════════════════════════════
// INTERACTIONS
// ═══════════════════════════════════════════
let _pointerOverUI = false;
document.querySelectorAll('.glass, #search-container, #stats-bar').forEach(el => {
  el.addEventListener('pointerenter', () => { _pointerOverUI = true; }, true);
  el.addEventListener('pointerleave', () => { _pointerOverUI = false; }, true);
});

function handleNodeHover(node, prevNode) {
  if (_pointerOverUI) {
    $tooltip.classList.remove('visible');
    if ($tooltip._moveHandler) {
      document.removeEventListener('mousemove', $tooltip._moveHandler);
    }
    document.body.style.cursor = 'default';
    return;
  }
  document.body.style.cursor = node ? 'pointer' : 'default';
  hoveredNodeId = node ? node.id : null;

  if (node) {
    const cat = node.payload.category;
    const imp = node.payload.importance || 5;
    const preview = truncate(node.payload.content, 100);

    document.getElementById('tooltip-category').textContent = cat;
    document.getElementById('tooltip-category').style.color = catColor(cat);
    document.getElementById('tooltip-preview').textContent = preview;
    document.getElementById('tooltip-importance').textContent = '\u2605'.repeat(Math.min(imp, 10));

    // Position tooltip near cursor
    const moveTooltip = (e) => {
      $tooltip.style.left = (e.clientX + 16) + 'px';
      $tooltip.style.top = (e.clientY + 16) + 'px';
    };
    document.addEventListener('mousemove', moveTooltip);
    $tooltip._moveHandler = moveTooltip;
    $tooltip.classList.add('visible');
  } else {
    $tooltip.classList.remove('visible');
    if ($tooltip._moveHandler) {
      document.removeEventListener('mousemove', $tooltip._moveHandler);
    }
  }
}

function handleNodeClick(node) {
  if (!node || _pointerOverUI) return;
  navigateToNode(node);
}

function navigateToNode(node, { zoom = 'close' } = {}) {
  if (!node) return;
  selectedNodeId = node.id;
  localStorage.setItem('neural-selected-node', node.id);

  // Ensure category is visible
  if (!activeCategories.has(node.payload.category)) {
    activeCategories.add(node.payload.category);
    buildCategorySidebar();
  }

  // If focus mode is on, switch focus to the newly clicked node
  if (focusedNodeId !== null) {
    focusedNodeId = node.id;
    applyGraphData();
    updateStats();
  }

  // Camera transition
  const dist = zoom === 'gentle' ? 200 : 60;
  graph.cameraPosition(
    { x: node.x + dist, y: node.y + dist * 0.4, z: node.z + dist },
    { x: node.x, y: node.y, z: node.z },
    1500
  );

  showDetailPanel(node);
}

function closeDetailPanel() {
  const wasFocused = focusedNodeId !== null;
  selectedNodeId = null;
  focusedNodeId = null;
  localStorage.removeItem('neural-selected-node');
  $detailPanel.classList.remove('open');
  document.getElementById('detail-focus-btn').classList.remove('active');
  // Reset to CSS-default so the slide-out works even if user dragged it
  $detailPanel.style.left = '';
  $detailPanel.style.top = '';
  $detailPanel.style.right = '';
  // Restore full graph if focus was active
  if (wasFocused) {
    applyGraphData();
    updateStats();
  }
}

// Explosion effect — blast nearby background particles outward from a 3D point
function triggerParticleExplosion(worldPos, radius = 300, force = 50) {
  bgLayers.forEach((layer, layerIdx) => {
    const invMatrix = layer.matrixWorld.clone().invert();
    const localPos = worldPos.clone().applyMatrix4(invMatrix);

    const posAttr = layer.geometry.getAttribute('position');
    const positions = posAttr.array;
    const vel = particleVelocities[layerIdx];

    for (let i = 0; i < posAttr.count; i++) {
      const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;
      const dx = positions[ix] - localPos.x;
      const dy = positions[iy] - localPos.y;
      const dz = positions[iz] - localPos.z;
      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

      if (dist < radius && dist > 0.1) {
        const falloff = 1 - dist / radius;
        const impulse = force * falloff * falloff;
        const invDist = 1 / dist;
        vel[ix] += dx * invDist * impulse;
        vel[iy] += dy * invDist * impulse;
        vel[iz] += dz * invDist * impulse;
      }
    }
  });
}

async function deleteMemoryFromUI(node) {
  const deleteZone = document.getElementById('detail-delete-zone');
  const confirmBtn = deleteZone?.querySelector('.delete-confirm-yes');
  if (confirmBtn) { confirmBtn.textContent = 'Deleting...'; confirmBtn.disabled = true; }

  // Capture node's 3D position before deletion
  let explosionPos = null;
  if (graph) {
    const graphNodes = graph.graphData().nodes;
    const gn = graphNodes.find(n => n.id === node.id);
    if (gn && gn.x !== undefined) {
      explosionPos = new THREE.Vector3(gn.x, gn.y, gn.z || 0);
    }
  }

  try {
    const res = await fetch('/api/memory/' + encodeURIComponent(node.id), { method: 'DELETE' });
    if (!res.ok) {
      let errMsg = 'Delete failed (' + res.status + ')';
      try { const err = await res.json(); errMsg = err.error || errMsg; } catch {}
      console.error('deleteMemory error:', errMsg);
      if (confirmBtn) { confirmBtn.textContent = errMsg; confirmBtn.disabled = false; }
      return;
    }

    // Trigger particle explosion at the node's position
    if (explosionPos) triggerParticleExplosion(explosionPos);

    // Remove from local data
    allNodes = allNodes.filter(n => n.id !== node.id);
    allLinks = allLinks.filter(l => l.source !== node.id && l.target !== node.id &&
      l.source?.id !== node.id && l.target?.id !== node.id);

    // Close detail panel and rebuild
    closeDetailPanel();
    const presentCats = new Set(allNodes.map(n => n.payload.category));
    buildCategorySidebar(presentCats);
    applyGraphData();
    updateStats();
  } catch (e) {
    console.error('deleteMemory fetch error:', e);
    if (confirmBtn) { confirmBtn.textContent = e.message || 'Network error'; confirmBtn.disabled = false; }
  }
}

function handleBackgroundClick() {
  // Don't close detail panel on background click — bad UX
  // Panel should only close via the X button
}

function formatMemoryContent(text) {
  if (!text) return '';

  const esc = s => s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');

  // Inline formatting: `code`, **bold**, *italic*, em-dash descriptions
  function inlineFmt(s) {
    let out = esc(s);
    // Backtick code spans
    out = out.replace(/`([^`]+)`/g, '<code>$1</code>');
    // Bold
    out = out.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    // Italic
    out = out.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<em>$1</em>');
    // Em-dash description split (` — ` becomes dimmed after)
    out = out.replace(/ — (.+)$/, ' <span class="kv-desc">\u2014 $1</span>');
    return out;
  }

  const lines = text.split('\n');
  let html = '';
  let inList = false;
  let inCode = false;

  function closeList() { if (inList) { html += '</ul>'; inList = false; } }

  for (let i = 0; i < lines.length; i++) {
    const raw = lines[i];
    const trimmed = raw.trim();

    // Empty line
    if (!trimmed) {
      if (inCode) { html += '\n'; continue; }
      closeList();
      continue;
    }

    // Code block fences
    if (trimmed.startsWith('```')) {
      if (inCode) { html += '</div>'; inCode = false; }
      else { closeList(); inCode = true; html += '<div class="mc-codeblock">'; }
      continue;
    }
    if (inCode) { html += esc(raw) + '\n'; continue; }

    // Markdown headings ## / ### / ####
    const headingMatch = trimmed.match(/^(#{1,4})\s+(.+)$/);
    if (headingMatch) {
      closeList();
      const level = headingMatch[1].length;
      const cls = level <= 2 ? 'mc-h2' : level === 3 ? 'mc-h3' : 'mc-h4';
      html += `<div class="${cls}">${inlineFmt(headingMatch[2])}</div>`;
      continue;
    }

    // Separator lines
    if (/^[-=_]{3,}$/.test(trimmed)) {
      closeList();
      html += '<div class="mc-divider"></div>';
      continue;
    }

    // Standalone backtick line (full line is a code key pattern)
    if (trimmed.startsWith('`') && trimmed.endsWith('`') && !trimmed.includes(' ')) {
      closeList();
      html += `<p>${inlineFmt(trimmed)}</p>`;
      continue;
    }

    // Backtick line followed by em-dash description
    if (/^`[^`]+`\s+—\s+/.test(trimmed)) {
      closeList();
      html += `<p>${inlineFmt(trimmed)}</p>`;
      continue;
    }

    // List items (- or * or numbered)
    if (/^[-*\u2022]\s/.test(trimmed) || /^\d+[.)]\s/.test(trimmed)) {
      if (!inList) { html += '<ul>'; inList = true; }
      const content = trimmed.replace(/^[-*\u2022]\s+/, '').replace(/^\d+[.)]\s+/, '');
      html += `<li>${inlineFmt(content)}</li>`;
      continue;
    }

    // Heading-like: short line ending with colon (not containing backticks — those are code patterns)
    if (trimmed.endsWith(':') && trimmed.length < 50 && !trimmed.includes('`') && !/\s{2,}/.test(trimmed)) {
      closeList();
      html += `<div class="mc-h3">${inlineFmt(trimmed.slice(0, -1))}</div>`;
      continue;
    }

    // Key: Value (label < 25 chars, then colon + space + value)
    const kvMatch = trimmed.match(/^([A-Za-z][\w\s/().,-]{0,24}?)\s{2,}(.+)$/);
    if (kvMatch) {
      closeList();
      html += `<div class="mc-kv"><span class="mc-kv-key">${esc(kvMatch[1])}</span> <span class="mc-kv-val">${inlineFmt(kvMatch[2])}</span></div>`;
      continue;
    }

    // Regular paragraph
    closeList();
    html += `<p>${inlineFmt(trimmed)}</p>`;
  }

  closeList();
  if (inCode) html += '</div>';
  return html;
}

function showTagDeleteModal(tagName, onConfirm) {
  const overlay = document.createElement('div');
  overlay.className = 'tag-delete-overlay';
  overlay.innerHTML = `
    <div class="tag-delete-modal">
      <div class="tag-delete-modal-title">Remove tag</div>
      <div class="tag-delete-modal-tag">${tagName}</div>
      <div class="tag-delete-modal-actions">
        <button class="action-btn action-btn--ghost tag-modal-cancel">Cancel</button>
        <button class="action-btn action-btn--danger tag-modal-confirm">Delete</button>
      </div>
    </div>
  `;
  document.body.appendChild(overlay);
  overlay.querySelector('.tag-modal-cancel').addEventListener('click', () => overlay.remove());
  overlay.querySelector('.tag-modal-confirm').addEventListener('click', () => { overlay.remove(); onConfirm(); });
  overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
}

// ── Markdown Content Editor ──
let _editingNode = null;

function enterEditMode(node) {
  _editingNode = node;
  const contentEl = document.getElementById('detail-content');
  const wrap = contentEl.parentElement; // .content-edit-wrap
  contentEl.style.display = 'none';
  document.getElementById('content-edit-btn').style.display = 'none';

  // Remove any previous editor
  const prev = wrap.querySelector('.md-editor-wrap');
  if (prev) prev.remove();

  const editor = document.createElement('div');
  editor.className = 'md-editor-wrap';

  // Toolbar
  const toolbar = document.createElement('div');
  toolbar.className = 'md-toolbar';

  const btnBold = document.createElement('button');
  btnBold.textContent = 'B';
  btnBold.title = 'Bold (**text**)';
  btnBold.style.fontWeight = '700';

  const btnList = document.createElement('button');
  btnList.textContent = '• List';
  btnList.title = 'Toggle list (- item)';

  const btnHeading = document.createElement('button');
  btnHeading.textContent = 'H';
  btnHeading.title = 'Cycle heading (## / ### / none)';

  toolbar.append(btnBold, btnList, btnHeading);

  // Textarea
  const textarea = document.createElement('textarea');
  textarea.className = 'md-textarea';
  textarea.value = node.payload.content || '';
  textarea.spellcheck = false;

  // Auto-resize textarea to fit content
  function autoResize() {
    textarea.style.height = 'auto';
    textarea.style.height = Math.max(180, textarea.scrollHeight) + 'px';
  }
  textarea.addEventListener('input', autoResize);

  // Actions
  const actions = document.createElement('div');
  actions.className = 'md-editor-actions';

  const btnCancel = document.createElement('button');
  btnCancel.className = 'md-btn-cancel';
  btnCancel.textContent = 'Cancel';

  const btnSave = document.createElement('button');
  btnSave.className = 'md-btn-save';
  btnSave.textContent = 'Save';

  actions.append(btnCancel, btnSave);
  editor.append(toolbar, textarea, actions);
  wrap.appendChild(editor);

  // Focus and auto-resize after insert
  requestAnimationFrame(() => { textarea.focus(); autoResize(); });

  // ── Toolbar actions ──

  // Bold: wrap/unwrap selection with **
  btnBold.addEventListener('click', () => {
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const val = textarea.value;
    const sel = val.substring(start, end);

    if (sel.startsWith('**') && sel.endsWith('**') && sel.length > 4) {
      // Unwrap
      textarea.value = val.substring(0, start) + sel.slice(2, -2) + val.substring(end);
      textarea.selectionStart = start;
      textarea.selectionEnd = end - 4;
    } else if (start >= 2 && val.substring(start - 2, start) === '**' && val.substring(end, end + 2) === '**') {
      // Unwrap (cursor inside bold markers)
      textarea.value = val.substring(0, start - 2) + sel + val.substring(end + 2);
      textarea.selectionStart = start - 2;
      textarea.selectionEnd = end - 2;
    } else {
      // Wrap
      textarea.value = val.substring(0, start) + '**' + sel + '**' + val.substring(end);
      textarea.selectionStart = start + 2;
      textarea.selectionEnd = end + 2;
    }
    textarea.focus();
  });

  // List: toggle "- " prefix on each selected line
  btnList.addEventListener('click', () => {
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const val = textarea.value;

    // Find line boundaries
    const lineStart = val.lastIndexOf('\n', start - 1) + 1;
    const lineEnd = val.indexOf('\n', end);
    const blockEnd = lineEnd === -1 ? val.length : lineEnd;
    const block = val.substring(lineStart, blockEnd);
    const lines = block.split('\n');

    const allList = lines.every(l => /^- /.test(l));
    const newLines = allList
      ? lines.map(l => l.replace(/^- /, ''))
      : lines.map(l => '- ' + l);

    const newBlock = newLines.join('\n');
    textarea.value = val.substring(0, lineStart) + newBlock + val.substring(blockEnd);

    const diff = newBlock.length - block.length;
    textarea.selectionStart = lineStart;
    textarea.selectionEnd = blockEnd + diff;
    textarea.focus();
  });

  // Heading: cycle none → ## → ### → none on selected lines
  btnHeading.addEventListener('click', () => {
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const val = textarea.value;

    const lineStart = val.lastIndexOf('\n', start - 1) + 1;
    const lineEnd = val.indexOf('\n', end);
    const blockEnd = lineEnd === -1 ? val.length : lineEnd;
    const block = val.substring(lineStart, blockEnd);
    const lines = block.split('\n');

    const newLines = lines.map(l => {
      if (l.startsWith('### ')) return l.slice(4); // ### → none
      if (l.startsWith('## ')) return '### ' + l.slice(3); // ## → ###
      return '## ' + l; // none → ##
    });

    const newBlock = newLines.join('\n');
    textarea.value = val.substring(0, lineStart) + newBlock + val.substring(blockEnd);

    const diff = newBlock.length - block.length;
    textarea.selectionStart = lineStart;
    textarea.selectionEnd = blockEnd + diff;
    textarea.focus();
  });

  // ── Save / Cancel ──
  btnCancel.addEventListener('click', () => exitEditMode(node, false));
  btnSave.addEventListener('click', () => exitEditMode(node, true));

  // Escape key cancels
  textarea.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') { e.preventDefault(); exitEditMode(node, false); }
  });
}

async function exitEditMode(node, save) {
  const contentEl = document.getElementById('detail-content');
  const wrap = contentEl.parentElement;
  const editor = wrap.querySelector('.md-editor-wrap');

  if (save && editor) {
    const textarea = editor.querySelector('.md-textarea');
    const newContent = textarea.value;

    try {
      const res = await fetch(`/api/memory/${node.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: newContent }),
      });
      if (!res.ok) throw new Error('Save failed');
      node.payload.content = newContent;
    } catch (err) {
      console.error('Content save failed:', err);
      // Still exit edit mode but don't update display
    }
  }

  if (editor) editor.remove();
  contentEl.style.display = '';
  document.getElementById('content-edit-btn').style.display = '';
  contentEl.innerHTML = formatMemoryContent(node.payload.content);
  _editingNode = null;
}

function showDetailPanel(node) {
  const p = node.payload;
  const color = catColor(p.category);

  // Category + subcategory with Change button
  const catEl = document.getElementById('detail-category');
  catEl.style.color = color;
  const catLabel = document.getElementById('detail-category-label');
  catLabel.textContent = p.category + (p.subcategory ? ' / ' + p.subcategory : '');

  document.getElementById('detail-change-cat-btn').onclick = () => {
    openCategoryChangeModal(node);
  };

  // Bookmark button state
  if (typeof updateDetailBookmarkBtn === 'function') updateDetailBookmarkBtn(node.id);

  // Focus button — toggle showing only linked memories
  const focusBtn = document.getElementById('detail-focus-btn');
  focusBtn.classList.toggle('active', focusedNodeId === node.id);
  focusBtn.onclick = () => {
    if (focusedNodeId === node.id) {
      focusedNodeId = null;
      focusBtn.classList.remove('active');
    } else {
      focusedNodeId = node.id;
      focusBtn.classList.add('active');
    }
    applyGraphData();
    updateStats();
  };

  // Importance as dots (filled/empty)
  const imp = p.importance || 5;
  const impEl = document.getElementById('detail-importance');
  impEl.innerHTML = '';
  for (let i = 1; i <= 10; i++) {
    const dot = document.createElement('span');
    dot.style.display = 'inline-block';
    dot.style.width = '6px';
    dot.style.height = '6px';
    dot.style.borderRadius = '50%';
    dot.style.marginRight = '4px';
    dot.style.background = i <= imp ? '#FFD700' : 'rgba(255,255,255,0.08)';
    dot.style.boxShadow = i <= imp ? '0 0 4px rgba(255,215,0,0.4)' : 'none';
    impEl.appendChild(dot);
  }

  // Formatted content
  // Exit any active edit mode first
  if (_editingNode) exitEditMode(_editingNode, false);
  const contentEl = document.getElementById('detail-content');
  contentEl.style.display = '';
  contentEl.innerHTML = formatMemoryContent(p.content);
  document.getElementById('content-edit-btn').style.display = '';

  // Wire up edit button
  document.getElementById('content-edit-btn').onclick = () => enterEditMode(node);

  // Tags (editable)
  const tagContainer = document.getElementById('detail-tag-chips');
  tagContainer.innerHTML = '';
  const currentTags = (p.tags && Array.isArray(p.tags)) ? [...p.tags] : [];

  function renderEditableTags() {
    tagContainer.innerHTML = '';
    currentTags.forEach(tag => {
      const chip = document.createElement('span');
      chip.className = 'tag-chip';

      const text = document.createElement('span');
      text.className = 'tag-text';
      text.textContent = tag;
      chip.appendChild(text);

      const rm = document.createElement('span');
      rm.className = 'tag-remove';
      rm.textContent = '\u00d7';
      rm.addEventListener('click', (e) => {
        e.stopPropagation();
        showTagDeleteModal(tag, async () => {
          const idx = currentTags.indexOf(tag);
          if (idx !== -1) currentTags.splice(idx, 1);
          try {
            await fetch(`/api/memory/${node.id}`, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ tags: currentTags }),
            });
            node.payload.tags = [...currentTags];
          } catch (e) { console.error('Tag remove failed:', e); }
          renderEditableTags();
        });
      });
      chip.appendChild(rm);

      tagContainer.appendChild(chip);
    });

    // Add tag input
    const input = document.createElement('input');
    input.className = 'tag-add-input';
    input.placeholder = '+ add tag';
    input.maxLength = 40;
    input.addEventListener('keydown', async (e) => {
      if (e.key === 'Enter' && input.value.trim()) {
        const newTag = input.value.trim().toLowerCase();
        if (currentTags.includes(newTag)) { input.value = ''; return; }
        currentTags.push(newTag);
        try {
          await fetch(`/api/memory/${node.id}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ tags: currentTags }),
          });
          node.payload.tags = [...currentTags];
        } catch (e) { console.error('Tag add failed:', e); }
        renderEditableTags();
      }
    });
    tagContainer.appendChild(input);
  }

  renderEditableTags();
  document.getElementById('detail-tags').style.display = '';

  // Metadata as clean rows
  const meta = document.getElementById('detail-meta-content');
  meta.innerHTML = '';
  const addMeta = (label, value) => {
    if (!value) return;
    const row = document.createElement('div');
    row.className = 'detail-meta-row';
    row.innerHTML = `<span style="color:rgba(255,255,255,0.3)">${label}</span><span>${value}</span>`;
    meta.appendChild(row);
  };
  addMeta('Project', p.project);
  addMeta('Source', p.source);
  addMeta('Created', p.created_at ? new Date(p.created_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) : null);
  addMeta('Updated', p.updated_at ? new Date(p.updated_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) : null);
  addMeta('Accessed', p.access_count ? `${p.access_count} times` : null);

  // ID row with copy button
  {
    const idRow = document.createElement('div');
    idRow.className = 'detail-meta-row';
    idRow.innerHTML = `<span style="color:rgba(255,255,255,0.3)">ID</span><span>${truncate(node.id, 20)}<button class="meta-copy-btn" title="Copy full ID">Copy</button></span>`;
    idRow.querySelector('.meta-copy-btn').addEventListener('click', () => {
      navigator.clipboard.writeText(node.id).then(() => {
        const btn = idRow.querySelector('.meta-copy-btn');
        btn.textContent = 'Copied!';
        btn.classList.add('copied');
        setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 1500);
      });
    });
    meta.appendChild(idRow);
  }

  // Related files
  const filesDiv = document.getElementById('detail-files');
  const filesContent = document.getElementById('detail-files-content');
  if (p.related_files && p.related_files.length) {
    filesContent.innerHTML = p.related_files.map(f =>
      `<div style="font-family:'SF Mono',Consolas,monospace;font-size:12px;color:rgba(255,255,255,0.45);padding:2px 0">${f}</div>`
    ).join('');
    filesDiv.style.display = '';
  } else {
    filesDiv.style.display = 'none';
  }

  // Delete button
  const deleteZone = document.getElementById('detail-delete-zone');
  function showDeleteBtn() {
    deleteZone.innerHTML = `<button id="detail-delete-btn">Delete Memory</button>`;
    document.getElementById('detail-delete-btn').addEventListener('click', () => {
      deleteZone.innerHTML = `
        <div class="detail-delete-confirm">
          <span>Permanently delete this memory?</span>
          <button class="delete-confirm-no">Cancel</button>
          <button class="delete-confirm-yes">Delete</button>
        </div>
      `;
      deleteZone.querySelector('.delete-confirm-no').addEventListener('click', showDeleteBtn);
      deleteZone.querySelector('.delete-confirm-yes').addEventListener('click', () => {
        deleteMemoryFromUI(node);
      });
    });
  }
  showDeleteBtn();

  // Restore saved position if it was dragged before
  const savedDetail = localStorage.getItem('neural-panel-detail-panel');
  if (savedDetail) {
    try {
      const d = JSON.parse(savedDetail);
      if (d.left && d.left !== 'auto') {
        $detailPanel.style.left = d.left;
        $detailPanel.style.top = d.top || '20px';
        $detailPanel.style.right = 'auto';
      }
    } catch {}
  }
  $detailPanel.classList.add('open');
}

// ═══════════════════════════════════════════
// SEARCH
// ═══════════════════════════════════════════
let searchTimeout = null;

$searchInput.addEventListener('focus', () => $searchWrapper.classList.add('focused'));
$searchInput.addEventListener('blur', () => $searchWrapper.classList.remove('focused'));

$searchInput.addEventListener('input', () => {
  clearTimeout(searchTimeout);
  const query = $searchInput.value.trim();

  if (!query) {
    clearSearch();
    return;
  }

  $searchClear.style.display = 'block';
  $searchBadge.classList.remove('visible');
  $statSearch.textContent = 'Searching...';

  searchTimeout = setTimeout(() => performSearch(query), 400);
});

$searchClear.addEventListener('click', () => {
  $searchInput.value = '';
  clearSearch();
  $searchInput.focus();
});

async function performSearch(query) {
  try {
    const res = await fetch('/api/search', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query, limit: 15 }),
    });
    const data = await res.json();

    if (data.results && data.results.length > 0) {
      searchResults = new Set(data.results.map(r => r.id));
      $searchBadge.textContent = data.results.length;
      $searchBadge.classList.add('visible');
      $searchClear.style.display = 'none'; // badge takes its place
      $statSearch.textContent = `${data.results.length} results`;

      // Camera to centroid of results
      const resultNodes = allNodes.filter(n => searchResults.has(n.id));
      if (resultNodes.length > 0 && graph) {
        // Get positions from graph internals
        const graphNodes = graph.graphData().nodes;
        const matchingGraphNodes = graphNodes.filter(n => searchResults.has(n.id));
        if (matchingGraphNodes.length > 0) {
          const cx = matchingGraphNodes.reduce((s, n) => s + (n.x || 0), 0) / matchingGraphNodes.length;
          const cy = matchingGraphNodes.reduce((s, n) => s + (n.y || 0), 0) / matchingGraphNodes.length;
          const cz = matchingGraphNodes.reduce((s, n) => s + (n.z || 0), 0) / matchingGraphNodes.length;
          graph.cameraPosition(
            { x: cx + 180, y: cy + 80, z: cz + 180 },
            { x: cx, y: cy, z: cz },
            1500
          );
        }
      }
    } else {
      searchResults = new Set(); // empty set = no matches
      $searchBadge.textContent = '0';
      $searchBadge.classList.add('visible');
      $searchClear.style.display = 'none';
      $statSearch.textContent = 'No results';
    }

    updateStats();
  } catch (err) {
    console.error('Search error:', err);
    $statSearch.textContent = 'Search error';
  }
}

function clearSearch() {
  searchResults = null;
  $searchBadge.classList.remove('visible');
  $searchClear.style.display = 'none';
  $statSearch.textContent = '';
  updateStats();
}

// ═══════════════════════════════════════════
// CATEGORY SIDEBAR
// ═══════════════════════════════════════════
function getCategoryOrder() {
  try { return JSON.parse(localStorage.getItem('neural-category-order') || '[]'); }
  catch { return []; }
}

function saveCategoryOrder(order) {
  localStorage.setItem('neural-category-order', JSON.stringify(order));
}

function buildCategorySidebar(presentCats) {
  $categoryList.innerHTML = '';

  // Count per category
  const counts = {};
  allNodes.forEach(n => {
    const cat = n.payload.category;
    counts[cat] = (counts[cat] || 0) + 1;
  });

  // Merge present categories with all known categories (including 0-count ones)
  const allCats = new Set(presentCats);
  allCategoryNames.forEach(c => allCats.add(c));

  // Group categories by parent
  const categoryGroups = {};
  const orphans = [];

  [...allCats].forEach(cat => {
    const meta = categoryMetadata[cat] || {};
    if (meta.parent) {
      if (!categoryGroups[meta.parent]) categoryGroups[meta.parent] = [];
      categoryGroups[meta.parent].push(cat);
    } else {
      orphans.push(cat);
    }
    // Ensure is_parent categories always have an entry in categoryGroups (even if empty)
    if (meta.is_parent && !categoryGroups[cat]) {
      categoryGroups[cat] = [];
    }
  });

  // Apply saved order, then append any new categories at the end sorted by count
  const savedOrder = getCategoryOrder();
  const ordered = savedOrder.filter(c => allCats.has(c));
  const remaining = [...allCats].filter(c => !savedOrder.includes(c))
    .sort((a, b) => (counts[b] || 0) - (counts[a] || 0));
  const sorted = [...ordered, ...remaining];

  // Track which parent clusters we've rendered
  const renderedClusters = new Set();

  sorted.forEach(cat => {
    const meta = categoryMetadata[cat] || {};

    // If this category has a parent and we haven't rendered that cluster header yet
    if (meta.parent && !renderedClusters.has(meta.parent)) {
      const clusterHeader = document.createElement('div');
      clusterHeader.className = 'category-cluster-header';
      clusterHeader.style.borderLeft = `3px solid ${catColor(meta.parent)}`;
      clusterHeader.dataset.parent = meta.parent;

      // Check if parent is inactive
      if (!activeCategories.has(meta.parent)) {
        clusterHeader.classList.add('inactive');
      }

      clusterHeader.innerHTML = `
        <span class="cluster-dot" style="background:${catColor(meta.parent)}" title="Change color"></span>
        <span class="cluster-name">${meta.parent}</span>
        <span class="cluster-actions">
          <button class="cluster-edit-btn" title="Edit ${meta.parent}">&#9998;</button>
          <button class="cluster-delete-btn" title="Delete ${meta.parent}">&times;</button>
        </span>
      `;

      // Click on cluster header to toggle parent and all children
      clusterHeader.addEventListener('click', (e) => {
        // Don't toggle if clicking on action buttons or color dot
        if (e.target.closest('.cluster-actions') || e.target.closest('.cluster-dot')) return;

        const parentCat = meta.parent;
        const childCategories = categoryGroups[parentCat] || [];

        if (activeCategories.has(parentCat)) {
          // Disable parent and all children
          activeCategories.delete(parentCat);
          childCategories.forEach(child => activeCategories.delete(child));
          clusterHeader.classList.add('inactive');
          // Mark all children as inactive
          childCategories.forEach(child => {
            const childChip = $categoryList.querySelector(`.category-chip[data-cat="${child}"]`);
            if (childChip) childChip.classList.add('inactive');
          });
        } else {
          // Enable parent and all children
          activeCategories.add(parentCat);
          childCategories.forEach(child => activeCategories.add(child));
          clusterHeader.classList.remove('inactive');
          // Mark all children as active
          childCategories.forEach(child => {
            const childChip = $categoryList.querySelector(`.category-chip[data-cat="${child}"]`);
            if (childChip) childChip.classList.remove('inactive');
          });
        }

        applyGraphData();
        updateStats();
      });

      // Color dot click
      clusterHeader.querySelector('.cluster-dot').addEventListener('click', (e) => {
        e.stopPropagation();
        openColorPicker(meta.parent, clusterHeader);
      });

      // Edit button
      clusterHeader.querySelector('.cluster-edit-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        editCategoryUI(meta.parent);
      });

      // Delete button
      clusterHeader.querySelector('.cluster-delete-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        const parentCount = counts[meta.parent] || 0;
        deleteCategoryUI(meta.parent, parentCount, clusterHeader);
      });

      $categoryList.appendChild(clusterHeader);
      renderedClusters.add(meta.parent);
    }

    // If this category is a parent (is_parent flag or has children), render its own cluster header
    if ((meta.is_parent || (categoryGroups[cat] && categoryGroups[cat].length > 0)) && !renderedClusters.has(cat)) {
      const clusterHeader = document.createElement('div');
      clusterHeader.className = 'category-cluster-header';
      clusterHeader.style.borderLeft = `3px solid ${catColor(cat)}`;
      clusterHeader.dataset.parent = cat;

      if (!activeCategories.has(cat)) {
        clusterHeader.classList.add('inactive');
      }

      const childCount = (categoryGroups[cat] || []).length;
      clusterHeader.innerHTML = `
        <span class="cluster-dot" style="background:${catColor(cat)}" title="Change color"></span>
        <span class="cluster-name">${cat}</span>
        <span class="cluster-actions">
          <button class="cluster-edit-btn" title="Edit ${cat}">&#9998;</button>
          <button class="cluster-delete-btn" title="Delete ${cat}">&times;</button>
        </span>
      `;

      clusterHeader.addEventListener('click', (e) => {
        if (e.target.closest('.cluster-actions') || e.target.closest('.cluster-dot')) return;
        const childCategories = categoryGroups[cat] || [];
        if (activeCategories.has(cat)) {
          activeCategories.delete(cat);
          childCategories.forEach(child => activeCategories.delete(child));
          clusterHeader.classList.add('inactive');
          childCategories.forEach(child => {
            const childChip = $categoryList.querySelector(`.category-chip[data-cat="${child}"]`);
            if (childChip) childChip.classList.add('inactive');
          });
        } else {
          activeCategories.add(cat);
          childCategories.forEach(child => activeCategories.add(child));
          clusterHeader.classList.remove('inactive');
          childCategories.forEach(child => {
            const childChip = $categoryList.querySelector(`.category-chip[data-cat="${child}"]`);
            if (childChip) childChip.classList.remove('inactive');
          });
        }
        applyGraphData();
        updateStats();
      });

      clusterHeader.querySelector('.cluster-dot').addEventListener('click', (e) => {
        e.stopPropagation();
        openColorPicker(cat, clusterHeader);
      });
      clusterHeader.querySelector('.cluster-edit-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        editCategoryUI(cat);
      });
      clusterHeader.querySelector('.cluster-delete-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        deleteCategoryUI(cat, counts[cat] || 0, clusterHeader);
      });

      $categoryList.appendChild(clusterHeader);
      renderedClusters.add(cat);

      // Show empty state hint if parent has no children yet
      if (childCount === 0) {
        const emptyHint = document.createElement('div');
        emptyHint.className = 'cluster-empty-hint';
        emptyHint.textContent = 'Drag categories here';
        $categoryList.appendChild(emptyHint);
      }
    }

    // Skip rendering chips for parent categories (they only appear as cluster headers)
    if (categoryGroups[cat] !== undefined) {
      return;
    }

    const chip = document.createElement('div');
    chip.className = 'category-chip' + (meta.parent ? ' category-chip-child' : '');
    chip.dataset.cat = cat;

    // Check if category should be inactive
    if (!activeCategories.has(cat)) {
      chip.classList.add('inactive');
    }

    chip.innerHTML = `
      <div class="category-dot" style="color:${catColor(cat)}; background:${catColor(cat)}" title="Change color"></div>
      <span class="category-label">${cat}<span class="cat-edit-icon" title="Edit description">&#9998;</span></span>
      <span class="category-count">${counts[cat] || 0}</span>
      <button class="category-delete" title="Delete category">&times;</button>
    `;

    // Color dot click → open color picker
    chip.querySelector('.category-dot').addEventListener('click', (e) => {
      e.stopPropagation();
      openColorPicker(cat, chip);
    });

    // Edit icon click → open full category editor
    chip.querySelector('.cat-edit-icon').addEventListener('click', (e) => {
      e.stopPropagation();
      editCategoryUI(cat);
    });

    chip.addEventListener('click', (e) => {
      if (categoryDragDidMove) { categoryDragDidMove = false; return; }
      if (e.target.closest('.category-delete')) return;
      if (e.target.closest('.category-dot')) return;
      if (e.target.closest('.cat-edit-icon')) return;
      if (activeCategories.has(cat)) {
        activeCategories.delete(cat);
        chip.classList.add('inactive');
      } else {
        activeCategories.add(cat);
        chip.classList.remove('inactive');
      }
      applyGraphData();
      updateStats();
    });

    chip.querySelector('.category-delete').addEventListener('click', (e) => {
      e.stopPropagation();
      deleteCategoryUI(cat, counts[cat] || 0, chip);
    });

    $categoryList.appendChild(chip);
  });

  // Wire up drag-to-reorder
  initCategoryDrag();
}

let categoryDragDidMove = false;

function initCategoryDrag() {
  let dragChip = null;
  let startY = 0;
  categoryDragDidMove = false;

  const chips = () => [...$categoryList.querySelectorAll('.category-chip')];
  const clusterHeaders = () => [...$categoryList.querySelectorAll('.category-cluster-header')];

  function clearIndicators() {
    chips().forEach(c => {
      c.classList.remove('drag-over-above', 'drag-over-below');
    });
    clusterHeaders().forEach(h => {
      h.classList.remove('drag-over-cluster');
    });
  }

  function getDropTarget(y) {
    // Check if hovering over a cluster header (for reparenting)
    for (const header of clusterHeaders()) {
      const rect = header.getBoundingClientRect();
      if (y >= rect.top && y <= rect.bottom) {
        const clusterName = header.querySelector('.cluster-name').textContent;
        return { type: 'cluster', header, clusterName };
      }
    }

    // Check if hovering over an empty cluster hint (treat as drop on parent)
    for (const hint of [...$categoryList.querySelectorAll('.cluster-empty-hint')]) {
      const rect = hint.getBoundingClientRect();
      if (y >= rect.top && y <= rect.bottom) {
        const header = hint.previousElementSibling;
        if (header && header.classList.contains('category-cluster-header')) {
          const clusterName = header.querySelector('.cluster-name').textContent;
          return { type: 'cluster', header, clusterName };
        }
      }
    }

    // Check if dropping in the top empty area (make top-level)
    const firstChip = chips()[0];
    if (firstChip) {
      const firstRect = firstChip.getBoundingClientRect();
      const listRect = $categoryList.getBoundingClientRect();
      if (y < firstRect.top && y >= listRect.top) {
        return { type: 'make-toplevel' };
      }
    }

    // Otherwise, find position for reordering
    for (const chip of chips()) {
      if (chip === dragChip) continue;
      const rect = chip.getBoundingClientRect();
      const mid = rect.top + rect.height / 2;
      if (y < mid) return { type: 'reorder', chip, position: 'before' };
    }
    const last = chips().filter(c => c !== dragChip).pop();
    return last ? { type: 'reorder', chip: last, position: 'after' } : null;
  }

  $categoryList.addEventListener('pointerdown', (e) => {
    // Skip if clicking interactive sub-elements
    if (e.target.closest('.category-delete')) return;
    if (e.target.closest('.category-dot')) return;
    if (e.target.closest('.cat-edit-icon')) return;

    const chip = e.target.closest('.category-chip');
    if (!chip) return;

    e.preventDefault();
    dragChip = chip;
    startY = e.clientY;
    categoryDragDidMove = false;
    chip.setPointerCapture(e.pointerId);

    function onMove(ev) {
      if (!dragChip) return;
      if (!categoryDragDidMove && Math.abs(ev.clientY - startY) < 5) return;
      if (!categoryDragDidMove) {
        categoryDragDidMove = true;
        dragChip.classList.add('drag-source');
      }
      clearIndicators();
      const target = getDropTarget(ev.clientY);
      if (target) {
        if (target.type === 'cluster') {
          target.header.classList.add('drag-over-cluster');
        } else if (target.type === 'reorder') {
          target.chip.classList.add(
            target.position === 'before' ? 'drag-over-above' : 'drag-over-below'
          );
        }
      }
    }

    async function onUp(ev) {
      chip.removeEventListener('pointermove', onMove);
      chip.removeEventListener('pointerup', onUp);
      chip.removeEventListener('pointercancel', onUp);

      if (!dragChip) return;
      const draggedCat = dragChip.dataset.cat;
      dragChip.classList.remove('drag-source');
      clearIndicators();

      if (categoryDragDidMove) {
        const target = getDropTarget(ev.clientY);

        if (target && target.type === 'cluster') {
          // Reparent: dropped onto a cluster header
          const newParent = target.clusterName;
          const currentMeta = categoryMetadata[draggedCat] || {};

          // Don't reparent if already this parent
          if (currentMeta.parent !== newParent) {
            try {
              const res = await fetch('/api/categories/' + encodeURIComponent(draggedCat), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ parent: newParent }),
              });

              const data = await res.json();
              if (res.ok) {
                // Update local metadata
                allCategoryNames = data.categories.map(c => c.name);
                categoryDescriptions = {};
                categoryMetadata = {};
                data.categories.forEach(c => {
                  categoryDescriptions[c.name] = c.description;
                  categoryMetadata[c.name] = { parent: c.parent, color: c.color, is_parent: c.is_parent };
                });

                // Rebuild sidebar
                const presentCats = new Set(allNodes.map(n => n.payload.category));
                buildCategorySidebar(presentCats);
                applyGraphData();
              } else {
                alert('Error reparenting category: ' + data.error);
              }
            } catch (err) {
              console.error('Error reparenting category:', err);
              alert('Error reparenting category: ' + err.message);
            }
          }
        } else if (target && target.type === 'make-toplevel') {
          // Make top-level: dropped in empty area at top
          const currentMeta = categoryMetadata[draggedCat] || {};

          if (currentMeta.parent) {
            try {
              const res = await fetch('/api/categories/' + encodeURIComponent(draggedCat), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ parent: '' }),
              });

              const data = await res.json();
              if (res.ok) {
                // Update local metadata
                allCategoryNames = data.categories.map(c => c.name);
                categoryDescriptions = {};
                categoryMetadata = {};
                data.categories.forEach(c => {
                  categoryDescriptions[c.name] = c.description;
                  categoryMetadata[c.name] = { parent: c.parent, color: c.color, is_parent: c.is_parent };
                });

                // Rebuild sidebar
                const presentCats = new Set(allNodes.map(n => n.payload.category));
                buildCategorySidebar(presentCats);
                applyGraphData();
              } else {
                alert('Error making category top-level: ' + data.error);
              }
            } catch (err) {
              console.error('Error making category top-level:', err);
              alert('Error making category top-level: ' + err.message);
            }
          }
        } else if (target && target.type === 'reorder' && target.chip !== dragChip) {
          // Reorder: dropped between chips
          if (target.position === 'before') {
            $categoryList.insertBefore(dragChip, target.chip);
          } else {
            target.chip.after(dragChip);
          }
          const newOrder = chips().map(c => c.dataset.cat);
          saveCategoryOrder(newOrder);
        }
      }

      dragChip = null;
    }

    chip.addEventListener('pointermove', onMove);
    chip.addEventListener('pointerup', onUp);
    chip.addEventListener('pointercancel', onUp);
  });
}

// ═══════════════════════════════════════════
// GRAPH DATA MANAGEMENT
// ═══════════════════════════════════════════
function applyGraphData() {
  if (!graph) return;

  let visibleNodes = allNodes.filter(n => activeCategories.has(n.payload.category));
  let visibleIds = new Set(visibleNodes.map(n => n.id));
  let visibleLinks = allLinks.filter(l => {
    const srcId = l.source.id || l.source;
    const tgtId = l.target.id || l.target;
    return visibleIds.has(srcId) && visibleIds.has(tgtId);
  });

  // Focus mode: only show selected node + direct neighbors
  if (focusedNodeId && visibleIds.has(focusedNodeId)) {
    const neighborIds = new Set([focusedNodeId]);
    visibleLinks.forEach(l => {
      const srcId = l.source.id || l.source;
      const tgtId = l.target.id || l.target;
      if (srcId === focusedNodeId) neighborIds.add(tgtId);
      if (tgtId === focusedNodeId) neighborIds.add(srcId);
    });
    visibleNodes = visibleNodes.filter(n => neighborIds.has(n.id));
    visibleIds = neighborIds;
    visibleLinks = visibleLinks.filter(l => {
      const srcId = l.source.id || l.source;
      const tgtId = l.target.id || l.target;
      return neighborIds.has(srcId) && neighborIds.has(tgtId);
    });
  }

  graph.graphData({ nodes: visibleNodes, links: visibleLinks });
}

function updateStats() {
  // Re-derive from what the graph is actually showing
  const gd = graph ? graph.graphData() : { nodes: [], links: [] };
  $statVisible.textContent = gd.nodes.length;
  $statLinks.textContent = gd.links.length;
}

// ═══════════════════════════════════════════
// CATEGORY MANAGEMENT
// ═══════════════════════════════════════════
// Store category metadata including parent and color
let categoryMetadata = {};

async function fetchCategories() {
  try {
    const res = await fetch('/api/categories');
    if (!res.ok) return;
    const data = await res.json();
    allCategoryNames = data.categories.map(c => c.name);
    categoryDescriptions = {};
    categoryMetadata = {};
    data.categories.forEach(c => {
      categoryDescriptions[c.name] = c.description;
      categoryMetadata[c.name] = {
        parent: c.parent,
        color: c.color,
        description: c.description,
        is_parent: c.is_parent
      };
    });
  } catch (e) {
    console.error('fetchCategories error:', e);
  }
}

function closeColorPicker() {
  const existing = document.querySelector('.color-edit-picker');
  if (existing) existing.remove();
}

function openColorPicker(cat, chipEl) {
  // Close any existing picker
  closeColorPicker();

  const picker = document.createElement('div');
  picker.className = 'color-edit-picker';

  const row = document.createElement('div');
  row.className = 'color-swatch-row';

  const currentColor = catColor(cat);

  COLOR_PALETTE.forEach(color => {
    const swatch = document.createElement('button');
    swatch.className = 'color-swatch' + (color === currentColor ? ' selected' : '');
    swatch.style.background = color;
    swatch.addEventListener('click', (e) => {
      e.stopPropagation();
      applyCategoryColor(cat, color);
      closeColorPicker();
    });
    row.appendChild(swatch);
  });

  picker.appendChild(row);

  // Reset to default button
  const overrides = JSON.parse(localStorage.getItem('neural-category-colors') || '{}');
  if (overrides[cat]) {
    const resetBtn = document.createElement('button');
    resetBtn.className = 'color-edit-reset';
    resetBtn.textContent = 'Reset to default';
    resetBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      applyCategoryColor(cat, null);
      closeColorPicker();
    });
    picker.appendChild(resetBtn);
  }

  // Insert after the chip
  chipEl.after(picker);

  // Close on outside click (deferred so current click doesn't trigger it)
  setTimeout(() => {
    function onOutsideClick(e) {
      if (!picker.contains(e.target)) {
        closeColorPicker();
        document.removeEventListener('click', onOutsideClick);
      }
    }
    document.addEventListener('click', onOutsideClick);
  }, 0);
}

function applyCategoryColor(cat, color) {
  const overrides = JSON.parse(localStorage.getItem('neural-category-colors') || '{}');
  if (color === null) {
    delete overrides[cat];
  } else {
    overrides[cat] = color;
  }
  localStorage.setItem('neural-category-colors', JSON.stringify(overrides));

  // Rebuild sidebar to reflect new color on the dot
  const presentCats = new Set(allNodes.map(n => n.payload.category));
  buildCategorySidebar(presentCats);

  // Force graph to recreate node objects with new colors
  if (graph) {
    graph.nodeThreeObject(createNodeObject);
  }
}

function closeDescEditor() {
  const existing = document.querySelector('.category-desc-editor');
  if (existing) existing.remove();
}

function openDescEditor(cat, chipEl) {
  closeDescEditor();
  closeColorPicker();

  const editor = document.createElement('div');
  editor.className = 'category-desc-editor';
  const currentDesc = categoryDescriptions[cat] || '';
  editor.innerHTML = `
    <label>Description for "${cat}"</label>
    <textarea class="desc-textarea">${currentDesc}</textarea>
    <div class="category-desc-actions">
      <button class="desc-cancel-btn">Cancel</button>
      <button class="desc-save-btn">Save</button>
    </div>
  `;

  const textarea = editor.querySelector('.desc-textarea');
  const saveBtn = editor.querySelector('.desc-save-btn');
  const cancelBtn = editor.querySelector('.desc-cancel-btn');

  cancelBtn.addEventListener('click', () => closeDescEditor());
  saveBtn.addEventListener('click', () => saveDescription(cat, textarea.value.trim()));

  textarea.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      saveDescription(cat, textarea.value.trim());
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      closeDescEditor();
    }
    e.stopPropagation();
  });
  textarea.addEventListener('keyup', (e) => e.stopPropagation());

  chipEl.after(editor);
  textarea.focus();
  textarea.setSelectionRange(textarea.value.length, textarea.value.length);
}

async function saveDescription(cat, description) {
  if (!description) return;
  const saveBtn = document.querySelector('.category-desc-editor .desc-save-btn');
  if (saveBtn) { saveBtn.textContent = 'Saving...'; saveBtn.disabled = true; }

  try {
    const res = await fetch('/api/categories/' + encodeURIComponent(cat), {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ description }),
    });
    const data = await res.json();
    if (!res.ok) {
      console.error('saveDescription error:', data.error);
      if (saveBtn) { saveBtn.textContent = 'Error'; saveBtn.disabled = false; }
      return;
    }
    allCategoryNames = data.categories.map(c => c.name);
    categoryDescriptions = {};
    data.categories.forEach(c => categoryDescriptions[c.name] = c.description);
    closeDescEditor();
  } catch (e) {
    console.error('saveDescription fetch error:', e);
    if (saveBtn) { saveBtn.textContent = 'Error'; saveBtn.disabled = false; }
  }
}

function openCategoryChangeModal(node) {
  const current = node.payload.category;

  const overlay = document.createElement('div');
  overlay.className = 'tag-delete-overlay';

  let listHtml = '';
  allCategoryNames.forEach(cat => {
    const desc = categoryDescriptions[cat] || '';
    const isActive = cat === current;
    listHtml += `
      <div class="cat-modal-option${isActive ? ' active' : ''}" data-cat="${cat}">
        <div class="cat-opt-dot" style="color:${catColor(cat)}; background:${catColor(cat)}"></div>
        <span class="cat-opt-name">${cat}</span>
        ${desc ? `<span class="cat-opt-desc">${desc}</span>` : ''}
      </div>`;
  });

  overlay.innerHTML = `
    <div class="tag-delete-modal cat-change-modal">
      <div class="cat-change-modal-title">Change category</div>
      <div class="cat-change-modal-current">
        <div class="cat-dot" style="color:${catColor(current)}; background:${catColor(current)}"></div>
        ${current}
      </div>
      <div class="cat-change-modal-list">${listHtml}</div>
    </div>
  `;

  document.body.appendChild(overlay);

  // Click a category to change
  overlay.querySelectorAll('.cat-modal-option').forEach(opt => {
    opt.addEventListener('click', () => {
      const cat = opt.dataset.cat;
      overlay.remove();
      if (cat !== current) {
        changeMemoryCategory(node, cat);
      }
    });
  });

  // Close on overlay backdrop click
  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) overlay.remove();
  });
}

async function changeMemoryCategory(node, newCategory) {
  const oldCategory = node.payload.category;

  // Optimistic update
  node.payload.category = newCategory;

  // Update detail panel label + color
  const color = catColor(newCategory);
  const catEl = document.getElementById('detail-category');
  catEl.style.color = color;
  const label = document.getElementById('detail-category-label');
  if (label) label.textContent = newCategory + (node.payload.subcategory ? ' / ' + node.payload.subcategory : '');

  // Rebuild sidebar + graph
  const presentCats = new Set(allNodes.map(n => n.payload.category));
  buildCategorySidebar(presentCats);
  if (graph) graph.nodeThreeObject(createNodeObject);

  // Persist to server
  try {
    const res = await fetch('/api/memory/' + encodeURIComponent(node.id), {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ category: newCategory }),
    });
    if (!res.ok) {
      const err = await res.json();
      console.error('changeMemoryCategory error:', err.error);
      // Rollback
      node.payload.category = oldCategory;
      const rColor = catColor(oldCategory);
      catEl.style.color = rColor;
      if (label) label.textContent = oldCategory + (node.payload.subcategory ? ' / ' + node.payload.subcategory : '');
      const rCats = new Set(allNodes.map(n => n.payload.category));
      buildCategorySidebar(rCats);
      if (graph) graph.nodeThreeObject(createNodeObject);
    }
  } catch (e) {
    console.error('changeMemoryCategory fetch error:', e);
    node.payload.category = oldCategory;
  }
}

async function createCategory(name, description, color, parent, isParent) {
  const payload = { name, description };
  if (parent) payload.parent = parent;
  if (color) payload.color = color;
  if (isParent) payload.is_parent = true;

  const res = await fetch('/api/categories', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });
  const data = await res.json();
  if (!res.ok) throw new Error(data.error);
  allCategoryNames = data.categories.map(c => c.name);
  categoryDescriptions = {};
  categoryMetadata = {};
  data.categories.forEach(c => {
    categoryDescriptions[c.name] = c.description;
    categoryMetadata[c.name] = {
      parent: c.parent,
      color: c.color,
      description: c.description,
      is_parent: c.is_parent
    };
  });
  // Save chosen color
  if (color) {
    const overrides = JSON.parse(localStorage.getItem('neural-category-colors') || '{}');
    overrides[name] = color;
    localStorage.setItem('neural-category-colors', JSON.stringify(overrides));
  }
  // Add to active set & rebuild
  activeCategories.add(name);
  const presentCats = new Set(allNodes.map(n => n.payload.category));
  buildCategorySidebar(presentCats);
}

async function editCategoryUI(name) {
  const overlay = document.createElement('div');
  overlay.className = 'tag-delete-overlay';

  const meta = categoryMetadata[name] || {};
  const currentDesc = categoryDescriptions[name] || '';
  const currentParent = meta.parent || '';
  const currentColor = meta.color || catColor(name);

  // Get available parent categories (excluding this one and its descendants)
  const getDescendants = (catName) => {
    const directChildren = allCategoryNames.filter(c => {
      const m = categoryMetadata[c] || {};
      return m.parent === catName;
    });
    const allDescendants = [...directChildren];
    directChildren.forEach(child => {
      allDescendants.push(...getDescendants(child));
    });
    return allDescendants;
  };

  const descendants = getDescendants(name);
  const descendantSet = new Set(descendants);
  const availableParents = allCategoryNames.filter(c => c !== name && !descendantSet.has(c));

  overlay.innerHTML = `
    <div class="tag-delete-modal" style="min-width:400px">
      <div class="tag-delete-modal-title">Edit Category</div>
      <div class="tag-delete-modal-tag">${name}</div>

      <div style="margin-top:16px">
        <label style="display:block;font-size:var(--fs-sm);margin-bottom:4px;color:var(--t-primary)">Name</label>
        <input type="text" class="edit-cat-name modal-select" value="${name}">
      </div>

      <div style="margin-top:12px">
        <label style="display:block;font-size:var(--fs-sm);margin-bottom:4px;color:var(--t-primary)">Description</label>
        <textarea class="edit-cat-desc modal-select" rows="3" style="resize:vertical;font-family:inherit">${currentDesc}</textarea>
      </div>

      <div style="margin-top:12px">
        <label style="display:block;font-size:var(--fs-sm);margin-bottom:4px;color:var(--t-primary)">Parent Category</label>
        <select class="edit-cat-parent modal-select">
          <option value="">-- No parent (top-level) --</option>
          ${availableParents.map(c => `<option value="${c}" ${c === currentParent ? 'selected' : ''}>${c}</option>`).join('')}
        </select>
      </div>

      <div style="margin-top:12px;display:flex;align-items:center;gap:8px" class="edit-cat-isparent-row" ${currentParent ? 'hidden' : ''}>
        <input type="checkbox" class="edit-cat-isparent" id="edit-cat-isparent-cb" ${meta.is_parent ? 'checked' : ''}>
        <label for="edit-cat-isparent-cb" style="font-size:var(--fs-sm);color:var(--t-primary);cursor:pointer">Make this a parent category (cluster container)</label>
      </div>

      <div style="margin-top:12px">
        <label style="display:block;font-size:var(--fs-sm);margin-bottom:4px;color:var(--t-primary)">Color</label>
        <input type="color" class="edit-cat-color modal-select" value="${currentColor}"
          style="height:40px;cursor:pointer;padding:4px">
      </div>

      <div class="tag-delete-modal-actions">
        <button class="action-btn action-btn--ghost cat-modal-cancel">Cancel</button>
        <button class="action-btn action-btn--primary cat-modal-confirm">Save Changes</button>
      </div>
    </div>
  `;

  document.body.appendChild(overlay);

  const $nameInput = overlay.querySelector('.edit-cat-name');
  const $descInput = overlay.querySelector('.edit-cat-desc');
  const $parentSelect = overlay.querySelector('.edit-cat-parent');
  const $colorInput = overlay.querySelector('.edit-cat-color');
  const $isParentCheck = overlay.querySelector('.edit-cat-isparent');
  const $isParentRow = overlay.querySelector('.edit-cat-isparent-row');

  // Show/hide is_parent checkbox based on parent selection
  $parentSelect.addEventListener('change', () => {
    if ($parentSelect.value) {
      $isParentRow.hidden = true;
      $isParentCheck.checked = false;
    } else {
      $isParentRow.hidden = false;
    }
  });

  overlay.querySelector('.cat-modal-cancel').addEventListener('click', () => overlay.remove());
  overlay.querySelector('.cat-modal-confirm').addEventListener('click', async () => {
    const newName = $nameInput.value.trim();
    const newDesc = $descInput.value.trim();
    const newParent = $parentSelect.value;
    const newColor = $colorInput.value;
    const newIsParent = $isParentCheck.checked;

    if (!newName || !newDesc) {
      alert('Name and description are required');
      return;
    }

    const btn = overlay.querySelector('.cat-modal-confirm');
    btn.textContent = 'Saving...';
    btn.disabled = true;

    const updates = {};
    if (newName !== name) updates.new_name = newName;
    if (newDesc !== currentDesc) updates.description = newDesc;
    if (newParent !== currentParent) updates.parent = newParent;
    if (newColor !== currentColor) updates.color = newColor;
    if (newIsParent !== !!meta.is_parent) updates.is_parent = newIsParent;

    const res = await fetch('/api/categories/' + encodeURIComponent(name), {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(updates),
    });

    const data = await res.json();
    if (!res.ok) {
      alert('Error updating category: ' + data.error);
      btn.textContent = 'Save Changes';
      btn.disabled = false;
      return;
    }

    // Update local state
    allCategoryNames = data.categories.map(c => c.name);
    categoryDescriptions = {};
    categoryMetadata = {};
    data.categories.forEach(c => {
      categoryDescriptions[c.name] = c.description;
      categoryMetadata[c.name] = { parent: c.parent, color: c.color, is_parent: c.is_parent };
    });

    // Update localStorage colors
    try {
      const overrides = JSON.parse(localStorage.getItem('neural-category-colors') || '{}');
      if (newColor !== currentColor) {
        overrides[newName || name] = newColor;
      }
      if (newName !== name && overrides[name]) {
        overrides[newName] = overrides[name];
        delete overrides[name];
      }
      localStorage.setItem('neural-category-colors', JSON.stringify(overrides));
    } catch {}

    // If renamed, update activeCategories
    if (newName !== name) {
      if (activeCategories.has(name)) {
        activeCategories.delete(name);
        activeCategories.add(newName);
      }
    }

    const presentCats = new Set(allNodes.map(n => n.payload.category));
    buildCategorySidebar(presentCats);
    applyGraphData();
    updateStats();

    overlay.remove();
  });

  overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
}

function deleteCategoryUI(name, count, chipEl) {
  const overlay = document.createElement('div');
  overlay.className = 'tag-delete-overlay';
  const allCats = allCategoryNames.filter(c => c !== name);

  // Check if this category has children
  const children = allCategoryNames.filter(c => {
    const meta = categoryMetadata[c] || {};
    return meta.parent === name;
  });

  const hasChildren = children.length > 0;
  const hasMemories = count > 0;

  if (!hasMemories && !hasChildren) {
    // Simple delete
    overlay.innerHTML = `
      <div class="tag-delete-modal">
        <div class="tag-delete-modal-title">Delete category</div>
        <div class="tag-delete-modal-tag">${name}</div>
        <div class="tag-delete-modal-actions">
          <button class="action-btn action-btn--ghost cat-modal-cancel">Cancel</button>
          <button class="action-btn action-btn--danger cat-modal-confirm">Delete</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    overlay.querySelector('.cat-modal-cancel').addEventListener('click', () => overlay.remove());
    overlay.querySelector('.cat-modal-confirm').addEventListener('click', () => {
      overlay.remove();
      deleteCategory(name);
    });
    overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
  } else {
    // Need reassignment
    let htmlContent = `
      <div class="tag-delete-modal">
        <div class="tag-delete-modal-title">Delete category</div>
        <div class="tag-delete-modal-tag">${name}</div>
    `;

    if (hasMemories) {
      htmlContent += `
        <div style="font-size:var(--fs-sm);color:var(--t-secondary);margin-bottom:8px">
          ${count} memor${count === 1 ? 'y uses' : 'ies use'} this category.<br>Reassign memories to:
        </div>
        <select class="cat-modal-select-memories modal-select" style="margin-bottom:12px">
          ${allCats.map(c => `<option value="${c}">${c}</option>`).join('')}
        </select>
      `;
    }

    if (hasChildren) {
      // Get all categories except this one and its descendants (to prevent circular dependencies)
      const getDescendants = (catName) => {
        const directChildren = allCategoryNames.filter(c => {
          const m = categoryMetadata[c] || {};
          return m.parent === catName;
        });
        const allDescendants = [...directChildren];
        directChildren.forEach(child => {
          allDescendants.push(...getDescendants(child));
        });
        return allDescendants;
      };
      const descendants = getDescendants(name);
      const descendantSet = new Set(descendants);
      const availableParents = allCategoryNames.filter(c => c !== name && !descendantSet.has(c));

      htmlContent += `
        <div style="font-size:var(--fs-sm);color:var(--t-secondary);margin-bottom:8px">
          ${children.length} child categor${children.length === 1 ? 'y' : 'ies'}: ${children.join(', ')}<br>Reassign children to:
        </div>
        <select class="cat-modal-select-children modal-select" style="margin-bottom:12px">
          <option value="">-- Make top-level --</option>
          ${availableParents.map(c => `<option value="${c}">${c}</option>`).join('')}
        </select>
      `;
    }

    htmlContent += `
        <div class="tag-delete-modal-actions">
          <button class="action-btn action-btn--ghost cat-modal-cancel">Cancel</button>
          <button class="action-btn action-btn--danger cat-modal-confirm">Delete & Reassign</button>
        </div>
      </div>
    `;

    overlay.innerHTML = htmlContent;
    document.body.appendChild(overlay);
    overlay.querySelector('.cat-modal-cancel').addEventListener('click', () => overlay.remove());
    overlay.querySelector('.cat-modal-confirm').addEventListener('click', async () => {
      const targetMemories = hasMemories ? overlay.querySelector('.cat-modal-select-memories')?.value : null;
      const targetChildren = hasChildren ? overlay.querySelector('.cat-modal-select-children')?.value : undefined;
      const btn = overlay.querySelector('.cat-modal-confirm');
      btn.textContent = 'Deleting...';
      btn.disabled = true;
      await deleteCategory(name, targetMemories, targetChildren);
      overlay.remove();
    });
    overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
  }
}

async function deleteCategory(name, reassignTo, reassignChildrenTo) {
  const body = {};
  if (reassignTo) body.reassign_to = reassignTo;
  if (reassignChildrenTo !== undefined) body.reassign_children_to = reassignChildrenTo;

  const res = await fetch('/api/categories/' + encodeURIComponent(name), {
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  });
  const data = await res.json();
  if (!res.ok) {
    console.error('deleteCategory error:', data.error);
    alert('Error deleting category: ' + data.error);
    return;
  }
  allCategoryNames = data.categories.map(c => c.name);
  categoryDescriptions = {};
  data.categories.forEach(c => categoryDescriptions[c.name] = c.description);
  // Update categoryMetadata
  categoryMetadata = {};
  data.categories.forEach(c => {
    categoryMetadata[c.name] = { parent: c.parent, color: c.color, is_parent: c.is_parent };
  });
  // Remove color override
  try {
    const overrides = JSON.parse(localStorage.getItem('neural-category-colors') || '{}');
    delete overrides[name];
    localStorage.setItem('neural-category-colors', JSON.stringify(overrides));
  } catch {}
  activeCategories.delete(name);

  if (reassignTo || (data.reassigned && data.reassigned > 0)) {
    // Re-fetch memories since payloads changed
    const memRes = await fetch('/api/memories');
    if (memRes.ok) {
      const memData = await memRes.json();
      allNodes = memData.nodes;
      allLinks = memData.links;
    }
  }

  const presentCats = new Set(allNodes.map(n => n.payload.category));
  buildCategorySidebar(presentCats);
  applyGraphData();
  updateStats();
}

// Category create form wiring
{
  const $addBtn = document.getElementById('category-add-btn');
  const $addParentBtn = document.getElementById('category-add-parent-btn');
  const $form = document.getElementById('category-create-form');
  const $formTitle = document.getElementById('cat-form-title');
  const $nameInput = document.getElementById('cat-name-input');
  const $descInput = document.getElementById('cat-desc-input');
  const $parentSelect = document.getElementById('cat-parent-select');
  const $swatchRow = document.getElementById('color-swatch-row');
  const $error = document.getElementById('cat-form-error');
  const $createBtn = document.getElementById('cat-form-create');
  const $cancelBtn = document.getElementById('cat-form-cancel');
  let selectedColor = COLOR_PALETTE[0];
  let formMode = 'child'; // 'child' or 'parent'

  // Build swatches
  COLOR_PALETTE.forEach((color, i) => {
    const btn = document.createElement('button');
    btn.className = 'color-swatch' + (i === 0 ? ' selected' : '');
    btn.style.background = color;
    btn.addEventListener('click', () => {
      $swatchRow.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
      btn.classList.add('selected');
      selectedColor = color;
    });
    $swatchRow.appendChild(btn);
  });

  // Populate parent dropdown
  function populateParentDropdown() {
    // Clear and re-populate with all categories
    $parentSelect.innerHTML = '<option value="">(None - standalone category)</option>';
    allCategoryNames.forEach(catName => {
      const opt = document.createElement('option');
      opt.value = catName;
      opt.textContent = catName;
      $parentSelect.appendChild(opt);
    });
  }

  function openForm(mode) {
    formMode = mode;
    $form.dataset.mode = mode;
    $form.classList.add('open');

    if (mode === 'parent') {
      $formTitle.textContent = 'CREATE PARENT CATEGORY';
      $nameInput.placeholder = 'parent-category-name';
      $descInput.placeholder = 'What does this group contain?';
    } else {
      $formTitle.textContent = 'CREATE CATEGORY';
      $nameInput.placeholder = 'category-name';
      $descInput.placeholder = 'Short description...';
      populateParentDropdown();
    }

    $nameInput.focus();
  }

  function closeForm() {
    $form.classList.remove('open');
    $nameInput.value = '';
    $descInput.value = '';
    $parentSelect.value = '';
    $error.textContent = '';
    $createBtn.disabled = true;
    $nameInput.classList.remove('invalid');
  }

  function validateForm() {
    const name = $nameInput.value;
    const desc = $descInput.value.trim();
    if (!name) { $error.textContent = ''; $createBtn.disabled = true; return; }
    if (name.length < 2) { $error.textContent = 'Min 2 characters'; $createBtn.disabled = true; return; }
    if (!/^[a-z][a-z0-9-]*$/.test(name)) { $error.textContent = 'Lowercase, starts with letter, letters/digits/hyphens only'; $createBtn.disabled = true; $nameInput.classList.add('invalid'); return; }
    $nameInput.classList.remove('invalid');
    if (!desc) { $error.textContent = 'Description required'; $createBtn.disabled = true; return; }
    $error.textContent = '';
    $createBtn.disabled = false;
  }

  $nameInput.addEventListener('input', () => {
    // Auto-lowercase and strip invalid chars as user types
    $nameInput.value = $nameInput.value.toLowerCase().replace(/[^a-z0-9-]/g, '');
    validateForm();
  });
  $descInput.addEventListener('input', validateForm);

  $addBtn.addEventListener('click', () => {
    if ($form.classList.contains('open')) {
      closeForm();
    } else {
      openForm('child');
    }
  });

  $addParentBtn.addEventListener('click', () => {
    if ($form.classList.contains('open')) {
      closeForm();
    } else {
      openForm('parent');
    }
  });

  $cancelBtn.addEventListener('click', () => {
    closeForm();
  });

  $createBtn.addEventListener('click', async () => {
    const name = $nameInput.value;
    const desc = $descInput.value.trim();
    // Only pass parent if we're in child mode
    const parent = formMode === 'child' ? ($parentSelect.value || null) : null;
    const isParent = formMode === 'parent';
    $createBtn.disabled = true;
    $createBtn.textContent = 'Creating...';
    try {
      await createCategory(name, desc, selectedColor, parent, isParent);
      closeForm();
    } catch (e) {
      $error.textContent = e.message;
    }
    $createBtn.textContent = 'Create';
    validateForm();
  });
}

// ═══════════════════════════════════════════
// KEYBOARD SHORTCUTS
// ═══════════════════════════════════════════
document.addEventListener('keydown', (e) => {
  const inInput = document.activeElement?.tagName === 'INPUT' || document.activeElement?.tagName === 'TEXTAREA';

  if (e.key === 'Escape') {
    const catModal = document.querySelector('.cat-change-modal');
    const colorPicker = document.querySelector('.color-edit-picker');
    const descEditor = document.querySelector('.category-desc-editor');
    if (catModal) {
      catModal.closest('.tag-delete-overlay')?.remove();
    } else if (descEditor) {
      closeDescEditor();
    } else if (colorPicker) {
      closeColorPicker();
    } else if (document.getElementById('category-create-form')?.classList.contains('open')) {
      document.getElementById('category-create-form').classList.remove('open');
    } else if ($helpOverlay.classList.contains('open')) {
      closeHelp();
    } else if (layoutsPanelOpen) {
      closeLayoutsPanel();
    } else if ($searchInput.value) {
      $searchInput.value = '';
      clearSearch();
    } else if (selectedNodeId) {
      closeDetailPanel();
    }
  }

  // Toggle help with ?
  if (e.key === '?' && !inInput) {
    e.preventDefault();
    $helpOverlay.classList.contains('open') ? closeHelp() : openHelp();
  }

  // Focus search with /
  if (e.key === '/' && !inInput) {
    e.preventDefault();
    $searchInput.focus();
  }
});

// Detail panel close
document.getElementById('detail-close').addEventListener('click', () => {
  closeDetailPanel();
});

// Reset node positions
document.getElementById('reset-positions-btn').addEventListener('click', () => {
  if (!graph) return;
  const nodes = graph.graphData().nodes;
  nodes.forEach(node => {
    node.fx = undefined;
    node.fy = undefined;
    node.fz = undefined;
  });
  graph.d3ReheatSimulation();
  activePresetId = null;
  renderPresetList();
});

// ═══════════════════════════════════════════
// WINDOW RESIZE
// ═══════════════════════════════════════════
function clampPanelsToViewport() {
  // Clamp all positioned panels within viewport bounds
  document.querySelectorAll('.resizable').forEach(el => {
    const minVisible = 60; // Minimum pixels that must remain visible horizontally
    const minHeight = 100; // Minimum height
    const minWidth = 140; // Minimum width

    // Get current dimensions
    let rect = el.getBoundingClientRect();

    // Clamp left position - keep panel fully visible horizontally
    if (el.style.left) {
      const currentLeft = parseInt(el.style.left);
      const maxLeft = Math.max(0, window.innerWidth - rect.width - 10);
      if (currentLeft > maxLeft) {
        el.style.left = maxLeft + 'px';
      }
    }

    // Clamp top position - keep panel fully visible vertically
    if (el.style.top) {
      const currentTop = parseInt(el.style.top);
      const maxTop = Math.max(0, window.innerHeight - rect.height - 10);
      if (currentTop > maxTop) {
        el.style.top = maxTop + 'px';
      }
    }

    // Get updated rect after position clamping
    rect = el.getBoundingClientRect();

    // Clamp width if panel extends beyond viewport
    if (rect.right > window.innerWidth && el.style.width) {
      const maxWidth = window.innerWidth - rect.left - 10;
      if (maxWidth > minWidth) {
        el.style.width = maxWidth + 'px';
      }
    }

    // Clamp height if panel extends beyond viewport
    rect = el.getBoundingClientRect(); // Get rect again after width adjustment
    if (rect.bottom > window.innerHeight) {
      const maxHeight = window.innerHeight - rect.top - 10; // 10px margin from bottom
      if (maxHeight > minHeight) {
        // Always enforce max-height constraint
        el.style.maxHeight = maxHeight + 'px';
        // If panel has explicit height that exceeds max, clamp it
        if (el.style.height && el.style.height !== 'auto') {
          const currentHeight = parseInt(el.style.height);
          if (currentHeight > maxHeight) {
            el.style.height = maxHeight + 'px';
          }
        }
      }
    }
  });
}

window.addEventListener('resize', () => {
  if (graph) {
    graph.width(window.innerWidth);
    graph.height(window.innerHeight);
  }
  // Clamp panels to stay within viewport
  clampPanelsToViewport();
});

// ═══════════════════════════════════════════
// PANEL DRAG + RESIZE
// ═══════════════════════════════════════════
{
  const sidebar = document.getElementById('category-sidebar');
  const detail = document.getElementById('detail-panel');
  let resizing = null;
  let dragging = null;
  const MIN_W = 140;
  const MIN_H = 100;

  // Helper: ensure panel uses left/top positioning (not right)
  function ensureLeftTop(el) {
    const rect = el.getBoundingClientRect();
    el.style.left = rect.left + 'px';
    el.style.top = rect.top + 'px';
    el.style.right = 'auto';
  }

  // --- Resize (all 8 directions, any panel) ---
  document.querySelectorAll('.resize-handle').forEach(handle => {
    handle.addEventListener('mousedown', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const dir = handle.dataset.resize;
      const el = handle.closest('.resizable');
      if (!el) return;

      const rect = el.getBoundingClientRect();
      ensureLeftTop(el);

      resizing = {
        el, dir,
        startX: e.clientX, startY: e.clientY,
        startW: rect.width, startH: rect.height,
        startL: rect.left, startT: rect.top,
      };
      handle.classList.add('active');
      el.classList.add('dragging');
      document.body.style.cursor = getComputedStyle(handle).cursor;
      document.body.style.userSelect = 'none';
    });
  });

  // --- Drag ---
  document.querySelectorAll('.drag-handle').forEach(handle => {
    handle.addEventListener('mousedown', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const el = document.getElementById(handle.dataset.drag);
      if (!el) return;

      ensureLeftTop(el);
      const rect = el.getBoundingClientRect();
      el.classList.add('dragging');

      dragging = { el, startX: e.clientX, startY: e.clientY, startLeft: rect.left, startTop: rect.top };
      document.body.style.cursor = 'grabbing';
      document.body.style.userSelect = 'none';
    });
  });

  document.addEventListener('mousemove', (e) => {
    // Resize
    if (resizing) {
      const { el, dir, startX, startY, startW, startH, startL, startT } = resizing;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;

      let newW = startW, newH = startH, newL = startL, newT = startT;

      // Right edge
      if (dir === 'r' || dir === 'br' || dir === 'tr') {
        newW = Math.max(MIN_W, startW + dx);
      }
      // Left edge (grow left = shrink from left, move left)
      if (dir === 'l' || dir === 'bl' || dir === 'tl') {
        newW = Math.max(MIN_W, startW - dx);
        newL = startL + startW - newW;
      }
      // Bottom edge
      if (dir === 'b' || dir === 'br' || dir === 'bl') {
        newH = Math.max(MIN_H, startH + dy);
      }
      // Top edge (grow up)
      if (dir === 't' || dir === 'tr' || dir === 'tl') {
        newH = Math.max(MIN_H, startH - dy);
        newT = startT + startH - newH;
      }

      // Clamp to viewport bounds
      newL = Math.max(0, newL);
      newT = Math.max(0, newT);

      // Ensure panel doesn't extend beyond viewport
      const maxWidth = window.innerWidth - newL - 10;
      const maxHeight = window.innerHeight - newT - 10;
      newW = Math.min(newW, maxWidth);
      newH = Math.min(newH, maxHeight);

      el.style.width = newW + 'px';
      el.style.height = newH + 'px';
      el.style.left = newL + 'px';
      el.style.top = newT + 'px';
      el.style.maxHeight = maxHeight + 'px'; // Enforce max-height based on viewport
    }

    // Drag
    if (dragging) {
      const { el, startX, startY, startLeft, startTop } = dragging;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      const rect = el.getBoundingClientRect();

      // Calculate maximum positions that keep panel fully within viewport
      const maxLeft = Math.max(0, window.innerWidth - rect.width - 10); // Keep 10px margin from right
      const maxTop = Math.max(0, window.innerHeight - rect.height - 10); // Keep 10px margin from bottom

      const newLeft = Math.max(0, Math.min(maxLeft, startLeft + dx));
      const newTop = Math.max(0, Math.min(maxTop, startTop + dy));

      el.style.left = newLeft + 'px';
      el.style.top = newTop + 'px';
    }
  });

  // Save panel layout to localStorage
  function savePanelLayout(el) {
    const id = el.id;
    const rect = el.getBoundingClientRect();
    const data = {
      left: el.style.left || null,
      top: el.style.top || null,
      right: el.style.right || null,
      width: el.style.width || null,
      height: el.style.height || null,
      maxHeight: el.style.maxHeight || null,
    };
    localStorage.setItem('neural-panel-' + id, JSON.stringify(data));
  }

  document.addEventListener('mouseup', () => {
    if (resizing) {
      document.querySelectorAll('.resize-handle.active').forEach(h => h.classList.remove('active'));
      resizing.el.classList.remove('dragging');
      savePanelLayout(resizing.el);
      resizing = null;
    }
    if (dragging) {
      dragging.el.classList.remove('dragging');
      savePanelLayout(dragging.el);
      dragging = null;
    }
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  });

  // Restore saved layouts on load
  function restorePanelLayout(el, sizeOnly) {
    const saved = localStorage.getItem('neural-panel-' + el.id);
    if (!saved) return;
    try {
      const data = JSON.parse(saved);
      // Position — only restore if not sizeOnly
      if (!sizeOnly) {
        if (data.left && data.left !== 'auto') el.style.left = data.left;
        if (data.top) el.style.top = data.top;
        if (data.right) el.style.right = data.right;
      }
      // Size — always restore
      if (data.width) el.style.width = data.width;
      if (data.height) el.style.height = data.height;
      // Don't set maxHeight='none' - let viewport clamping handle it
    } catch {}
  }

  restorePanelLayout(sidebar, false);
  // Detail panel: only restore size now, restore position when it opens
  restorePanelLayout(detail, true);

  // Clamp restored panels to current viewport
  clampPanelsToViewport();
}

// ═══════════════════════════════════════════
// PER-PANEL PIN TOGGLE
// ═══════════════════════════════════════════
document.querySelectorAll('.pin-btn').forEach(btn => {
  const panelId = btn.dataset.pin;
  const panel = document.getElementById(panelId);
  const key = 'neural-pinned-' + panelId;

  // Restore saved state
  if (localStorage.getItem(key) === 'true') {
    panel.classList.add('locked');
    btn.classList.add('pinned');
  }

  btn.addEventListener('click', (e) => {
    e.stopPropagation();
    const pinned = panel.classList.toggle('locked');
    btn.classList.toggle('pinned', pinned);
    localStorage.setItem(key, pinned);
  });
});

// ═══════════════════════════════════════════
// BOOKMARKS
// ═══════════════════════════════════════════
const $bookmarksBtn = document.getElementById('bookmarks-btn');
const $bookmarksPanel = document.getElementById('bookmarks-panel');
const $bookmarksList = document.getElementById('bookmarks-list');
const $bookmarkCount = document.getElementById('bookmark-count');
let bookmarksPanelOpen = false;

function getBookmarks() {
  try { return JSON.parse(localStorage.getItem('neural-bookmarks') || '[]'); }
  catch { return []; }
}

function saveBookmarks(arr) {
  localStorage.setItem('neural-bookmarks', JSON.stringify(arr));
  updateBookmarkCount();
}

function isBookmarked(nodeId) {
  return getBookmarks().some(b => b.id === nodeId);
}

function toggleBookmark(node) {
  const bookmarks = getBookmarks();
  const idx = bookmarks.findIndex(b => b.id === node.id);
  if (idx !== -1) {
    bookmarks.splice(idx, 1);
  } else {
    const p = node.payload || {};
    const preview = (p.content || '').replace(/\n/g, ' ').slice(0, 80);
    bookmarks.unshift({
      id: node.id,
      title: preview || node.id,
      category: p.category || 'unknown',
      added: Date.now(),
    });
  }
  saveBookmarks(bookmarks);
  return isBookmarked(node.id);
}

function updateBookmarkCount() {
  const count = getBookmarks().length;
  $bookmarkCount.textContent = count > 0 ? count : '';
}

function updateDetailBookmarkBtn(nodeId) {
  const btn = document.getElementById('detail-bookmark-btn');
  const svg = btn.querySelector('svg');
  if (isBookmarked(nodeId)) {
    btn.classList.add('active');
    svg.classList.add('filled');
  } else {
    btn.classList.remove('active');
    svg.classList.remove('filled');
  }
}

function renderBookmarksList() {
  const bookmarks = getBookmarks();
  $bookmarksList.innerHTML = '';
  if (bookmarks.length === 0) {
    $bookmarksList.innerHTML = '<div class="dropdown-empty">No bookmarks yet.<br>Click the bookmark icon on any memory to save it here.</div>';
    return;
  }
  bookmarks.forEach(b => {
    const item = document.createElement('div');
    item.className = 'dropdown-item';
    const color = catColor(b.category);
    item.innerHTML = `
      <div class="dropdown-item-dot" style="background:${color}"></div>
      <div class="dropdown-item-text">
        <div class="dropdown-item-title">${b.title}</div>
        <div class="dropdown-item-sub">${b.category}</div>
      </div>
      <button class="icon-btn icon-btn--danger" style="width:22px;height:22px;font-size:13px;border:none" title="Remove bookmark">&times;</button>
    `;
    // Click item → navigate to node
    const navToBookmark = () => {
      const node = allNodes.find(n => n.id === b.id);
      if (node) {
        closeBookmarksPanel();
        navigateToNode(node, { zoom: 'gentle' });
      }
    };
    item.querySelector('.dropdown-item-text').addEventListener('click', navToBookmark);
    item.querySelector('.dropdown-item-dot').addEventListener('click', navToBookmark);
    // Remove button
    item.querySelector('.icon-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      const bks = getBookmarks().filter(x => x.id !== b.id);
      saveBookmarks(bks);
      renderBookmarksList();
      if (selectedNodeId === b.id) updateDetailBookmarkBtn(b.id);
    });
    $bookmarksList.appendChild(item);
  });
}

function openBookmarksPanel() {
  bookmarksPanelOpen = true;
  $bookmarksPanel.classList.add('open');
  $bookmarksBtn.classList.add('active');
  renderBookmarksList();
}

function closeBookmarksPanel() {
  bookmarksPanelOpen = false;
  $bookmarksPanel.classList.remove('open');
  $bookmarksBtn.classList.remove('active');
}

$bookmarksBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  if (typeof closeLayoutsPanel === 'function' && layoutsPanelOpen) closeLayoutsPanel();
  if (bookmarksPanelOpen) closeBookmarksPanel();
  else openBookmarksPanel();
});

$bookmarksPanel.addEventListener('click', (e) => e.stopPropagation());

document.addEventListener('click', () => {
  if (bookmarksPanelOpen) closeBookmarksPanel();
});

// Detail panel bookmark toggle
document.getElementById('detail-bookmark-btn').addEventListener('click', () => {
  const node = allNodes.find(n => n.id === selectedNodeId);
  if (!node) return;
  toggleBookmark(node);
  updateDetailBookmarkBtn(node.id);
});

updateBookmarkCount();

// ═══════════════════════════════════════════
// LAYOUT PRESETS
// ═══════════════════════════════════════════
const $layoutsBtn = document.getElementById('layouts-btn');
const $layoutsPanel = document.getElementById('layouts-panel');
const $presetNameInput = document.getElementById('preset-name-input');
const $presetSaveBtn = document.getElementById('preset-save-btn');
const $presetList = document.getElementById('preset-list');
const $presetWarning = document.getElementById('preset-warning');
let layoutsPanelOpen = false;
let activePresetId = null;

function getPresets() {
  try {
    return JSON.parse(localStorage.getItem('neural-layout-presets') || '[]');
  } catch { return []; }
}

function savePresets(arr) {
  localStorage.setItem('neural-layout-presets', JSON.stringify(arr));
}

// ── Built-in presets (cannot be deleted) ──

function generateCategoryCluster() {
  if (!graph) return null;
  const nodes = graph.graphData().nodes;
  if (nodes.length === 0) return null;

  const groups = {};
  nodes.forEach(n => {
    const cat = n.payload.category || 'unknown';
    if (!groups[cat]) groups[cat] = [];
    groups[cat].push(n);
  });

  const catNames = Object.keys(groups);
  const catCount = catNames.length;

  // Large separation radius so clusters are visually distinct
  const maxMembers = Math.max(...catNames.map(c => groups[c].length));
  const clusterSpread = Math.max(40, Math.sqrt(maxMembers) * 22);
  const RADIUS = Math.max(300, catCount * 55, clusterSpread * 3.5);

  const positions = {};
  const goldenAngle = Math.PI * (3 - Math.sqrt(5));

  catNames.forEach((cat, i) => {
    // Fibonacci sphere distribution for category centers
    const phi = Math.acos(1 - 2 * (i + 0.5) / catCount);
    const theta = goldenAngle * i;
    const cx = RADIUS * Math.sin(phi) * Math.cos(theta);
    const cy = RADIUS * Math.cos(phi);
    const cz = RADIUS * Math.sin(phi) * Math.sin(theta);

    const members = groups[cat];
    const spread = Math.max(30, Math.sqrt(members.length) * 22);

    members.forEach((node, j) => {
      // Fibonacci sphere for each node within the cluster
      const subPhi = Math.acos(1 - 2 * (j + 0.5) / members.length);
      const subTheta = goldenAngle * j;
      // Layer radius: nodes towards center are closer, outer ones further
      const layer = Math.cbrt((j + 1) / members.length);
      const r = spread * layer;

      positions[node.id] = {
        x: cx + r * Math.sin(subPhi) * Math.cos(subTheta),
        y: cy + r * Math.cos(subPhi),
        z: cz + r * Math.sin(subPhi) * Math.sin(subTheta),
      };
    });
  });

  return positions;
}

function generateCategoryHelix() {
  if (!graph) return null;
  const nodes = graph.graphData().nodes;
  if (nodes.length === 0) return null;

  const groups = {};
  nodes.forEach(n => {
    const cat = n.payload.category || 'unknown';
    if (!groups[cat]) groups[cat] = [];
    groups[cat].push(n);
  });

  const catNames = Object.keys(groups);
  const catCount = catNames.length;
  const HELIX_RADIUS = Math.max(150, catCount * 25);
  const HELIX_HEIGHT = Math.max(300, catCount * 60);
  const positions = {};
  const goldenAngle = Math.PI * (3 - Math.sqrt(5));

  catNames.forEach((cat, i) => {
    // Each category sits at a point along a double helix
    const t = i / Math.max(catCount - 1, 1); // 0..1
    const angle = i * goldenAngle * 3;
    const cx = HELIX_RADIUS * Math.cos(angle);
    const cy = (t - 0.5) * HELIX_HEIGHT;
    const cz = HELIX_RADIUS * Math.sin(angle);

    const members = groups[cat];
    const spread = Math.max(20, Math.sqrt(members.length) * 14);

    // Scatter members in a 3D sphere around the helix point
    members.forEach((node, j) => {
      const phi = Math.acos(1 - 2 * (j + 0.5) / members.length);
      const theta = goldenAngle * j;
      const r = spread * (0.4 + 0.6 * Math.cbrt((j + 1) / members.length));
      positions[node.id] = {
        x: cx + r * Math.sin(phi) * Math.cos(theta),
        y: cy + r * Math.cos(phi),
        z: cz + r * Math.sin(phi) * Math.sin(theta),
      };
    });
  });

  return positions;
}

function generateCategoryOrbits() {
  if (!graph) return null;
  const nodes = graph.graphData().nodes;
  if (nodes.length === 0) return null;

  const groups = {};
  nodes.forEach(n => {
    const cat = n.payload.category || 'unknown';
    if (!groups[cat]) groups[cat] = [];
    groups[cat].push(n);
  });

  const catNames = Object.keys(groups);
  const catCount = catNames.length;
  const positions = {};

  // Each category gets its own tilted orbital ring at a different radius
  catNames.forEach((cat, i) => {
    const members = groups[cat];
    const orbitRadius = 100 + i * 45;
    // Tilt each orbital plane differently in 3D
    const tiltX = (i * 0.618) * Math.PI * 0.6; // golden ratio tilt
    const tiltZ = (i * 0.382) * Math.PI * 0.4;

    members.forEach((node, j) => {
      const angle = (j / members.length) * Math.PI * 2;
      // Position on a flat ring first
      let px = orbitRadius * Math.cos(angle);
      let py = 0;
      let pz = orbitRadius * Math.sin(angle);

      // Add slight radial scatter
      const scatter = 15 + Math.sqrt(members.length) * 3;
      px += (Math.sin(j * 7.3) * scatter * 0.5);
      py += (Math.cos(j * 4.1) * scatter * 0.5);
      pz += (Math.sin(j * 5.7) * scatter * 0.5);

      // Rotate around X axis (tilt)
      const y1 = py * Math.cos(tiltX) - pz * Math.sin(tiltX);
      const z1 = py * Math.sin(tiltX) + pz * Math.cos(tiltX);
      // Rotate around Z axis (second tilt)
      const x2 = px * Math.cos(tiltZ) - y1 * Math.sin(tiltZ);
      const y2 = px * Math.sin(tiltZ) + y1 * Math.cos(tiltZ);

      positions[node.id] = { x: x2, y: y2, z: z1 };
    });
  });

  return positions;
}

function generateCategoryTower() {
  if (!graph) return null;
  const nodes = graph.graphData().nodes;
  if (nodes.length === 0) return null;

  const groups = {};
  nodes.forEach(n => {
    const cat = n.payload.category || 'unknown';
    if (!groups[cat]) groups[cat] = [];
    groups[cat].push(n);
  });

  const catNames = Object.keys(groups);
  const catCount = catNames.length;
  const FLOOR_HEIGHT = 80;
  const positions = {};

  // Stack categories as floors, each floor a different shape
  catNames.forEach((cat, i) => {
    const members = groups[cat];
    const cy = (i - (catCount - 1) / 2) * FLOOR_HEIGHT;
    const floorRadius = Math.max(40, Math.sqrt(members.length) * 20);
    // Alternate rotation per floor for visual interest
    const rotOffset = i * Math.PI * 0.3;

    members.forEach((node, j) => {
      // Arrange in a 3D disc: concentric rings with slight vertical scatter
      const ring = Math.floor(Math.sqrt(j));
      const ringIdx = j - ring * ring;
      const ringSize = 2 * ring + 1;
      const angle = rotOffset + (ringIdx / ringSize) * Math.PI * 2;
      const r = (ring + 1) * (floorRadius / (Math.sqrt(members.length) + 1));
      const yJitter = (Math.sin(j * 3.7) * FLOOR_HEIGHT * 0.15);

      positions[node.id] = {
        x: r * Math.cos(angle),
        y: cy + yJitter,
        z: r * Math.sin(angle),
      };
    });
  });

  return positions;
}

function generateCategoryDNA() {
  if (!graph) return null;
  const nodes = graph.graphData().nodes;
  if (nodes.length === 0) return null;

  const groups = {};
  nodes.forEach(n => {
    const cat = n.payload.category || 'unknown';
    if (!groups[cat]) groups[cat] = [];
    groups[cat].push(n);
  });

  const catNames = Object.keys(groups);
  const catCount = catNames.length;
  const STRAND_RADIUS = Math.max(100, catCount * 18);
  const TOTAL_HEIGHT = Math.max(400, catCount * 70);
  const positions = {};

  // Two interleaved helical strands, categories alternate between them
  catNames.forEach((cat, i) => {
    const members = groups[cat];
    const strand = i % 2; // which helix strand
    const step = Math.floor(i / 2);
    const t = step / Math.max(Math.ceil(catCount / 2) - 1, 1);
    const angle = t * Math.PI * 4 + strand * Math.PI; // 2 full turns, offset by PI

    const cx = STRAND_RADIUS * Math.cos(angle);
    const cy = (t - 0.5) * TOTAL_HEIGHT;
    const cz = STRAND_RADIUS * Math.sin(angle);

    const spread = Math.max(18, Math.sqrt(members.length) * 12);
    const goldenAngle = Math.PI * (3 - Math.sqrt(5));

    members.forEach((node, j) => {
      const phi = Math.acos(1 - 2 * (j + 0.5) / members.length);
      const theta = goldenAngle * j;
      const r = spread * Math.cbrt((j + 1) / members.length);
      positions[node.id] = {
        x: cx + r * Math.sin(phi) * Math.cos(theta),
        y: cy + r * Math.cos(phi),
        z: cz + r * Math.sin(phi) * Math.sin(theta),
      };
    });
  });

  return positions;
}

const BUILTIN_PRESETS = [
  { id: '__clusters', name: 'Category Clusters', desc: '3D sphere with category clusters', generate: generateCategoryCluster },
  { id: '__helix', name: 'Category Helix', desc: '3D helix spiral by category', generate: generateCategoryHelix },
  { id: '__orbits', name: 'Category Orbits', desc: 'Tilted orbital rings per category', generate: generateCategoryOrbits },
  { id: '__tower', name: 'Category Tower', desc: 'Stacked floors by category', generate: generateCategoryTower },
  { id: '__dna', name: 'Category DNA', desc: 'Double helix with interleaved categories', generate: generateCategoryDNA },
];

function loadBuiltinPreset(builtin) {
  if (!graph) return;
  const positions = builtin.generate();
  if (!positions) return;

  const nodes = graph.graphData().nodes;
  nodes.forEach(node => {
    const saved = positions[node.id];
    if (saved) {
      node.fx = saved.x;
      node.fy = saved.y;
      node.fz = saved.z;
    } else {
      node.fx = undefined;
      node.fy = undefined;
      node.fz = undefined;
    }
  });

  graph.d3ReheatSimulation();

  // Zoom camera out based on actual extent of positions
  let maxDist = 0;
  for (const p of Object.values(positions)) {
    const d = Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z);
    if (d > maxDist) maxDist = d;
  }
  const camDist = Math.max(400, maxDist * 2.2);
  graph.cameraPosition({ x: camDist * 0.7, y: camDist * 0.5, z: camDist * 0.7 }, { x: 0, y: 0, z: 0 }, 2000);

  activePresetId = builtin.id;
  renderPresetList();
}

// ── User presets ──

function saveCurrentLayout(name) {
  if (!graph) return;
  const nodes = graph.graphData().nodes;
  const positions = {};
  let pinnedCount = 0;

  nodes.forEach(node => {
    if (node.fx !== undefined && node.fx !== null) {
      positions[node.id] = { x: node.fx, y: node.fy, z: node.fz };
      pinnedCount++;
    }
  });

  if (pinnedCount === 0) {
    $presetWarning.classList.add('visible');
    setTimeout(() => $presetWarning.classList.remove('visible'), 2500);
    return;
  }

  const cam = graph.camera();
  const controls = graph.controls();
  const camera = {
    position: { x: cam.position.x, y: cam.position.y, z: cam.position.z },
    lookAt: controls.target ? { x: controls.target.x, y: controls.target.y, z: controls.target.z } : { x: 0, y: 0, z: 0 }
  };

  const preset = {
    id: String(Date.now()),
    name: name.trim(),
    created: new Date().toISOString(),
    positions,
    camera
  };

  const presets = getPresets();
  presets.unshift(preset);
  savePresets(presets);
  activePresetId = preset.id;

  $presetNameInput.value = '';
  $presetWarning.classList.remove('visible');
  renderPresetList();
}

function loadPreset(preset) {
  if (!graph) return;
  const nodes = graph.graphData().nodes;

  nodes.forEach(node => {
    const saved = preset.positions[node.id];
    if (saved) {
      node.fx = saved.x;
      node.fy = saved.y;
      node.fz = saved.z;
    } else {
      node.fx = undefined;
      node.fy = undefined;
      node.fz = undefined;
    }
  });

  graph.d3ReheatSimulation();

  if (preset.camera) {
    graph.cameraPosition(
      preset.camera.position,
      preset.camera.lookAt,
      2000
    );
  }

  activePresetId = preset.id;
  renderPresetList();
}

function deletePreset(id) {
  const presets = getPresets().filter(p => p.id !== id);
  savePresets(presets);
  if (activePresetId === id) activePresetId = null;
  renderPresetList();
}

function renderPresetList() {
  const presets = getPresets();
  $presetList.innerHTML = '';

  // Built-in presets first
  BUILTIN_PRESETS.forEach(bp => {
    const row = document.createElement('div');
    row.className = 'preset-row builtin' + (bp.id === activePresetId ? ' active' : '');
    row.innerHTML = `
      <span class="preset-name">${bp.name}</span>
      <span class="preset-badge">auto</span>
    `;
    row.title = bp.desc;
    row.addEventListener('click', () => loadBuiltinPreset(bp));
    $presetList.appendChild(row);
  });

  // Divider if user presets exist
  if (presets.length > 0) {
    const div = document.createElement('div');
    div.className = 'preset-divider';
    $presetList.appendChild(div);
  }

  // User presets
  presets.forEach(preset => {
    const nodeCount = Object.keys(preset.positions).length;
    const date = new Date(preset.created);
    const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

    const row = document.createElement('div');
    row.className = 'preset-row' + (preset.id === activePresetId ? ' active' : '');

    row.innerHTML = `
      <span class="preset-name">${preset.name}</span>
      <span class="preset-badge">${nodeCount}</span>
      <span class="preset-date">${dateStr}</span>
      <button class="preset-delete" title="Delete">&times;</button>
    `;

    row.addEventListener('click', (e) => {
      if (e.target.classList.contains('preset-delete')) return;
      loadPreset(preset);
    });

    row.querySelector('.preset-delete').addEventListener('click', (e) => {
      e.stopPropagation();
      deletePreset(preset.id);
    });

    $presetList.appendChild(row);
  });

  if (presets.length === 0 && BUILTIN_PRESETS.length === 0) {
    $presetList.innerHTML = '<div class="preset-empty">No saved layouts</div>';
  }
}

function openLayoutsPanel() {
  layoutsPanelOpen = true;
  $layoutsPanel.classList.add('open');
  $layoutsBtn.classList.add('active');
  renderPresetList();
}

function closeLayoutsPanel() {
  layoutsPanelOpen = false;
  $layoutsPanel.classList.remove('open');
  $layoutsBtn.classList.remove('active');
  $presetWarning.classList.remove('visible');
}

// Toggle panel
$layoutsBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  if (bookmarksPanelOpen) closeBookmarksPanel();
  if (layoutsPanelOpen) closeLayoutsPanel();
  else openLayoutsPanel();
});

// Prevent panel clicks from closing it
$layoutsPanel.addEventListener('click', (e) => e.stopPropagation());

// Close on background click
document.addEventListener('click', () => {
  if (layoutsPanelOpen) closeLayoutsPanel();
});

// Save on Enter or button click
$presetNameInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    const name = $presetNameInput.value.trim();
    if (name) saveCurrentLayout(name);
  }
});

$presetSaveBtn.addEventListener('click', () => {
  const name = $presetNameInput.value.trim();
  if (name) saveCurrentLayout(name);
});

// ═══════════════════════════════════════════
// HELP MODAL
// ═══════════════════════════════════════════
const $helpOverlay = document.getElementById('help-overlay');
const $helpBtn = document.getElementById('help-btn');

function openHelp() { $helpOverlay.classList.add('open'); }
function closeHelp() { $helpOverlay.classList.remove('open'); }

$helpBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  $helpOverlay.classList.contains('open') ? closeHelp() : openHelp();
});

document.getElementById('help-close').addEventListener('click', closeHelp);

$helpOverlay.addEventListener('click', (e) => {
  if (e.target === $helpOverlay) closeHelp();
});

// ═══════════════════════════════════════════
// SETTINGS MODAL
// ═══════════════════════════════════════════
async function openSettingsModal() {
  let settings = {};
  let qdrantOk = false;

  try {
    const [settingsRes, statsRes] = await Promise.allSettled([
      fetch('/api/settings').then(r => r.json()),
      fetch('/api/stats').then(r => r.json()),
    ]);
    if (settingsRes.status === 'fulfilled') settings = settingsRes.value;
    if (statsRes.status === 'fulfilled' && statsRes.value.status) qdrantOk = true;
  } catch {}

  const overlay = document.createElement('div');
  overlay.className = 'tag-delete-overlay';

  const eyeOpen = '<svg viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>';
  const eyeClosed = '<svg viewBox="0 0 24 24"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94"/><path d="M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19"/><line x1="1" y1="1" x2="23" y2="23"/></svg>';

  overlay.innerHTML = `
    <div class="tag-delete-modal settings-modal">
      <h3><svg viewBox="0 0 24 24" style="width:16px;height:16px;stroke:var(--accent-blue);stroke-width:2;fill:none"><path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>Settings</h3>

      <div class="settings-status">
        <span class="settings-status-dot ${qdrantOk ? 'connected' : 'disconnected'}"></span>
        Qdrant: ${qdrantOk ? 'Connected' : 'Not connected'}
      </div>

      <div class="settings-field">
        <label>OpenAI API Key</label>
        <div class="settings-key-row">
          <input type="password" id="stg-openai" placeholder="${settings.openaiApiKey || 'sk-...'}" autocomplete="off" spellcheck="false">
          <button class="settings-toggle-vis" data-target="stg-openai" title="Toggle visibility">${eyeClosed}</button>
        </div>
        <div class="settings-hint">${settings.openaiApiKeySet ? 'Key is set' : 'Not configured'} — leave empty to keep current</div>
      </div>

      <div class="settings-field">
        <label>Qdrant URL</label>
        <div class="settings-key-row">
          <input type="text" id="stg-qdrant-url" placeholder="${settings.qdrantUrl || 'http://localhost:6333'}" autocomplete="off" spellcheck="false">
        </div>
        <div class="settings-hint">Default: http://localhost:6333</div>
      </div>

      <div class="settings-field">
        <label>Qdrant API Key</label>
        <div class="settings-key-row">
          <input type="password" id="stg-qdrant-key" placeholder="${settings.qdrantApiKey || 'your-key'}" autocomplete="off" spellcheck="false">
          <button class="settings-toggle-vis" data-target="stg-qdrant-key" title="Toggle visibility">${eyeClosed}</button>
        </div>
        <div class="settings-hint">${settings.qdrantApiKeySet ? 'Key is set' : 'Not configured'} — leave empty to keep current</div>
      </div>

      <div class="settings-field">
        <label>Collection Name</label>
        <div class="settings-key-row">
          <input type="text" id="stg-collection" placeholder="${settings.collection || 'claude_memory'}" autocomplete="off" spellcheck="false">
        </div>
        <div class="settings-hint">Default: claude_memory</div>
      </div>

      <div class="settings-restart-notice" id="stg-restart-notice">Settings saved. Restart the server for changes to take effect.</div>

      <div class="settings-actions">
        <button class="settings-btn-cancel" id="stg-cancel">Cancel</button>
        <button class="settings-btn-save" id="stg-save">Save</button>
      </div>
    </div>
  `;

  document.body.appendChild(overlay);

  // Toggle visibility buttons
  overlay.querySelectorAll('.settings-toggle-vis').forEach(btn => {
    btn.addEventListener('click', () => {
      const input = overlay.querySelector('#' + btn.dataset.target);
      if (!input) return;
      const isPassword = input.type === 'password';
      input.type = isPassword ? 'text' : 'password';
      btn.innerHTML = isPassword ? eyeOpen : eyeClosed;
    });
  });

  // Close handlers
  const close = () => overlay.remove();
  overlay.querySelector('#stg-cancel').addEventListener('click', close);
  overlay.addEventListener('click', e => { if (e.target === overlay) close(); });

  // Save handler
  overlay.querySelector('#stg-save').addEventListener('click', async () => {
    const body = {};
    const openai = overlay.querySelector('#stg-openai').value.trim();
    const qdrantUrl = overlay.querySelector('#stg-qdrant-url').value.trim();
    const qdrantKey = overlay.querySelector('#stg-qdrant-key').value.trim();
    const collection = overlay.querySelector('#stg-collection').value.trim();

    if (openai) body.openaiApiKey = openai;
    if (qdrantUrl) body.qdrantUrl = qdrantUrl;
    if (qdrantKey) body.qdrantApiKey = qdrantKey;
    if (collection) body.collection = collection;

    if (Object.keys(body).length === 0) { close(); return; }

    try {
      const saveBtn = overlay.querySelector('#stg-save');
      saveBtn.textContent = 'Saving...';
      saveBtn.disabled = true;

      const res = await fetch('/api/settings', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      const data = await res.json();

      if (data.ok) {
        const notice = overlay.querySelector('#stg-restart-notice');
        notice.style.display = 'block';
        saveBtn.textContent = 'Saved';
        setTimeout(close, 3000);
      } else {
        saveBtn.textContent = 'Error';
        saveBtn.disabled = false;
      }
    } catch {
      const saveBtn = overlay.querySelector('#stg-save');
      saveBtn.textContent = 'Error';
      saveBtn.disabled = false;
    }
  });
}

document.getElementById('settings-btn').addEventListener('click', () => openSettingsModal());

// ═══════════════════════════════════════════
// BOOT
// ═══════════════════════════════════════════
init();
</script>
</body>
</html>
