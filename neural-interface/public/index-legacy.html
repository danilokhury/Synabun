<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neural Memory Interface</title>
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&family=Space+Grotesk:wght@500;600;700&display=swap" rel="stylesheet">
<style>
  /* ═══════════════════════════════════════════
     RESET & BASE
     ═══════════════════════════════════════════ */
  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    /* ── Text ── */
    --t-faint: rgba(255,255,255,0.2);
    --t-muted: rgba(255,255,255,0.3);
    --t-secondary: rgba(255,255,255,0.5);
    --t-primary: rgba(255,255,255,0.7);
    --t-bright: rgba(255,255,255,0.9);
    /* ── Surfaces ── */
    --s-transparent: transparent;
    --s-subtle: rgba(255,255,255,0.04);
    --s-light: rgba(255,255,255,0.06);
    --s-medium: rgba(255,255,255,0.10);
    --s-hover: rgba(255,255,255,0.08);
    --s-active: rgba(255,255,255,0.14);
    --s-panel: rgba(28,28,30,0.85);
    /* ── Borders ── */
    --b-subtle: rgba(255,255,255,0.06);
    --b-light: rgba(255,255,255,0.10);
    --b-hover: rgba(255,255,255,0.16);
    --b-visible: rgba(255,255,255,0.22);
    /* ── Accents ── */
    --accent-blue: #4FC3F7;
    --accent-blue-bg: rgba(79,195,247,0.10);
    --accent-blue-border: rgba(79,195,247,0.25);
    --accent-gold: rgba(255,215,0,0.85);
    --accent-gold-bg: rgba(255,215,0,0.10);
    --accent-gold-border: rgba(255,215,0,0.22);
    --accent-red: #FF5252;
    --accent-red-bg: rgba(255,82,82,0.15);
    --accent-red-hover: rgba(255,82,82,0.30);
    --accent-orange: #FFB74D;
    --accent-orange-bg: rgba(255,183,77,0.10);
    /* ── Radii ── */
    --r-pill: 20px;
    --r-button: 10px;
    --r-card: 8px;
    --r-circle: 50%;
    --r-small: 6px;
    /* ── Font sizes ── */
    --fs-xs: 12px;
    --fs-sm: 13px;
    --fs-md: 14px;
    --fs-base: 15px;
    --fs-lg: 16px;
    /* ── Transitions ── */
    --ease: 0.2s ease;
    /* ── UI Scale ── */
    --ui-scale: 1;
  }

  body {
    background: #050505;
    color: #e0e0e0;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
  }

  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: rgba(255,255,255,0.03); }
  ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 3px; }

  /* ═══════════════════════════════════════════
     GLASSMORPHISM BASE
     ═══════════════════════════════════════════ */
  .glass {
    background: rgba(28, 28, 30, 0.72);
    backdrop-filter: blur(40px) saturate(1.4);
    -webkit-backdrop-filter: blur(40px) saturate(1.4);
    border: 1px solid rgba(255, 255, 255, 0.06);
    border-radius: 14px;
    box-shadow: 0 2px 20px rgba(0, 0, 0, 0.4), inset 0 0.5px 0 rgba(255, 255, 255, 0.05);
  }

  /* UI scale — applied to all glass overlay panels */
  #category-sidebar,
  #detail-panel,
  #stats-bar,
  .settings-panel {
    transform: scale(var(--ui-scale, 1));
    transform-origin: top left;
  }
  /* Detail panel anchors from the right */
  #detail-panel { transform-origin: top right; }

  /* Resizable panels now use JavaScript-based viewport clamping */
  .resizable {
    overflow-y: auto;
    box-sizing: border-box;
  }

  /* ═══════════════════════════════════════════
     GRAPH CONTAINER
     ═══════════════════════════════════════════ */
  #graph-container {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 1;
  }

  /* ═══════════════════════════════════════════
     TOP MENU BAR (full-width unified)
     ═══════════════════════════════════════════ */
  #title-bar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 100;
    padding: 10px 18px;
    display: flex;
    align-items: center;
    gap: 12px;
    background: rgba(18, 18, 20, 0.65);
    backdrop-filter: blur(40px) saturate(1.4);
    -webkit-backdrop-filter: blur(40px) saturate(1.4);
    border-bottom: 1px solid rgba(255, 255, 255, 0.04);
    border-radius: 0;
    box-shadow: 0 1px 12px rgba(0, 0, 0, 0.3);
  }

  #title-bar .bar-left {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-shrink: 0;
  }

  #title-bar .bar-center {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 8px;
    min-width: 0;
  }

  #title-bar .bar-right {
    display: flex;
    align-items: center;
    gap: 6px;
    flex-shrink: 0;
  }

  /* Thin separator between sections */
  #title-bar .bar-sep {
    width: 1px;
    height: 20px;
    background: rgba(255, 255, 255, 0.06);
    flex-shrink: 0;
  }

  .pin-btn {
    background: var(--s-subtle);
    border: 1px solid var(--b-subtle);
    color: var(--t-muted);
    cursor: pointer;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: var(--r-circle);
    transition: all 0.2s;
    padding: 0;
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 11;
    opacity: 0;
  }
  .pin-btn svg {
    width: 14px;
    height: 14px;
    stroke: rgba(255,255,255,0.35);
    fill: none;
    stroke-width: 2;
    transition: all 0.2s;
    transform: rotate(45deg);
  }
  .resizable:hover .pin-btn { opacity: 1; }
  .pin-btn:hover {
    background: var(--s-hover);
    color: var(--t-primary);
    border-color: var(--b-light);
  }
  .pin-btn:hover svg { stroke: rgba(255,255,255,0.6); }
  .pin-btn.pinned {
    opacity: 1;
    background: var(--s-medium);
    border-color: var(--b-hover);
  }
  .pin-btn.pinned svg {
    stroke: rgba(255,255,255,0.7);
    fill: rgba(255,255,255,0.15);
    transform: rotate(0deg);
  }

  .detail-header .pin-btn {
    position: relative !important;
    top: auto !important;
    right: auto !important;
    opacity: 1 !important;
    width: 26px;
    height: 26px;
  }

  #title-bar h1 {
    font-size: 14px;
    font-weight: 600;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.65);
  }

  /* ── Pill buttons (links, type, reset) ── */
  .bar-pill {
    background: transparent;
    border: 1px solid rgba(255, 255, 255, 0.06);
    color: var(--t-muted);
    font-size: 12px;
    font-weight: 500;
    font-family: inherit;
    letter-spacing: 0.04em;
    padding: 5px 12px;
    border-radius: var(--r-pill);
    cursor: pointer;
    transition: all var(--ease);
    white-space: nowrap;
  }
  .bar-pill:hover {
    background: rgba(255, 255, 255, 0.06);
    color: var(--t-primary);
    border-color: rgba(255, 255, 255, 0.1);
  }
  .bar-pill:active {
    background: var(--s-active);
    transform: scale(0.96);
  }
  .bar-pill.active {
    background: rgba(255, 255, 255, 0.08);
    color: var(--t-primary);
    border-color: rgba(255, 255, 255, 0.1);
  }

  /* ── View toggle (2D/3D) ── */
  .view-toggle {
    display: flex;
    align-items: center;
    gap: 0;
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: var(--r-pill);
    overflow: hidden;
  }
  .view-toggle a {
    padding: 4px 10px;
    font-size: 11px;
    font-weight: 600;
    letter-spacing: 0.06em;
    color: var(--t-muted);
    text-decoration: none;
    transition: all var(--ease);
    border-right: 1px solid rgba(255,255,255,0.05);
  }
  .view-toggle a:last-child { border-right: none; }
  .view-toggle a:hover { color: var(--t-primary); background: var(--s-hover); }
  .view-toggle a.active {
    color: var(--accent-blue);
    background: var(--accent-blue-bg);
  }

  /* ── Icon-only buttons in top bar ── */
  .bar-icon {
    background: transparent;
    border: 1px solid transparent;
    color: var(--t-muted);
    width: 28px;
    height: 28px;
    border-radius: var(--r-circle);
    cursor: pointer;
    transition: all 0.15s;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    flex-shrink: 0;
    position: relative;
  }
  .bar-icon:hover {
    background: rgba(255, 255, 255, 0.06);
    color: var(--t-primary);
  }
  .bar-icon svg {
    width: 14px;
    height: 14px;
    stroke: currentColor;
    stroke-width: 2;
    fill: none;
  }
  .bar-icon .count-badge {
    position: absolute;
    top: -3px;
    right: -3px;
    font-size: 8px;
    min-width: 12px;
    height: 12px;
    padding: 0 3px;
    line-height: 12px;
  }

  /* ═══════════════════════════════════════════
     HELP BUTTON + MODAL
     (help, settings, trash now use .bar-icon class)
     ═══════════════════════════════════════════ */
  #help-btn {
    font-size: 12px;
    font-weight: 600;
  }

  #help-overlay {
    position: fixed;
    inset: 0;
    z-index: 500;
    background: rgba(0, 0, 0, 0.35);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    display: none;
    align-items: center;
    justify-content: center;
    animation: helpFadeIn 0.15s ease-out;
  }
  #help-overlay.open { display: flex; }

  @keyframes helpFadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  #help-modal {
    width: 480px;
    max-height: calc(100vh - 80px);
    overflow-y: auto;
    padding: 28px 30px;
    animation: helpSlideIn 0.2s ease-out;
  }

  @keyframes helpSlideIn {
    from { opacity: 0; transform: translateY(10px) scale(0.98); }
    to { opacity: 1; transform: translateY(0) scale(1); }
  }

  #help-modal h2 {
    font-size: 14px;
    font-weight: 600;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.55);
    margin-bottom: 20px;
  }

  .help-section {
    margin-bottom: 20px;
  }

  .help-section-title {
    font-size: 12px;
    font-weight: 600;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.3);
    margin-bottom: 10px;
    padding-bottom: 6px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.04);
  }

  .help-row {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    padding: 5px 0;
  }

  .help-keys {
    display: flex;
    gap: 4px;
    flex-shrink: 0;
  }

  .help-key {
    font-family: 'JetBrains Mono', 'JetBrains Mono', 'SF Mono', 'Consolas', monospace;
    font-size: 12px;
    font-weight: 500;
    color: rgba(255, 255, 255, 0.7);
    background: rgba(255, 255, 255, 0.06);
    border: 1px solid rgba(255, 255, 255, 0.06);
    border-radius: 5px;
    padding: 2px 8px;
    white-space: nowrap;
  }

  .help-desc {
    font-size: 13px;
    color: rgba(255, 255, 255, 0.45);
    text-align: right;
    flex: 1;
    margin-left: 16px;
  }

  #help-close {
    position: absolute;
    top: 14px;
    right: 14px;
    background: rgba(255, 255, 255, 0.06);
    border: none;
    color: rgba(255, 255, 255, 0.3);
    cursor: pointer;
    font-size: 18px;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s;
  }
  #help-close:hover {
    color: rgba(255, 255, 255, 0.7);
    background: rgba(255, 255, 255, 0.1);
  }

  /* ═══════════════════════════════════════════
     BOOKMARKS
     ═══════════════════════════════════════════ */
  /* ── Toolbar buttons (shared) ── */
  .toolbar-btn {
    background: transparent;
    border: 1px solid rgba(255, 255, 255, 0.06);
    color: var(--t-muted);
    font-size: 12px;
    font-weight: 500;
    font-family: inherit;
    letter-spacing: 0.02em;
    padding: 5px 12px;
    border-radius: var(--r-pill);
    cursor: pointer;
    transition: all var(--ease);
    white-space: nowrap;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    gap: 5px;
    position: relative;
  }
  .toolbar-btn:hover {
    background: rgba(255, 255, 255, 0.06);
    color: var(--t-primary);
    border-color: rgba(255, 255, 255, 0.1);
  }
  .toolbar-btn:active { transform: scale(0.97); }
  .toolbar-btn.active {
    background: rgba(255, 255, 255, 0.08);
    color: var(--t-primary);
    border-color: rgba(255, 255, 255, 0.1);
  }
  .toolbar-btn svg {
    width: 12px; height: 12px;
    fill: none;
    stroke: currentColor;
    stroke-width: 1.8;
  }
  /* ── Collections tab (settings modal) ── */
  .conn-list {
    display: flex;
    flex-direction: column;
    gap: 4px;
    margin-bottom: 12px;
  }
  .conn-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 10px;
    border-radius: var(--r-card);
    background: var(--s-subtle);
    border: 1px solid var(--b-subtle);
    transition: all var(--ease);
    cursor: pointer;
  }
  .conn-item:hover {
    background: var(--s-hover);
    border-color: var(--b-hover);
  }
  .conn-item.active {
    background: var(--s-medium);
    border-color: rgba(255,255,255,0.2);
  }
  .conn-item-dot {
    width: 8px;
    height: 8px;
    border-radius: var(--r-circle);
    background: var(--t-muted);
    flex-shrink: 0;
    transition: all var(--ease);
  }
  .conn-item.active .conn-item-dot {
    background: var(--t-bright);
  }
  .conn-item-info {
    flex: 1;
    min-width: 0;
  }
  .conn-item-name {
    font-size: var(--fs-sm);
    font-weight: 500;
    color: var(--t-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .conn-item.active .conn-item-name { color: var(--t-bright); }
  .conn-item-meta {
    font-size: var(--fs-xs);
    color: var(--t-muted);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-family: 'JetBrains Mono', monospace;
  }
  .conn-item.active .conn-item-meta { color: var(--t-secondary); }
  .conn-item-count {
    font-size: var(--fs-xs);
    color: var(--t-secondary);
    background: var(--s-medium);
    padding: 2px 8px;
    border-radius: var(--r-pill);
    flex-shrink: 0;
    font-family: 'JetBrains Mono', monospace;
    font-weight: 600;
  }
  .conn-item.active .conn-item-count {
    background: rgba(255,255,255,0.12);
    color: var(--t-bright);
  }
  .conn-item-delete {
    width: 22px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: none;
    border: none;
    color: var(--t-muted);
    cursor: pointer;
    border-radius: var(--r-circle);
    opacity: 0;
    transition: all var(--ease);
    flex-shrink: 0;
    padding: 0;
  }
  .conn-item:hover .conn-item-delete { opacity: 0.6; }
  .conn-item-delete:hover { opacity: 1 !important; color: var(--accent-red); background: rgba(255,82,82,0.1); }
  .conn-item-delete svg { width: 12px; height: 12px; fill: none; stroke: currentColor; stroke-width: 2; }
  .conn-item-action {
    width: 22px; height: 22px;
    display: flex; align-items: center; justify-content: center;
    background: none; border: none; color: var(--t-muted);
    cursor: pointer; border-radius: var(--r-circle);
    opacity: 0.5; transition: all var(--ease);
    flex-shrink: 0; padding: 0;
  }
  .conn-item:hover .conn-item-action { opacity: 0.8; }
  .conn-item-action:hover { opacity: 1 !important; color: var(--accent-blue); background: rgba(79,195,247,0.1); }
  .conn-item-action svg { width: 12px; height: 12px; fill: none; stroke: currentColor; stroke-width: 2; }
  .conn-item-action.restoring,
  .conn-item-action.backing-up { opacity: 0.8 !important; pointer-events: none; }
  .conn-item-action.restoring svg,
  .conn-item-action.backing-up svg {
    animation: dep-spin 0.7s linear infinite;
  }
  .conn-item.unreachable {
    opacity: 0.5;
    border-style: dashed;
  }
  .conn-item.unreachable .conn-item-dot {
    background: var(--accent-red, #ef5350);
    opacity: 0.6;
  }
  .conn-item.unreachable .conn-item-name::after {
    content: ' (offline)';
    font-size: var(--fs-xs);
    color: var(--t-muted);
    font-weight: 400;
  }
  .conn-item-start {
    width: 22px; height: 22px;
    display: flex; align-items: center; justify-content: center;
    background: none; border: none; color: var(--accent-green, #66bb6a);
    cursor: pointer; border-radius: var(--r-circle);
    opacity: 0.7; transition: all var(--ease);
    flex-shrink: 0; padding: 0;
  }
  .conn-item-start:hover {
    opacity: 1;
    background: rgba(102,187,106,0.12);
  }
  .conn-item-start svg {
    width: 12px; height: 12px; fill: none; stroke: currentColor; stroke-width: 2;
  }
  .conn-item-start:disabled {
    pointer-events: none; opacity: 0.5;
  }
  .conn-add-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    width: 100%;
    padding: 8px;
    border-radius: var(--r-card);
    background: var(--s-subtle);
    border: 1px dashed var(--b-subtle);
    color: var(--t-muted);
    font-size: var(--fs-sm);
    font-family: inherit;
    cursor: pointer;
    transition: all var(--ease);
  }
  .conn-add-btn:hover {
    background: var(--s-hover);
    border-color: var(--b-hover);
    color: var(--t-primary);
  }
  .conn-add-btn svg { width: 14px; height: 14px; fill: none; stroke: currentColor; stroke-width: 2; }
  .conn-empty {
    text-align: center;
    padding: 20px;
    color: var(--t-muted);
    font-size: var(--fs-sm);
  }

  /* ── Bridge connection item variant ── */

  /* ── Add Collection Wizard ── */
  .conn-wizard-overlay {
    position: fixed; inset: 0; z-index: 10001;
    background: rgba(0,0,0,0.65);
    backdrop-filter: blur(20px) saturate(0.8);
    -webkit-backdrop-filter: blur(20px) saturate(0.8);
    display: flex; align-items: center; justify-content: center;
    animation: tagModalFadeIn 0.15s ease-out;
  }
  .conn-wizard-panel {
    width: 520px; max-height: 85vh;
    background: rgba(18,18,22,0.88);
    backdrop-filter: blur(40px) saturate(1.4);
    -webkit-backdrop-filter: blur(40px) saturate(1.4);
    border: 1px solid rgba(255,255,255,0.07);
    border-radius: 16px;
    box-shadow: 0 2px 32px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.04);
    display: flex; flex-direction: column; overflow: hidden;
    animation: tagModalScaleIn 0.18s ease-out;
  }
  .conn-wizard-viewport {
    position: relative; overflow: hidden;
    transition: height 0.38s cubic-bezier(0.4,0,0.2,1);
  }
  .conn-wizard-step {
    position: absolute; top: 0; left: 0; right: 0;
    padding: 28px 32px;
    display: flex; flex-direction: column;
    transition: transform 0.38s cubic-bezier(0.4,0,0.2,1), opacity 0.28s ease;
    overflow-y: auto;
  }
  .conn-wizard-step.active { transform: translateX(0); opacity: 1; z-index: 2; }
  .conn-wizard-step.left   { transform: translateX(-100%); opacity: 0; z-index: 1; }
  .conn-wizard-step.right  { transform: translateX(100%); opacity: 0; z-index: 1; }
  .conn-wizard-step h3 {
    font-size: 16px; font-weight: 600; color: var(--t-bright);
    margin-bottom: 5px; letter-spacing: -0.2px;
  }
  .conn-wizard-step .wiz-subtitle {
    font-size: 12px; color: var(--t-secondary);
    margin-bottom: 22px; line-height: 1.5;
  }
  .wiz-mode-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 4px; }
  .wiz-mode-card {
    padding: 16px; border: 1px solid var(--b-light);
    border-radius: var(--r-card); background: var(--s-subtle);
    cursor: pointer; transition: all 0.22s ease; text-align: center;
  }
  .wiz-mode-card:hover { background: var(--s-hover); border-color: var(--b-hover); transform: translateY(-1px); }
  .wiz-mode-card.selected {
    border-color: var(--accent-blue-border); background: var(--accent-blue-bg);
    box-shadow: 0 0 0 1px var(--accent-blue-border);
  }
  .wiz-mode-card .wmc-icon {
    width: 28px; height: 28px; margin: 0 auto 8px; stroke: var(--t-muted);
    fill: none; stroke-width: 1.5; transition: stroke 0.2s;
  }
  .wiz-mode-card.selected .wmc-icon { stroke: var(--accent-blue); }
  .wiz-mode-card .wmc-title { font-size: 13px; font-weight: 600; color: var(--t-bright); }
  .wiz-mode-card .wmc-desc { font-size: 11px; color: var(--t-muted); margin-top: 3px; line-height: 1.4; }
  .wiz-field { margin-bottom: 14px; }
  .wiz-field label {
    display: block; font-size: 11px; font-weight: 600;
    color: var(--t-secondary); margin-bottom: 6px;
    text-transform: uppercase; letter-spacing: 0.5px;
  }
  .wiz-field input[type="text"],
  .wiz-field input[type="number"],
  .wiz-field input[type="password"] {
    width: 100%; box-sizing: border-box;
    font-size: var(--fs-sm); font-family: 'JetBrains Mono', monospace;
    padding: 8px 10px; border-radius: var(--r-small);
    background: var(--s-subtle); color: var(--t-bright);
    border: 1px solid var(--b-light); outline: none;
    transition: border-color var(--ease);
  }
  .wiz-field input:focus { border-color: var(--accent-blue-border); }
  .wiz-field .wiz-hint { font-size: 11px; color: var(--t-muted); margin-top: 4px; line-height: 1.4; }
  .wiz-field .wiz-error { font-size: 11px; color: var(--accent-red); margin-top: 4px; display: none; }
  .wiz-field .wiz-error.visible { display: block; }
  .wiz-row { display: flex; gap: 8px; }
  .wiz-row .wiz-field { flex: 1; }
  .wiz-input-row { display: flex; gap: 6px; }
  .wiz-input-row input { flex: 1; }
  .wiz-generate-btn {
    padding: 8px 12px; border-radius: var(--r-small);
    border: 1px solid var(--b-light); background: var(--s-light);
    color: var(--t-primary); font-size: 11px; font-family: inherit;
    cursor: pointer; white-space: nowrap; transition: all var(--ease); flex-shrink: 0;
  }
  .wiz-generate-btn:hover { background: var(--s-medium); color: var(--t-bright); border-color: var(--b-hover); }
  .wiz-terminal {
    background: rgba(0,0,0,0.3); border: 1px solid var(--b-subtle);
    border-radius: var(--r-small); padding: 10px 12px;
    font-family: 'JetBrains Mono', monospace; font-size: 11px;
    color: var(--t-secondary); max-height: 120px;
    overflow-y: auto; white-space: pre-wrap; word-break: break-all;
    line-height: 1.5; margin: 10px 0;
  }
  .wiz-status {
    display: flex; align-items: center; gap: 8px;
    font-size: 12px; color: var(--t-primary); margin-bottom: 8px;
  }
  .wiz-status-dot {
    width: 7px; height: 7px; border-radius: 50%; flex-shrink: 0;
  }
  .wiz-status-dot.green { background: #6dd58c; box-shadow: 0 0 6px rgba(109,213,140,0.4); }
  .wiz-status-dot.red { background: var(--accent-red); }
  .wiz-status-dot.spin {
    border: 2px solid rgba(79,195,247,0.25);
    border-top-color: var(--accent-blue);
    animation: dep-spin 0.7s linear infinite;
    width: 9px; height: 9px; background: none;
  }
  .wiz-action-btn {
    padding: 10px 20px; border-radius: var(--r-small);
    border: 1px solid var(--accent-blue-border);
    background: var(--accent-blue-bg); color: var(--accent-blue);
    font-size: 12px; font-weight: 600; font-family: inherit;
    cursor: pointer; transition: all var(--ease); width: 100%;
  }
  .wiz-action-btn:hover { background: rgba(79,195,247,0.16); border-color: rgba(79,195,247,0.35); }
  .wiz-action-btn:disabled { opacity: 0.4; pointer-events: none; }
  .wiz-summary-card {
    border: 1px solid var(--b-light); border-radius: var(--r-card);
    background: var(--s-subtle); padding: 16px 18px; margin-bottom: 16px;
  }
  .wiz-summary-row {
    display: flex; justify-content: space-between; align-items: center;
    padding: 6px 0; font-size: 12px;
  }
  .wiz-summary-row + .wiz-summary-row { border-top: 1px solid var(--b-subtle); }
  .wiz-summary-row .wsr-label { color: var(--t-muted); }
  .wiz-summary-row .wsr-value { color: var(--t-bright); font-family: 'JetBrains Mono', monospace; font-size: 11px; }
  .conn-wizard-nav {
    padding: 12px 20px; display: flex; align-items: center;
    justify-content: space-between;
    border-top: 1px solid rgba(255,255,255,0.05);
    background: rgba(0,0,0,0.2); flex-shrink: 0;
  }
  .wiz-dots { display: flex; gap: 3px; }
  .wiz-dot {
    width: 14px; height: 3px; border-radius: 1px;
    background: rgba(255,255,255,0.08); transition: all 0.3s ease;
  }
  .wiz-dot.active { background: var(--accent-blue); box-shadow: 0 0 6px rgba(79,195,247,0.4); }
  .wiz-dot.done { background: rgba(79,195,247,0.25); }
  .wiz-nav-btn {
    padding: 6px 14px; border-radius: var(--r-small);
    border: 1px solid var(--b-subtle); background: var(--s-subtle);
    color: var(--t-muted); font-size: 11px; font-family: inherit;
    cursor: pointer; transition: all var(--ease); letter-spacing: 0.04em;
  }
  .wiz-nav-btn:hover { color: var(--t-bright); background: var(--s-hover); border-color: var(--b-hover); }
  .wiz-nav-btn:disabled { opacity: 0; pointer-events: none; }
  .wiz-nav-btn.primary {
    background: var(--accent-blue-bg); border-color: var(--accent-blue-border);
    color: var(--accent-blue);
  }
  .wiz-nav-btn.primary:hover { background: rgba(79,195,247,0.16); border-color: rgba(79,195,247,0.35); }
  .wiz-nav-btn.primary:disabled { opacity: 0.4; pointer-events: none; }

  /* ── Claude Code integration ── */
  .cc-integration-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 12px;
    border-radius: var(--r-small);
    background: transparent;
    border: 1px solid transparent;
    transition: all var(--ease);
  }
  .cc-integration-item + .cc-integration-item { margin-top: 6px; }
  .cc-integration-item:hover { background: var(--s-subtle); }
  .cc-integration-item.enabled {
    background: rgba(255,255,255,0.06);
    border-color: rgba(255,255,255,0.12);
  }
  .cc-integration-info { flex: 1; min-width: 0; }
  .cc-integration-label {
    font-size: var(--fs-sm);
    font-weight: 500;
    color: var(--t-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .cc-integration-item.enabled .cc-integration-label { color: var(--t-bright); }
  .cc-integration-path {
    font-size: 11px;
    color: var(--t-muted);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .cc-toggle {
    position: relative;
    width: 36px;
    height: 20px;
    background: rgba(255,255,255,0.06);
    border: 1px solid var(--b-subtle);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.25s ease;
    flex-shrink: 0;
    padding: 0;
  }
  .cc-toggle::after {
    content: '';
    position: absolute;
    top: 2px;
    left: 2px;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--t-muted);
    transition: all 0.25s ease;
  }
  .cc-toggle.on {
    background: rgba(255,255,255,0.14);
    border-color: rgba(255,255,255,0.22);
  }
  .cc-toggle.on::after {
    left: 18px;
    background: rgba(255,255,255,0.85);
    box-shadow: 0 0 4px rgba(255,255,255,0.15);
  }
  .cc-skill-row {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 12px;
    border-radius: var(--r-small);
    background: transparent;
    border: 1px solid transparent;
    transition: all var(--ease);
  }
  .cc-skill-row + .cc-skill-row { margin-top: 6px; }
  .cc-skill-row:hover { background: var(--s-subtle); }
  .cc-skill-row.installed {
    background: rgba(255,255,255,0.06);
    border-color: rgba(255,255,255,0.12);
  }
  .cc-skill-info { flex: 1; min-width: 0; display: flex; align-items: baseline; gap: 8px; }
  .cc-skill-name {
    font-size: var(--fs-sm);
    font-weight: 500;
    color: var(--t-secondary);
    white-space: nowrap;
  }
  .cc-skill-row.installed .cc-skill-name { color: var(--t-bright); }
  .cc-skill-desc {
    font-size: 11px;
    color: var(--t-muted);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .cc-toast {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--s-dark);
    border: 1px solid var(--s-medium);
    color: var(--text);
    padding: 10px 20px;
    border-radius: 8px;
    font-size: 13px;
    z-index: 100000;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
  }
  .cc-toast.show { opacity: 1; }
  .cc-remove-btn {
    width: 22px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: none;
    border: none;
    color: var(--t-muted);
    cursor: pointer;
    border-radius: var(--r-circle);
    opacity: 0;
    transition: all var(--ease);
    flex-shrink: 0;
    padding: 0;
  }
  .cc-integration-item:hover .cc-remove-btn { opacity: 0.6; }
  .cc-remove-btn:hover { opacity: 1 !important; color: var(--accent-red); background: rgba(255,82,82,0.1); }
  .cc-remove-btn svg { width: 12px; height: 12px; fill: none; stroke: currentColor; stroke-width: 2; }
  .cc-section-label {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 1.2px;
    font-weight: 700;
    color: var(--t-faint);
    margin-top: 20px;
    margin-bottom: 8px;
    padding-bottom: 5px;
    border-bottom: 1px solid rgba(255,255,255,0.04);
  }
  .cc-section-label:first-child { margin-top: 0; }
  .cc-hint {
    font-size: 11px;
    color: var(--t-faint);
    margin-top: 4px;
    line-height: 1.45;
  }

  /* Collapsible connection panels */
  .cc-panel {
    border: 1px solid var(--b-light);
    border-radius: var(--r-card);
    background: rgba(255,255,255,0.02);
    overflow: hidden;
    transition: border-color 0.2s, background 0.2s;
  }
  .cc-panel + .cc-panel { margin-top: 6px; }
  .cc-panel.enabled {
    border-color: rgba(255,255,255,0.14);
    background: rgba(255,255,255,0.03);
  }
  .cc-panel-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    cursor: pointer;
    user-select: none;
    transition: background 0.15s;
  }
  .cc-panel-header:hover { background: rgba(255,255,255,0.03); }
  .cc-panel-chevron {
    width: 12px;
    height: 12px;
    flex-shrink: 0;
    fill: none;
    stroke: var(--t-muted);
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
    transition: transform 0.2s;
  }
  .cc-panel.open .cc-panel-chevron { transform: rotate(90deg); }
  .cc-panel-title {
    flex: 1;
    min-width: 0;
    font-size: var(--fs-sm);
    font-weight: 600;
    color: var(--t-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .cc-panel.enabled .cc-panel-title { color: var(--t-bright); }
  .cc-panel-status {
    font-size: 11px;
    padding: 2px 8px;
    border-radius: var(--r-pill);
    font-weight: 600;
    letter-spacing: 0.3px;
    flex-shrink: 0;
  }
  .cc-panel-status.active {
    background: rgba(255,255,255,0.08);
    color: var(--t-bright);
  }
  .cc-panel-status.inactive {
    background: rgba(255,255,255,0.04);
    color: var(--t-muted);
  }
  .cc-panel-body {
    display: none;
    padding: 4px 14px 16px;
  }
  .cc-panel.open .cc-panel-body { display: block; }
  .cc-panel-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 0;
  }
  .cc-panel-row + .cc-panel-row {
    border-top: 1px solid rgba(255,255,255,0.03);
  }
  .cc-panel-row-label {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.6px;
    color: var(--t-muted);
    font-weight: 600;
  }
  .cc-panel-row-value {
    font-size: var(--fs-xs);
    color: var(--t-secondary);
    font-family: 'JetBrains Mono', monospace;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 60%;
    text-align: right;
  }
  .cc-panel-actions {
    display: flex;
    align-items: center;
    gap: 6px;
    padding-top: 8px;
    margin-top: 4px;
    border-top: 1px solid var(--b-subtle);
  }
  .cc-panel-actions button {
    flex: 1;
    padding: 5px 0;
    font-size: var(--fs-xs);
    font-weight: 500;
    font-family: inherit;
    border-radius: var(--r-small);
    cursor: pointer;
    transition: background 0.15s, border-color 0.15s;
  }
  .cc-panel-actions .cc-enable-btn {
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.12);
    color: var(--t-primary);
  }
  .cc-panel-actions .cc-enable-btn:hover {
    background: rgba(255,255,255,0.1);
  }
  .cc-panel-actions .cc-enable-btn.on {
    background: rgba(255,255,255,0.10);
    border-color: rgba(255,255,255,0.20);
    color: var(--t-bright);
  }
  .cc-panel-actions .cc-disable-btn {
    background: rgba(255,82,82,0.08);
    border: 1px solid rgba(255,82,82,0.2);
    color: var(--accent-red);
  }
  .cc-panel-actions .cc-disable-btn:hover {
    background: rgba(255,82,82,0.15);
  }
  .cc-panel-actions .cc-remove-panel-btn {
    background: none;
    border: 1px solid var(--b-subtle);
    color: var(--t-muted);
  }
  .cc-panel-actions .cc-remove-panel-btn:hover {
    color: var(--accent-red);
    border-color: rgba(255,82,82,0.3);
    background: rgba(255,82,82,0.08);
  }

  .toolbar-btn svg {
    width: 14px; height: 14px;
    fill: none;
    stroke: currentColor;
    stroke-width: 1.8;
    stroke-linejoin: round;
    flex-shrink: 0;
  }

  /* ── Count badges (shared) ── */
  .count-badge {
    font-size: var(--fs-xs);
    font-weight: 600;
    padding: 1px 6px;
    border-radius: var(--r-pill);
    min-width: 16px;
    text-align: center;
    line-height: 1.5;
  }
  .count-badge:empty { display: none; }
  .count-badge--gold {
    background: var(--accent-gold-bg);
    color: var(--accent-gold);
  }
  .count-badge--blue {
    background: var(--accent-blue-bg);
    color: var(--accent-blue);
  }
  .count-badge--muted {
    background: var(--s-light);
    color: var(--t-secondary);
  }
  .count-badge--red {
    background: var(--accent-red-bg);
    color: var(--accent-red);
  }

  /* ── Dropdown panels (shared) ── */
  .dropdown-panel {
    position: absolute;
    top: 100%;
    right: 0;
    margin-top: 16px;
    z-index: 101;
    width: 340px;
    padding: 12px;
    display: none;
    animation: dropdownFadeIn 0.15s ease-out;
  }
  .dropdown-panel.open { display: block; }
  @keyframes dropdownFadeIn {
    from { opacity: 0; transform: translateY(-6px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .dropdown-empty {
    text-align: center;
    color: var(--t-faint);
    font-size: var(--fs-md);
    padding: 20px 10px;
    line-height: 1.7;
  }

  /* ── Dropdown list items (shared) ── */
  .dropdown-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 10px;
    border-radius: var(--r-card);
    cursor: pointer;
    transition: background 0.15s;
  }
  .dropdown-item:hover { background: var(--s-hover); }
  .dropdown-item-dot {
    width: 8px; height: 8px;
    border-radius: var(--r-circle);
    flex-shrink: 0;
  }
  .dropdown-item-text {
    flex: 1;
    min-width: 0;
  }
  .dropdown-item-title {
    font-size: var(--fs-md);
    font-weight: 500;
    color: var(--t-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .dropdown-item:hover .dropdown-item-title { color: var(--t-primary); }
  .dropdown-item-sub {
    font-size: var(--fs-xs);
    color: var(--t-faint);
    text-transform: uppercase;
    letter-spacing: 0.4px;
    margin-top: 1px;
  }

  /* ── Trash window (floating panel like settings) ── */
  .trash-window {
    position: fixed;
    z-index: 300;
    width: 560px;
    max-width: 92vw;
    min-width: 360px;
    min-height: 340px;
    max-height: 80vh;
    animation: tagModalScaleIn 0.15s ease-out;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    border: 1px solid rgba(255,255,255,0.10);
  }
  .trash-window.dragging { transition: none; }
  .trash-window-header {
    display: flex !important;
    align-items: center !important;
    justify-content: flex-start !important;
    padding: 12px 14px !important;
    margin: 0 !important;
    border-bottom: 1px solid var(--b-subtle);
    gap: 10px;
    flex-shrink: 0;
    min-height: 44px;
    box-sizing: border-box;
  }
  .trash-window-header h3 {
    flex: 1;
    font-size: 13px;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    font-weight: 500;
    color: rgba(255,255,255,0.45);
    margin: 0;
    pointer-events: none;
    line-height: 1;
  }
  .trash-window-header h3 .tw-h-count {
    font-size: 10px;
    letter-spacing: 0.05em;
    color: var(--t-muted);
    margin-left: 6px;
    font-weight: 400;
  }
  .trash-window-header .pin-btn {
    position: relative !important;
    top: auto !important;
    right: auto !important;
    opacity: 1 !important;
    flex-shrink: 0;
  }
  .trash-window-close {
    width: 26px; height: 26px;
    display: flex; align-items: center; justify-content: center;
    background: transparent; border: none;
    color: var(--t-muted); cursor: pointer;
    border-radius: var(--r-circle);
    font-size: 18px; line-height: 1;
    transition: all var(--ease);
    padding: 0; flex-shrink: 0;
  }
  .trash-window-close:hover { color: var(--t-bright); background: var(--s-hover); }
  .trash-window.locked .trash-window-header { cursor: default; }
  .trash-window-body {
    display: flex;
    flex: 1;
    overflow: hidden;
    min-height: 0;
  }
  .trash-list-pane {
    width: 220px;
    flex-shrink: 0;
    border-right: 1px solid var(--b-subtle);
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  .trash-list-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 10px;
    border-bottom: 1px solid var(--b-subtle);
    flex-shrink: 0;
  }
  .trash-list-header span {
    font-size: var(--fs-xs);
    color: var(--t-muted);
    font-weight: 500;
  }
  .trash-purge-btn {
    font-size: 10px;
    padding: 2px 8px;
    border-radius: var(--r-small);
    border: 1px solid rgba(180,70,70,0.25);
    background: rgba(140,50,50,0.18);
    color: rgba(220,130,130,0.85);
    cursor: pointer;
    font-family: inherit;
    font-weight: 500;
    transition: all var(--ease);
  }
  .trash-purge-btn:hover { background: rgba(140,50,50,0.30); color: rgba(230,150,150,0.95); }
  .trash-list-scroll {
    flex: 1;
    overflow-y: auto;
  }
  .trash-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 7px 10px;
    border-bottom: 1px solid var(--b-subtle);
    cursor: pointer;
    transition: background var(--ease);
  }
  .trash-item:hover { background: var(--s-hover); }
  .trash-item:last-child { border-bottom: none; }
  .trash-item.active { background: var(--s-active); }
  .trash-item-content {
    flex: 1;
    min-width: 0;
  }
  .trash-item-preview {
    font-size: var(--fs-xs);
    color: var(--t-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    line-height: 1.35;
  }
  .trash-item-meta {
    font-size: 10px;
    color: var(--t-muted);
    margin-top: 1px;
  }
  .trash-detail-pane {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    min-width: 0;
  }
  .trash-detail-header {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 14px;
    border-bottom: 1px solid var(--b-subtle);
    flex-shrink: 0;
  }
  .trash-detail-cat {
    font-size: var(--fs-xs);
    color: var(--t-muted);
    font-weight: 500;
    flex: 1;
  }
  .trash-detail-actions { display: flex; gap: 4px; }
  .trash-detail-actions button {
    font-size: var(--fs-xs);
    font-family: inherit;
    font-weight: 500;
    padding: 4px 10px;
    border-radius: var(--r-small);
    cursor: pointer;
    transition: all var(--ease);
    border: 1px solid var(--b-subtle);
    background: var(--s-subtle);
    color: var(--t-secondary);
  }
  .trash-detail-actions .trash-restore-btn:hover {
    background: rgba(70,140,170,0.15);
    border-color: rgba(70,140,170,0.30);
    color: rgba(160,200,220,0.90);
  }
  .trash-detail-actions .trash-delete-btn:hover {
    background: rgba(140,50,50,0.18);
    border-color: rgba(180,70,70,0.25);
    color: rgba(220,130,130,0.85);
  }
  .trash-detail-body {
    flex: 1;
    overflow-y: auto;
    padding: 16px 18px;
    font-size: 13px;
    color: rgba(255,255,255,0.7);
    line-height: 1.7;
    font-family: 'JetBrains Mono', 'SF Mono', 'Consolas', monospace;
    word-break: break-word;
  }
  .trash-detail-empty {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--t-muted);
    font-size: var(--fs-sm);
  }
  .trash-empty-msg {
    text-align: center;
    padding: 24px 14px;
    color: var(--t-muted);
    font-size: var(--fs-sm);
  }

  /* ── Icon buttons (shared) ── circular action buttons in panels ── */
  .icon-btn {
    width: 28px; height: 28px;
    border-radius: var(--r-circle);
    background: var(--s-subtle);
    border: 1px solid var(--b-subtle);
    color: var(--t-muted);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all var(--ease);
    flex-shrink: 0;
    font-size: var(--fs-lg);
    line-height: 1;
    padding: 0;
  }
  .icon-btn:hover {
    background: var(--s-hover);
    color: var(--t-primary);
    border-color: var(--b-light);
  }
  .icon-btn svg {
    width: 14px; height: 14px;
    stroke: currentColor;
    stroke-width: 1.8;
    fill: none;
    transition: fill var(--ease), stroke var(--ease);
  }
  .icon-btn--danger:hover {
    background: var(--accent-red-bg);
    color: var(--accent-red);
    border-color: rgba(255,82,82,0.2);
  }
  .icon-btn--gold:hover {
    background: var(--accent-gold-bg);
    color: var(--accent-gold);
    border-color: var(--accent-gold-border);
  }
  .icon-btn--gold.active {
    background: var(--accent-gold-bg);
    color: var(--accent-gold);
    border-color: var(--accent-gold-border);
  }
  .icon-btn--gold.active svg.filled { fill: currentColor; }

  /* ── Action buttons (shared) ── solid clickable actions ── */
  .action-btn {
    font-size: var(--fs-md);
    font-weight: 500;
    font-family: inherit;
    padding: 6px 14px;
    border-radius: var(--r-small);
    border: 1px solid var(--b-subtle);
    cursor: pointer;
    transition: all var(--ease);
    white-space: nowrap;
  }
  .action-btn--primary {
    background: var(--s-medium);
    color: var(--t-primary);
  }
  .action-btn--primary:hover {
    background: var(--s-active);
    color: var(--t-bright);
  }
  .action-btn--primary:disabled {
    opacity: 0.3;
    cursor: not-allowed;
  }
  .action-btn--ghost {
    background: var(--s-transparent);
    color: var(--t-muted);
    border-color: transparent;
  }
  .action-btn--ghost:hover {
    background: var(--s-hover);
    color: var(--t-primary);
  }
  .action-btn--danger {
    background: var(--accent-red-bg);
    color: var(--accent-red);
    border-color: rgba(255,82,82,0.12);
  }
  .action-btn--danger:hover {
    background: var(--accent-red-hover);
  }

  /* ── Pill badges (shared) ── small info pills ── */
  .pill-badge {
    font-size: var(--fs-xs);
    font-weight: 500;
    padding: 2px 8px;
    border-radius: var(--r-pill);
    background: var(--s-subtle);
    color: var(--t-muted);
    line-height: 1.5;
  }
  .pill-badge--blue {
    background: var(--accent-blue-bg);
    color: rgba(100,180,255,0.6);
  }

  /* ═══════════════════════════════════════════
     LAYOUTS PANEL
     ═══════════════════════════════════════════ */
  /* layouts-btn and layouts-panel now use shared .toolbar-btn and .dropdown-panel */

  .preset-save-bar {
    display: flex;
    gap: 6px;
    margin-bottom: 10px;
  }
  .preset-save-bar input {
    flex: 1;
    background: var(--s-subtle);
    border: 1px solid var(--b-subtle);
    border-radius: var(--r-small);
    padding: 6px 10px;
    color: var(--t-bright);
    font-size: var(--fs-md);
    font-family: inherit;
    outline: none;
    transition: border-color var(--ease);
  }
  .preset-save-bar input::placeholder {
    color: var(--t-faint);
  }
  .preset-save-bar input:focus {
    border-color: var(--b-hover);
  }
  .preset-save-bar button {
    background: var(--s-medium);
    border: 1px solid var(--b-subtle);
    color: var(--t-secondary);
    font-size: var(--fs-md);
    font-weight: 500;
    font-family: inherit;
    padding: 6px 12px;
    border-radius: var(--r-small);
    cursor: pointer;
    transition: all var(--ease);
    white-space: nowrap;
  }
  .preset-save-bar button:hover {
    background: var(--s-active);
    color: var(--t-bright);
    border-color: var(--b-hover);
  }

  .preset-list {
    max-height: 240px;
    overflow-y: auto;
  }

  .preset-row {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 7px 10px;
    border-radius: var(--r-card);
    cursor: pointer;
    transition: background 0.15s;
    position: relative;
  }
  .preset-row:hover { background: var(--s-hover); }
  .preset-row.active { background: var(--s-medium); }

  .preset-name {
    flex: 1;
    font-size: var(--fs-md);
    color: var(--t-secondary);
    font-weight: 500;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .preset-row:hover .preset-name { color: var(--t-primary); }
  .preset-row.active .preset-name { color: var(--t-bright); }

  .preset-badge {
    font-size: var(--fs-xs);
    font-weight: 500;
    color: var(--t-muted);
    background: var(--s-subtle);
    padding: 2px 8px;
    border-radius: var(--r-pill);
    flex-shrink: 0;
  }

  .preset-date {
    font-size: var(--fs-xs);
    color: var(--t-faint);
    flex-shrink: 0;
  }

  .preset-delete {
    background: none;
    border: none;
    color: var(--t-faint);
    font-size: var(--fs-lg);
    cursor: pointer;
    padding: 0 2px;
    line-height: 1;
    opacity: 0;
    transition: all 0.15s;
    flex-shrink: 0;
  }
  .preset-row:hover .preset-delete { opacity: 1; }
  .preset-delete:hover { color: var(--accent-red); }

  .preset-empty {
    text-align: center;
    padding: 18px 8px;
    font-size: var(--fs-md);
    color: var(--t-faint);
    letter-spacing: 0.02em;
    line-height: 1.7;
  }

  .preset-divider {
    height: 1px;
    background: rgba(255,255,255,0.06);
    margin: 6px 0;
  }
  .preset-row.builtin .preset-name {
    color: rgba(255,255,255,0.5);
    font-style: italic;
  }
  .preset-row.builtin.active .preset-name {
    color: rgba(255,255,255,0.85);
  }
  .preset-row.builtin .preset-badge {
    background: var(--accent-blue-bg);
    color: rgba(100,180,255,0.6);
    font-size: var(--fs-xs);
  }
  .preset-warning {
    font-size: 12px;
    color: rgba(255, 180, 0, 0.6);
    padding: 4px 0 2px;
    text-align: center;
    display: none;
  }
  .preset-warning.visible { display: block; }

  .status-dot {
    width: 10px; height: 10px;
    border-radius: 50%;
    background: #555;
    transition: background 0.5s;
  }
  .status-dot.connected { background: #64FFDA; box-shadow: 0 0 8px #64FFDA; }
  .status-dot.error { background: #FF5252; box-shadow: 0 0 8px #FF5252; }

  /* ═══════════════════════════════════════════
     SEARCH BAR (inline in top bar)
     ═══════════════════════════════════════════ */
  #search-container {
    display: contents;
  }

  #search-wrapper {
    position: relative;
    width: 340px;
    max-width: 40vw;
    border-radius: 8px;
    padding: 1px;
    background: rgba(255,255,255,0.06);
    transition: all 0.3s;
  }

  #search-wrapper.focused {
    background: conic-gradient(from var(--search-angle, 0deg),
      rgba(255,255,255,0.2), rgba(255,255,255,0.06), rgba(255,255,255,0.15), rgba(255,255,255,0.04), rgba(255,255,255,0.2));
    animation: rotateGradient 4s linear infinite;
  }

  @property --search-angle {
    syntax: '<angle>';
    initial-value: 0deg;
    inherits: false;
  }

  @keyframes rotateGradient {
    to { --search-angle: 360deg; }
  }

  #search-input {
    width: 100%;
    padding: 6px 36px 6px 12px;
    background: rgba(28, 28, 30, 0.7);
    border: none;
    border-radius: 7px;
    color: rgba(255, 255, 255, 0.9);
    font-size: 12px;
    font-weight: 400;
    outline: none;
    letter-spacing: 0.01em;
  }

  #search-input::placeholder {
    color: rgba(255,255,255,0.2);
    letter-spacing: 0.04em;
    font-weight: 400;
  }

  #search-badge {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    background: var(--s-medium);
    color: var(--t-primary);
    font-size: 9px;
    font-weight: 600;
    padding: 1px 6px;
    border-radius: var(--r-pill);
    opacity: 0;
    transition: opacity 0.3s;
  }
  #search-badge.visible { opacity: 1; }

  #search-clear {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: var(--t-muted);
    cursor: pointer;
    font-size: 14px;
    display: none;
    padding: 2px 6px;
    transition: color 0.15s;
  }
  #search-clear:hover { color: var(--t-bright); }

  /* ═══════════════════════════════════════════
     RESIZE HANDLES
     ═══════════════════════════════════════════ */
  .resize-handle {
    position: absolute;
    z-index: 10;
    opacity: 0;
    transition: opacity 0.2s;
  }
  .resizable:hover .resize-handle,
  .resize-handle.active { opacity: 1; }

  .resize-handle-r   { right: 0; top: 0; width: 6px; height: 100%; cursor: ew-resize; }
  .resize-handle-l   { left: 0; top: 0; width: 6px; height: 100%; cursor: ew-resize; }
  .resize-handle-b   { bottom: 0; left: 0; height: 6px; width: 100%; cursor: ns-resize; }
  .resize-handle-t   { top: 0; left: 0; height: 6px; width: 100%; cursor: ns-resize; }
  .resize-handle-br  { right: 0; bottom: 0; width: 14px; height: 14px; cursor: nwse-resize; }
  .resize-handle-bl  { left: 0; bottom: 0; width: 14px; height: 14px; cursor: nesw-resize; }
  .resize-handle-tr  { right: 0; top: 0; width: 14px; height: 14px; cursor: nesw-resize; }
  .resize-handle-tl  { left: 0; top: 0; width: 14px; height: 14px; cursor: nwse-resize; }

  /* Drag handle (top bar of panels) */
  .drag-handle {
    position: relative;
    z-index: 20;
    cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' viewBox='0 0 22 22'%3E%3Cpath d='M11 2l3 3.5h-2v4.5h4.5V8L20 11l-3.5 3v-2H12v4.5h2L11 20l-3-3.5h2v-4.5H5.5V14L2 11l3.5-3v2H10V5.5H8z' fill='rgba(255,255,255,0.65)' stroke='rgba(0,0,0,0.35)' stroke-width='0.6'/%3E%3C/svg%3E") 11 11, move;
    padding: 6px 0 4px 0;
    margin: -4px 0 6px 0;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .locked > .drag-handle .drag-grip { pointer-events: none; }
  .locked .drag-handle { cursor: default; }
  .locked .resize-handle { display: none; }
  .drag-handle:active {
    cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' viewBox='0 0 22 22'%3E%3Cpath d='M11 2l3 3.5h-2v4.5h4.5V8L20 11l-3.5 3v-2H12v4.5h2L11 20l-3-3.5h2v-4.5H5.5V14L2 11l3.5-3v2H10V5.5H8z' fill='%234FC3F7' stroke='rgba(0,0,0,0.35)' stroke-width='0.6'/%3E%3C/svg%3E") 11 11, move;
  }
  .drag-handle .drag-grip {
    width: 32px;
    height: 4px;
    border-radius: 2px;
    background: rgba(255,255,255,0.08);
    transition: background 0.2s;
  }
  .resizable:hover .drag-grip { background: rgba(255,255,255,0.14); }

  .dragging { transition: none !important; }

  /* Offset top resize handles below the drag handle area per panel */
  #category-sidebar > .resize-handle-t,
  #category-sidebar > .resize-handle-tl,
  #category-sidebar > .resize-handle-tr  { top: 56px; }
  #detail-panel > .resize-handle-t,
  #detail-panel > .resize-handle-tl,
  #detail-panel > .resize-handle-tr      { top: 56px; }
  .trash-window > .resize-handle-t,
  .trash-window > .resize-handle-tl,
  .trash-window > .resize-handle-tr      { top: 44px; }
  .settings-panel > .resize-handle-t,
  .settings-panel > .resize-handle-tl,
  .settings-panel > .resize-handle-tr    { top: 40px; }

  /* ═══════════════════════════════════════════
     CATEGORY SIDEBAR (left)
     ═══════════════════════════════════════════ */
  #category-sidebar {
    position: fixed;
    top: 52px;
    left: 20px;
    z-index: 100;
    padding: 0;
    max-height: calc(100vh - 80px);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    width: 220px;
    min-width: 160px;
    min-height: 100px;
  }
  #category-sidebar-body {
    flex: 1;
    overflow-y: auto;
    padding: 0 14px 14px;
    min-height: 0;
  }

  /* ── Sidebar header (matches detail-panel pattern) ── */
  .sidebar-header {
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
  }
  .sidebar-header-actions {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 4px;
    padding: 8px 4px 0;
  }
  .sidebar-header-title {
    font-size: var(--fs-md);
    font-weight: 600;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--t-primary);
    padding: 8px 8px 10px;
    border-bottom: 1px solid var(--b-subtle);
    margin-bottom: 10px;
    pointer-events: none;
  }
  .sidebar-header .pin-btn {
    position: relative !important;
    top: auto !important;
    right: auto !important;
    opacity: 1 !important;
    width: 26px;
    height: 26px;
  }
  #sidebar-label-controls {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 0 4px;
    margin-bottom: 10px;
  }

  .category-chip {
    display: flex;
    align-items: center;
    gap: 11px;
    padding: 8px 10px;
    border-radius: 8px;
    cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='80' height='22' viewBox='0 0 80 22'%3E%3Cpath d='M11 2l3 3.5h-2v4.5h4.5V8L20 11l-3.5 3v-2H12v4.5h2L11 20l-3-3.5h2v-4.5H5.5V14L2 11l3.5-3v2H10V5.5H8z' fill='rgba(255,255,255,0.65)' stroke='rgba(0,0,0,0.35)' stroke-width='0.6'/%3E%3Ctext x='23' y='15' font-size='11' font-family='system-ui,sans-serif' font-weight='500' fill='rgba(255,255,255,0.55)' stroke='rgba(0,0,0,0.4)' stroke-width='0.3' paint-order='stroke'%3Edrag me%3C/text%3E%3C/svg%3E") 11 11, move;
    transition: all 0.2s ease;
    margin-bottom: 2px;
    user-select: none;
  }
  .category-chip * { cursor: inherit; }
  .category-chip .category-dot,
  .category-chip .category-delete,
  .category-chip .cat-edit-icon { cursor: pointer; }

  .category-chip:hover { background: rgba(255,255,255,0.05); }
  .category-chip.inactive { opacity: 0.25; }
  .category-chip.drag-source {
    opacity: 0 !important;
    pointer-events: none;
    transition: opacity 0.1s ease !important;
  }

  /* ── Drag & Drop: Floating clone ── */
  .cat-drag-clone {
    position: fixed;
    z-index: 99999;
    pointer-events: none;
    border-radius: 8px;
    opacity: 0.97;
    will-change: transform;
    background: rgba(30, 30, 34, 0.98);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    box-shadow:
      0 20px 40px rgba(0,0,0,0.4),
      0 8px 16px rgba(0,0,0,0.25),
      0 0 0 1px rgba(255,255,255,0.06),
      0 0 32px rgba(79, 195, 247, 0.05);
  }

  /* ── Drag & Drop: Animated gap ── */
  #category-list.cat-dragging .category-chip,
  #category-list.cat-dragging .category-cluster-header,
  #category-list.cat-dragging .cluster-empty-hint {
    transition: margin 0.25s cubic-bezier(0.2, 0, 0, 1),
                opacity 0.15s ease;
  }
  #category-list.cat-dragging .drag-source {
    transition: opacity 0.1s ease !important;
  }
  .drag-gap-before {
    margin-top: var(--drag-gap, 36px) !important;
  }
  .drag-gap-after {
    margin-bottom: var(--drag-gap, 36px) !important;
  }

  /* ── Drag & Drop: Settle animation ── */
  @keyframes cat-drop-settle {
    0% { transform: scale(0.96); opacity: 0.5; }
    60% { transform: scale(1.02); }
    100% { transform: scale(1); opacity: 1; }
  }
  .category-chip.just-dropped,
  .category-cluster-header.just-dropped {
    animation: cat-drop-settle 0.25s cubic-bezier(0.22, 1, 0.36, 1);
  }

  .category-dot {
    width: 12px; height: 12px;
    border-radius: 50%;
    flex-shrink: 0;
    box-shadow: 0 0 4px currentColor;
    transition: transform 0.15s, box-shadow 0.15s;
  }
  .category-dot:hover {
    transform: scale(1.4);
    box-shadow: 0 0 8px currentColor;
  }

  /* Cluster headers */
  .category-cluster-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px 10px 6px 10px;
    margin-top: 16px;
    margin-bottom: 4px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: rgba(255,255,255,0.5);
    border-left-width: 3px;
    border-left-style: solid;
    padding-left: 12px;
  }
  .category-cluster-header:first-child {
    margin-top: 0;
  }
  .category-cluster-header.inactive {
    opacity: 0.25;
  }
  .category-cluster-header {
    cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='80' height='22' viewBox='0 0 80 22'%3E%3Cpath d='M11 2l3 3.5h-2v4.5h4.5V8L20 11l-3.5 3v-2H12v4.5h2L11 20l-3-3.5h2v-4.5H5.5V14L2 11l3.5-3v2H10V5.5H8z' fill='rgba(255,255,255,0.65)' stroke='rgba(0,0,0,0.35)' stroke-width='0.6'/%3E%3Ctext x='23' y='15' font-size='11' font-family='system-ui,sans-serif' font-weight='500' fill='rgba(255,255,255,0.55)' stroke='rgba(0,0,0,0.4)' stroke-width='0.3' paint-order='stroke'%3Edrag me%3C/text%3E%3C/svg%3E") 11 11, move;
  }
  .category-cluster-header * { cursor: inherit; }
  .category-cluster-header .cluster-dot,
  .category-cluster-header .cluster-edit-btn,
  .category-cluster-header .cluster-delete-btn { cursor: pointer; }
  .category-cluster-header.drag-source {
    opacity: 0 !important;
    pointer-events: none;
    transition: opacity 0.1s ease !important;
  }
  .category-cluster-header.drag-over-cluster {
    background: rgba(79, 195, 247, 0.08) !important;
    box-shadow: inset 0 0 0 1.5px rgba(79, 195, 247, 0.25);
    border-radius: 6px;
    transition: all 0.2s cubic-bezier(0.2, 0, 0, 1);
  }
  .cluster-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
    cursor: pointer;
    transition: transform 0.15s;
  }
  .cluster-dot:hover {
    transform: scale(1.3);
  }
  .cluster-name {
    flex: 1;
  }
  .cluster-actions {
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.2s;
  }
  .category-cluster-header:hover .cluster-actions {
    opacity: 1;
  }
  .cluster-edit-btn,
  .cluster-delete-btn {
    background: rgba(255,255,255,0.1);
    border: none;
    color: rgba(255,255,255,0.6);
    width: 20px;
    height: 20px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
  }
  .cluster-edit-btn:hover {
    background: rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.9);
  }
  .cluster-delete-btn:hover {
    background: rgba(220,38,38,0.2);
    color: rgb(239,68,68);
  }
  .cluster-empty-hint {
    margin-left: 20px;
    padding: 6px 12px;
    font-size: 10px;
    color: rgba(255,255,255,0.25);
    font-style: italic;
    border: 1px dashed rgba(255,255,255,0.1);
    border-radius: 4px;
    text-align: center;
    margin-bottom: 4px;
  }
  .drag-over-cluster {
    background: rgba(79, 195, 247, 0.08) !important;
    box-shadow: inset 0 0 0 1.5px rgba(79, 195, 247, 0.25);
    border-radius: 6px;
    transition: all 0.2s cubic-bezier(0.2, 0, 0, 1);
  }

  /* Child categories (indented) */
  .category-chip-child {
    margin-left: 20px;
    opacity: 0.95;
  }

  .color-edit-picker {
    padding: 8px 10px;
    margin: 2px 0 4px;
    background: rgba(30, 30, 34, 0.95);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 10px;
    animation: colorPickerIn 0.12s ease-out;
  }
  @keyframes colorPickerIn {
    from { opacity: 0; transform: translateY(-4px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .color-edit-picker .color-swatch-row {
    margin-bottom: 0;
  }
  .color-edit-picker .color-swatch {
    width: 22px; height: 22px;
  }
  .color-edit-reset {
    background: none;
    border: none;
    color: rgba(255,255,255,0.3);
    font-size: 12px;
    cursor: pointer;
    padding: 4px 0 0;
    transition: color 0.15s;
    width: 100%;
    text-align: center;
  }
  .color-edit-reset:hover { color: rgba(255,255,255,0.7); }

  .category-label {
    font-size: 15px;
    font-weight: 500;
    color: rgba(255,255,255,0.7);
    flex: 1;
  }

  .category-count {
    font-size: 14px;
    font-weight: 500;
    color: rgba(255,255,255,0.3);
    min-width: 18px;
    text-align: right;
  }

  .category-chip .category-delete {
    display: none;
    background: none;
    border: none;
    color: var(--t-muted);
    font-size: 15px;
    cursor: pointer;
    padding: 0;
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
    flex-shrink: 0;
    margin-left: auto;
    transition: color 0.15s;
  }
  .category-chip:hover .category-delete { display: block; }
  .category-chip .category-delete:hover { color: var(--accent-red); }

  .category-desc-editor {
    padding: 6px 10px 8px;
    margin: 2px 0 4px;
    background: rgba(30, 30, 34, 0.95);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 10px;
    animation: colorPickerIn 0.12s ease-out;
  }
  .category-desc-editor label {
    font-size: 12px;
    color: rgba(255,255,255,0.3);
    display: block;
    margin-bottom: 4px;
  }
  .category-desc-editor textarea {
    width: 100%;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 6px;
    color: rgba(255,255,255,0.8);
    font-size: 15px;
    font-family: inherit;
    padding: 6px 8px;
    resize: vertical;
    min-height: 36px;
    max-height: 80px;
    outline: none;
    transition: border-color 0.15s;
  }
  .category-desc-editor textarea:focus {
    border-color: rgba(255,255,255,0.2);
  }
  .category-desc-actions {
    display: flex;
    gap: 6px;
    margin-top: 6px;
    justify-content: flex-end;
  }
  .category-desc-actions button {
    font-size: var(--fs-sm);
    font-family: inherit;
    font-weight: 500;
    padding: 4px 12px;
    border-radius: var(--r-small);
    border: 1px solid var(--b-subtle);
    cursor: pointer;
    transition: all var(--ease);
  }
  .desc-save-btn {
    background: var(--s-medium);
    color: var(--t-primary);
  }
  .desc-save-btn:hover { background: var(--s-active); color: var(--t-bright); }
  .desc-cancel-btn {
    background: none;
    color: var(--t-muted);
    border-color: transparent;
  }
  .desc-cancel-btn:hover { color: var(--t-secondary); background: var(--s-hover); }

  .category-label {
    cursor: default;
  }
  .category-label .cat-edit-icon {
    display: none;
    font-size: 13px;
    margin-left: 5px;
    opacity: 0.45;
    vertical-align: middle;
    cursor: pointer;
    transition: opacity 0.15s;
  }
  .category-chip:hover .category-label .cat-edit-icon {
    display: inline;
  }
  .category-label .cat-edit-icon:hover {
    opacity: 0.8;
  }

  #category-add-btn,
  #category-add-parent-btn {
    border-radius: var(--r-card);
    border: 1px dashed var(--b-light);
    background: var(--s-subtle);
    color: var(--t-muted);
    font-size: var(--fs-sm);
    font-weight: 500;
    font-family: inherit;
    letter-spacing: 0.3px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    transition: all var(--ease);
    padding: 7px 0;
  }
  #category-add-btn:hover,
  #category-add-parent-btn:hover {
    background: var(--s-hover);
    border-color: var(--b-visible);
    color: var(--t-primary);
    border-style: solid;
  }
  #category-add-btn svg,
  #category-add-parent-btn svg {
    width: 13px; height: 13px;
    stroke: currentColor;
    stroke-width: 2;
    fill: none;
  }

  #category-create-form {
    display: none;
    padding: 10px;
    margin-top: 8px;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 10px;
  }
  #category-create-form[data-mode="parent"] #cat-parent-select,
  #category-create-form[data-mode="parent"] .styled-select {
    display: none;
  }
  #category-create-form.open { display: block; }

  .category-create-input {
    width: 100%;
    background: var(--s-subtle);
    border: 1px solid var(--b-subtle);
    border-radius: var(--r-small);
    padding: 7px 10px;
    color: var(--t-bright);
    font-size: var(--fs-base);
    outline: none;
    margin-bottom: 6px;
    transition: border-color var(--ease);
    font-family: inherit;
  }
  .category-create-input::placeholder { color: var(--t-faint); }
  .category-create-input:focus { border-color: var(--b-hover); }
  .category-create-input.invalid { border-color: rgba(255,82,82,0.5); }

  .color-swatch-row {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    margin-bottom: 8px;
  }

  .color-swatch {
    width: 24px; height: 24px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all 0.15s;
    padding: 0;
  }
  .color-swatch:hover { transform: scale(1.15); }
  .color-swatch.selected { border-color: rgba(255,255,255,0.8); transform: scale(1.15); }

  .category-form-actions {
    display: flex;
    gap: 6px;
  }
  .category-form-actions button {
    flex: 1;
    padding: 6px 0;
    border-radius: var(--r-small);
    font-size: var(--fs-md);
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    transition: all var(--ease);
    border: 1px solid var(--b-subtle);
  }
  .category-form-btn-create {
    background: var(--s-medium);
    color: var(--t-primary);
  }
  .category-form-btn-create:hover {
    background: var(--s-active);
    color: var(--t-bright);
  }
  .category-form-btn-create:disabled {
    opacity: 0.3;
    cursor: not-allowed;
  }
  .category-form-btn-cancel {
    background: var(--s-transparent);
    color: var(--t-muted);
    border-color: transparent;
  }
  .category-form-btn-cancel:hover {
    background: var(--s-hover);
    color: var(--t-primary);
  }

  .category-form-error {
    font-size: 12px;
    color: #FF5252;
    margin-bottom: 6px;
    min-height: 14px;
  }

  .category-reassign-bar {
    padding: 8px;
    margin-top: 4px;
    background: rgba(255,82,82,0.08);
    border: 1px solid rgba(255,82,82,0.15);
    border-radius: 8px;
    font-size: 12px;
    color: rgba(255,255,255,0.6);
  }
  .category-reassign-bar select {
    width: 100%;
    margin: 6px 0;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 6px;
    padding: 5px 8px;
    color: rgba(255,255,255,0.8);
    font-size: 13px;
    outline: none;
  }
  .category-reassign-bar select option {
    background: #1c1c1e;
    color: #e0e0e0;
  }
  .category-reassign-actions {
    display: flex;
    gap: 6px;
    margin-top: 6px;
  }
  .category-reassign-actions button {
    flex: 1;
    padding: 5px 0;
    border-radius: var(--r-small);
    font-size: var(--fs-md);
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    border: 1px solid var(--b-subtle);
    transition: all var(--ease);
  }
  .reassign-confirm {
    background: var(--accent-red-bg);
    color: var(--accent-red);
    border-color: rgba(255,82,82,0.12);
  }
  .reassign-confirm:hover {
    background: var(--accent-red-hover);
  }
  .reassign-cancel-btn {
    background: var(--s-transparent);
    color: var(--t-muted);
    border-color: transparent;
  }
  .reassign-cancel-btn:hover {
    background: var(--s-hover);
    color: var(--t-primary);
  }

  /* ── Category delete flow ── */
  .cat-delete-options {
    display: flex;
    flex-direction: column;
    gap: 6px;
    margin: 16px 0 12px;
    text-align: left;
  }
  .cat-delete-option {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 14px;
    border-radius: var(--r-card);
    border: 1px solid var(--b-subtle);
    background: rgba(255,255,255,0.02);
    cursor: pointer;
    transition: all var(--ease);
  }
  .cat-delete-option:hover {
    background: rgba(255,255,255,0.04);
    border-color: rgba(255,255,255,0.10);
  }
  .cat-delete-option-icon {
    flex-shrink: 0;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .cat-delete-option-icon svg {
    width: 18px;
    height: 18px;
    stroke-width: 1.6;
    fill: none;
    opacity: 0.75;
    transition: opacity var(--ease);
  }
  .cat-delete-option:hover .cat-delete-option-icon svg,
  .cat-delete-option.selected .cat-delete-option-icon svg { opacity: 1; }
  .cat-delete-option--delete .cat-delete-option-icon svg { stroke: #E8886F; }
  .cat-delete-option--export .cat-delete-option-icon svg { stroke: var(--accent-blue); }
  .cat-delete-option--migrate .cat-delete-option-icon svg { stroke: var(--accent-gold); }
  .cat-delete-option--delete.selected {
    border-color: rgba(232,136,111,0.35);
    background: rgba(232,136,111,0.06);
  }
  .cat-delete-option--export.selected {
    border-color: rgba(79,195,247,0.3);
    background: rgba(79,195,247,0.05);
  }
  .cat-delete-option--migrate.selected {
    border-color: rgba(255,215,0,0.3);
    background: rgba(255,215,0,0.04);
  }
  .cat-delete-option-text {
    flex: 1;
    min-width: 0;
  }
  .cat-delete-option-label {
    font-size: var(--fs-md);
    font-weight: 600;
    color: var(--t-bright);
    margin-bottom: 2px;
  }
  .cat-delete-option-desc {
    font-size: var(--fs-xs);
    color: var(--t-muted);
    line-height: 1.35;
  }
  .cat-delete-step {
    animation: tagModalFadeIn 0.15s ease-out;
  }
  .cat-delete-step .modal-select {
    margin-top: 8px;
  }
  .cat-delete-progress {
    font-size: var(--fs-xs);
    color: var(--t-muted);
    margin-top: 8px;
    text-align: center;
  }

  /* ═══════════════════════════════════════════
     DETAIL PANEL (right, slide-in)
     ═══════════════════════════════════════════ */
  #detail-panel {
    position: fixed;
    top: 52px;
    right: -520px;
    z-index: 100;
    width: 400px;
    min-width: 280px;
    min-height: 200px;
    max-height: calc(100vh - 80px);
    overflow-y: auto;
    padding: 0;
    transition: right 0.4s cubic-bezier(0.22, 1, 0.36, 1);
    display: flex;
    flex-direction: column;
  }

  #detail-panel.open { right: 20px; }
  #detail-panel.resizing { transition: none; }

  /* ── Panel header — action bar + category ── */
  .detail-header {
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' viewBox='0 0 22 22'%3E%3Cpath d='M11 2l3 3.5h-2v4.5h4.5V8L20 11l-3.5 3v-2H12v4.5h2L11 20l-3-3.5h2v-4.5H5.5V14L2 11l3.5-3v2H10V5.5H8z' fill='rgba(255,255,255,0.65)' stroke='rgba(0,0,0,0.35)' stroke-width='0.6'/%3E%3C/svg%3E") 11 11, move;
  }
  .detail-header:active {
    cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' viewBox='0 0 22 22'%3E%3Cpath d='M11 2l3 3.5h-2v4.5h4.5V8L20 11l-3.5 3v-2H12v4.5h2L11 20l-3-3.5h2v-4.5H5.5V14L2 11l3.5-3v2H10V5.5H8z' fill='%234FC3F7' stroke='rgba(0,0,0,0.35)' stroke-width='0.6'/%3E%3C/svg%3E") 11 11, move;
  }
  .detail-header-actions {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 4px;
    padding: 8px 12px 0;
  }
  .detail-header-category {
    display: flex;
    align-items: baseline;
    gap: 8px;
    padding: 8px 16px 12px;
    border-bottom: 1px solid var(--b-subtle);
  }
  .detail-header-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    flex-shrink: 0;
    box-shadow: 0 0 6px currentColor;
    position: relative;
    top: -1px;
  }
  .detail-header-name {
    font-size: var(--fs-md);
    font-weight: 600;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--t-primary);
    line-height: 1.4;
    word-break: break-word;
  }
  /* Small icon buttons used in header */
  .detail-action-btn {
    width: 30px; height: 30px;
    border-radius: var(--r-circle);
    background: transparent;
    border: 1px solid transparent;
    color: var(--t-muted);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all var(--ease);
    padding: 0;
    flex-shrink: 0;
    position: relative;
  }
  .detail-action-btn svg {
    width: 15px; height: 15px;
    stroke: currentColor;
    stroke-width: 1.8;
    fill: none;
  }
  .detail-action-btn:hover {
    background: var(--s-hover);
    color: var(--t-primary);
    border-color: var(--b-light);
  }
  .detail-action-btn--gold:hover {
    color: var(--accent-gold);
    border-color: var(--accent-gold-border);
  }
  .detail-action-btn--gold.active {
    color: var(--accent-gold);
  }
  .detail-action-btn--gold.active svg,
  .detail-action-btn--gold.active svg.filled { fill: currentColor; }
  .detail-action-btn--danger:hover {
    color: var(--accent-red);
    border-color: rgba(255,82,82,0.25);
    background: var(--accent-red-bg);
  }
  .detail-action-btn--close {
    font-size: 18px;
    font-weight: 400;
    line-height: 1;
  }
  .detail-action-btn--close:hover {
    color: var(--t-bright);
  }
  /* Custom tooltip (JS-positioned, appended to body) */
  .ui-tooltip {
    display: none;
    position: fixed;
    pointer-events: none;
    z-index: 99999;
    padding: 5px 10px;
    border-radius: 6px;
    background: rgba(10, 12, 18, 0.92);
    border: 1px solid rgba(255,255,255,0.08);
    backdrop-filter: blur(12px);
    color: rgba(255,255,255,0.85);
    font-size: 11px;
    font-family: inherit;
    font-weight: 500;
    letter-spacing: 0.02em;
    white-space: nowrap;
    box-shadow: 0 4px 16px rgba(0,0,0,0.4), 0 0 0 1px rgba(255,255,255,0.04);
    opacity: 0;
    transform: translateY(4px);
    transition: opacity 0.15s ease, transform 0.15s ease;
  }
  .ui-tooltip.visible {
    opacity: 1;
    transform: translateY(0);
  }
  .ui-tooltip-arrow {
    position: absolute;
    width: 10px; height: 10px;
    pointer-events: none;
  }
  .ui-tooltip-arrow::after {
    content: '';
    position: absolute;
    border: 5px solid transparent;
  }
  .ui-tooltip.above .ui-tooltip-arrow {
    bottom: -10px; left: 50%; transform: translateX(-50%);
  }
  .ui-tooltip.above .ui-tooltip-arrow::after {
    border-top-color: rgba(10, 12, 18, 0.92);
  }
  .ui-tooltip.below .ui-tooltip-arrow {
    top: -10px; left: 50%; transform: translateX(-50%);
  }
  .ui-tooltip.below .ui-tooltip-arrow::after {
    border-bottom-color: rgba(10, 12, 18, 0.92);
  }
  /* Separator dot between action groups */
  .detail-action-sep {
    width: 3px; height: 3px;
    border-radius: 50%;
    background: var(--b-light);
    flex-shrink: 0;
  }

  /* ── Panel body ── */
  .detail-body {
    padding: 14px 16px 16px;
    overflow-y: auto;
    flex: 1;
  }

  /* ── Subheader — importance + chips ── */
  .detail-subheader {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 14px;
    flex-wrap: wrap;
  }
  #detail-importance {
    display: flex;
    align-items: center;
    gap: 3px;
  }
  .detail-chip {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 3px 10px;
    border: 1px solid var(--b-subtle);
    border-radius: var(--r-pill);
    background: var(--s-subtle);
    color: var(--t-muted);
    font-size: var(--fs-xs);
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    transition: all var(--ease);
    white-space: nowrap;
    letter-spacing: 0.02em;
  }
  .detail-chip:hover {
    color: var(--t-primary);
    background: var(--s-hover);
    border-color: var(--b-hover);
  }
  .detail-chip.active {
    color: var(--accent-blue);
    background: var(--accent-blue-bg);
    border-color: var(--accent-blue-border);
  }
  .detail-chip.active:hover {
    background: rgba(79,195,247,0.18);
  }
  .detail-chip svg {
    width: 10px; height: 10px;
    fill: none;
    stroke: currentColor;
    stroke-width: 2;
    stroke-linecap: round;
  }
  /* ── Category change modal ── */
  .cat-change-modal {
    min-width: 380px;
    max-width: 440px;
    max-height: 480px;
    display: flex;
    flex-direction: column;
  }
  .cat-change-modal-title {
    font-size: var(--fs-md);
    color: var(--t-secondary);
    margin-bottom: 4px;
  }
  .cat-change-modal-current {
    font-size: var(--fs-base);
    font-weight: 600;
    color: var(--t-bright);
    margin-bottom: 14px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .cat-change-modal-current .cat-dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
    box-shadow: 0 0 4px currentColor;
  }
  .cat-change-modal-list {
    overflow-y: auto;
    max-height: 300px;
    padding: 2px;
  }
  .cat-modal-option {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.12s;
    font-size: var(--fs-base);
    color: var(--t-primary);
    text-transform: none;
    letter-spacing: normal;
  }
  .cat-modal-option:hover {
    background: var(--s-hover);
    color: var(--t-bright);
  }
  .cat-modal-option.active {
    background: var(--accent-blue-bg);
    border: 1px solid var(--accent-blue-border);
    color: var(--t-bright);
  }
  .cat-modal-option .cat-opt-dot {
    width: 10px; height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
    box-shadow: 0 0 4px currentColor;
  }
  .cat-modal-option .cat-opt-name {
    flex: 1;
    min-width: 0;
  }
  .cat-modal-option .cat-opt-desc {
    font-size: var(--fs-xs);
    color: var(--t-muted);
    max-width: 180px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  #detail-content {
    font-family: 'JetBrains Mono', 'SF Mono', 'Consolas', monospace;
    font-size: 13px;
    line-height: 1.7;
    color: rgba(255,255,255,0.7);
    margin-bottom: 20px;
    word-break: break-word;
    position: relative;
  }

  /* Paragraphs */
  #detail-content p, .trash-detail-body p {
    margin: 0 0 10px 0;
  }
  #detail-content p:last-child, .trash-detail-body p:last-child { margin-bottom: 0; }

  /* H2 — main section */
  #detail-content .mc-h2, .trash-detail-body .mc-h2 {
    font-size: 16px;
    font-weight: 600;
    color: rgba(255,255,255,0.92);
    margin: 0 0 12px 0;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
    letter-spacing: -0.01em;
  }
  #detail-content .mc-h2:first-child, .trash-detail-body .mc-h2:first-child { margin-top: 0; }

  /* H3 — subsection */
  #detail-content .mc-h3, .trash-detail-body .mc-h3 {
    font-size: 14px;
    font-weight: 600;
    color: rgba(255,255,255,0.75);
    margin: 16px 0 6px 0;
    letter-spacing: 0.01em;
  }
  #detail-content .mc-h3:first-child, .trash-detail-body .mc-h3:first-child { margin-top: 0; }

  /* H4+ / plain heading */
  #detail-content .mc-h4, .trash-detail-body .mc-h4 {
    font-size: 13px;
    font-weight: 600;
    color: rgba(255,255,255,0.6);
    margin: 12px 0 4px 0;
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }

  /* Inline code */
  #detail-content code, .trash-detail-body code {
    font-family: inherit;
    font-size: inherit;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.04);
    border-radius: 5px;
    padding: 2px 7px;
    color: rgba(255,255,255,0.75);
    word-break: break-all;
  }

  /* Code block */
  #detail-content .mc-codeblock, .trash-detail-body .mc-codeblock {
    font-family: inherit;
    font-size: inherit;
    line-height: 1.6;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.04);
    border-radius: 10px;
    padding: 12px 14px;
    margin: 8px 0 12px 0;
    color: rgba(255,255,255,0.6);
    overflow-x: auto;
    white-space: pre;
  }

  /* Bold */
  #detail-content strong, .trash-detail-body strong {
    font-weight: 600;
    color: rgba(255,255,255,0.88);
  }

  /* Lists */
  #detail-content ul, .trash-detail-body ul {
    margin: 4px 0 12px 0;
    padding: 0;
    list-style: none;
  }

  #detail-content li, .trash-detail-body li {
    position: relative;
    padding-left: 16px;
    margin-bottom: 5px;
    color: rgba(255,255,255,0.65);
    font-size: inherit;
    line-height: 1.65;
  }

  #detail-content li::before, .trash-detail-body li::before {
    content: '';
    position: absolute;
    left: 2px;
    top: 8px;
    width: 5px;
    height: 5px;
    border-radius: 50%;
    background: rgba(255,255,255,0.2);
  }

  /* Key-value description after em dash or colon in list */
  #detail-content li .kv-desc, .trash-detail-body li .kv-desc {
    color: rgba(255,255,255,0.4);
    font-weight: 400;
  }

  /* Divider */
  #detail-content .mc-divider, .trash-detail-body .mc-divider {
    height: 1px;
    background: rgba(255,255,255,0.05);
    margin: 14px 0;
  }

  /* Key: Value standalone */
  #detail-content .mc-kv, .trash-detail-body .mc-kv {
    margin-bottom: 4px;
    font-size: inherit;
    line-height: 1.65;
  }
  #detail-content .mc-kv-key, .trash-detail-body .mc-kv-key {
    color: rgba(255,255,255,0.4);
    font-weight: 500;
  }
  #detail-content .mc-kv-val, .trash-detail-body .mc-kv-val {
    color: rgba(255,255,255,0.75);
  }

  /* ── Content Edit Button ── */
  .content-edit-wrap {
    position: relative;
  }

  /* ── Markdown Editor ── */
  .md-editor-wrap {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 20px;
  }
  .md-toolbar {
    display: flex;
    gap: 4px;
    padding: 4px;
    background: var(--s-subtle);
    border: 1px solid var(--b-subtle);
    border-radius: var(--r-card);
  }
  .md-toolbar button {
    padding: 5px 10px;
    border: 1px solid transparent;
    border-radius: var(--r-small);
    background: transparent;
    color: var(--t-secondary);
    font-size: var(--fs-md);
    font-weight: 600;
    font-family: inherit;
    cursor: pointer;
    transition: all var(--ease);
    line-height: 1;
  }
  .md-toolbar button:hover {
    background: var(--s-medium);
    color: var(--t-bright);
    border-color: var(--b-light);
  }
  .md-toolbar button.active {
    background: var(--accent-blue-bg);
    color: var(--accent-blue);
    border-color: var(--accent-blue-border);
  }
  .md-textarea {
    width: 100%;
    min-height: 120px;
    max-height: 360px;
    overflow-y: auto;
    padding: 12px 14px;
    background: rgba(0,0,0,0.3);
    border: 1px solid var(--b-light);
    border-radius: var(--r-card);
    color: var(--t-primary);
    font-family: 'JetBrains Mono', 'SF Mono', 'Consolas', monospace;
    font-size: 13px;
    line-height: 1.6;
    resize: vertical;
    outline: none;
    transition: border-color var(--ease);
  }
  .md-textarea:focus {
    border-color: var(--accent-blue-border);
  }
  .md-editor-actions {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
  }
  .md-editor-actions button {
    padding: 6px 16px;
    border-radius: var(--r-small);
    font-size: var(--fs-md);
    font-weight: 500;
    cursor: pointer;
    transition: all var(--ease);
    border: 1px solid;
  }
  .md-btn-cancel {
    background: transparent;
    border-color: var(--b-light) !important;
    color: var(--t-secondary);
  }
  .md-btn-cancel:hover {
    background: var(--s-hover);
    color: var(--t-primary);
  }
  .md-btn-save {
    background: var(--accent-blue-bg);
    border-color: var(--accent-blue-border) !important;
    color: var(--accent-blue);
  }
  .md-btn-save:hover {
    background: rgba(79,195,247,0.2);
  }

  .detail-section {
    margin-bottom: 16px;
  }

  .detail-label {
    font-size: 11px;
    font-weight: 600;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: rgba(255,255,255,0.3);
    margin-bottom: 8px;
  }

  .tag-chips {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .tag-chip {
    font-size: var(--fs-sm);
    font-weight: 500;
    padding: 4px 10px;
    border-radius: var(--r-pill);
    background: var(--s-light);
    color: var(--t-secondary);
    border: 1px solid var(--b-subtle);
    display: inline-flex;
    align-items: center;
    gap: 0;
    cursor: default;
    transition: all 0.2s;
    position: relative;
  }
  .tag-chip:hover {
    border-color: var(--b-light);
  }
  .tag-chip .tag-remove {
    display: none;
    margin-left: 6px;
    color: var(--t-muted);
    font-size: 13px;
    line-height: 1;
    cursor: pointer;
    transition: color 0.15s;
  }
  .tag-chip:hover .tag-remove { display: inline; }
  .tag-chip .tag-remove:hover { color: var(--accent-red); }

  /* Confirmation modal overlay + panel */
  .tag-delete-overlay {
    position: fixed;
    inset: 0;
    z-index: 300;
    background: rgba(0,0,0,0.55);
    backdrop-filter: blur(18px) saturate(0.8);
    -webkit-backdrop-filter: blur(18px) saturate(0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    animation: tagModalFadeIn 0.15s ease-out;
  }
  @keyframes tagModalFadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  .tag-delete-modal {
    background: rgba(28, 28, 30, 0.72);
    backdrop-filter: blur(40px) saturate(1.4);
    -webkit-backdrop-filter: blur(40px) saturate(1.4);
    border: 1px solid rgba(255, 255, 255, 0.06);
    border-radius: 14px;
    box-shadow: 0 2px 20px rgba(0, 0, 0, 0.4), inset 0 0.5px 0 rgba(255, 255, 255, 0.05);
    padding: 22px 28px;
    text-align: center;
    min-width: 260px;
    animation: tagModalScaleIn 0.15s ease-out;
  }
  @keyframes tagModalScaleIn {
    from { opacity: 0; transform: scale(0.95); }
    to { opacity: 1; transform: scale(1); }
  }
  .tag-delete-modal-title {
    font-size: var(--fs-md);
    color: var(--t-secondary);
    margin-bottom: 6px;
  }
  .tag-delete-modal-tag {
    font-size: var(--fs-base);
    font-weight: 600;
    color: var(--t-bright);
    margin-bottom: 18px;
  }
  .tag-delete-modal-actions {
    display: flex;
    gap: 8px;
    justify-content: center;
  }
  .tag-delete-modal-actions button {
    font-size: var(--fs-sm);
    font-weight: 500;
    font-family: inherit;
    padding: 7px 22px;
    border-radius: var(--r-card);
    border: 1px solid var(--b-subtle);
    cursor: pointer;
    transition: all var(--ease);
  }
  .modal-select {
    width: 100%;
    margin-bottom: 16px;
    background: #111114;
    border: 1px solid var(--b-light);
    border-radius: var(--r-button);
    padding: 9px 12px;
    color: var(--t-bright);
    font-size: var(--fs-md);
    font-family: inherit;
    outline: none;
    appearance: none;
    -webkit-appearance: none;
    cursor: pointer;
    transition: all var(--ease);
  }
  select.modal-select {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='rgba(255,255,255,0.35)' stroke-width='2.5' stroke-linecap='round'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 10px center;
    background-color: #111114;
    padding-right: 30px;
  }
  .modal-select:focus {
    border-color: var(--b-hover);
    background-color: #151518;
  }
  .modal-select option {
    background: #111114;
    color: #ccc;
    padding: 8px 12px;
  }

  /* ── Custom styled dropdown (replaces native <select>) ── */
  .styled-select {
    position: relative;
    width: 100%;
    margin-bottom: 16px;
  }
  .styled-select-trigger {
    width: 100%;
    display: flex;
    align-items: center;
    gap: 8px;
    background: #111114;
    border: 1px solid var(--b-light);
    border-radius: var(--r-button);
    padding: 9px 32px 9px 12px;
    color: var(--t-bright);
    font-size: var(--fs-md);
    font-family: inherit;
    cursor: pointer;
    transition: all var(--ease);
    position: relative;
    text-align: left;
    outline: none;
  }
  .styled-select-trigger::after {
    content: '';
    position: absolute;
    right: 11px;
    top: 50%;
    transform: translateY(-50%) rotate(0deg);
    width: 0;
    height: 0;
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
    border-top: 5px solid rgba(255,255,255,0.35);
    transition: transform 0.2s ease;
  }
  .styled-select.open .styled-select-trigger::after {
    transform: translateY(-50%) rotate(180deg);
  }
  .styled-select-trigger:hover,
  .styled-select.open .styled-select-trigger {
    border-color: var(--b-hover);
    background: #151518;
  }
  .styled-select-label {
    flex: 1;
    min-width: 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .styled-select-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
  }
  .styled-select-menu {
    position: absolute;
    top: calc(100% + 4px);
    left: 0;
    right: 0;
    z-index: 310;
    max-height: 220px;
    overflow-y: auto;
    background: rgba(20, 20, 22, 0.92);
    backdrop-filter: blur(24px) saturate(1.3);
    -webkit-backdrop-filter: blur(24px) saturate(1.3);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 10px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5), inset 0 0.5px 0 rgba(255,255,255,0.04);
    padding: 4px;
    display: none;
    animation: styledSelectIn 0.12s ease-out;
  }
  .styled-select.open .styled-select-menu { display: block; }
  @keyframes styledSelectIn {
    from { opacity: 0; transform: translateY(-4px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .styled-select-menu::-webkit-scrollbar { width: 5px; }
  .styled-select-menu::-webkit-scrollbar-track { background: transparent; }
  .styled-select-menu::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.08); border-radius: 4px; }
  .styled-select-option {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 7px 10px;
    border-radius: 7px;
    cursor: pointer;
    color: var(--t-secondary);
    font-size: var(--fs-md);
    font-family: inherit;
    transition: all 0.1s ease;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .styled-select-option:hover {
    background: rgba(255,255,255,0.06);
    color: var(--t-bright);
  }
  .styled-select-option.active {
    background: rgba(99,102,241,0.12);
    color: var(--t-bright);
  }
  .styled-select-option .styled-select-dot { flex-shrink: 0; }

  /* ── Settings Panel (draggable/pinnable) ── */
  .settings-panel {
    position: fixed;
    z-index: 300;
    width: 620px;
    max-width: 92vw;
    min-width: 380px;
    min-height: 400px;
    animation: tagModalScaleIn 0.15s ease-out;
    display: flex;
    flex-direction: column;
    max-height: 80vh;
    overflow: hidden;
  }
  .settings-panel.dragging { transition: none; }
  .settings-panel-header {
    display: flex;
    align-items: center;
    padding: 10px 16px;
    border-bottom: 1px solid var(--b-subtle);
    gap: 8px;
  }
  .settings-panel-header h3 {
    flex: 1;
    font-size: 13px;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    font-weight: 500;
    color: rgba(255,255,255,0.45);
    margin: 0;
    pointer-events: none;
  }
  .settings-panel-header .pin-btn {
    position: relative;
    top: auto;
    right: auto;
    opacity: 1;
  }
  .settings-panel-close {
    width: 26px; height: 26px;
    display: flex; align-items: center; justify-content: center;
    background: transparent; border: none;
    color: var(--t-muted); cursor: pointer;
    border-radius: var(--r-circle);
    font-size: 18px; line-height: 1;
    transition: all var(--ease);
    padding: 0; flex-shrink: 0;
  }
  .settings-panel-close:hover { color: var(--t-bright); background: var(--s-hover); }
  .settings-panel-body {
    display: flex;
    flex: 1;
    overflow: hidden;
    min-height: 0;
  }
  .settings-nav {
    width: 150px;
    flex-shrink: 0;
    padding: 12px 8px;
    border-right: 1px solid var(--b-subtle);
    display: flex;
    flex-direction: column;
    gap: 2px;
    overflow-y: auto;
  }
  .settings-nav-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 10px;
    font-size: 13px;
    font-weight: 500;
    font-family: inherit;
    color: var(--t-muted);
    background: transparent;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all var(--ease);
    text-align: left;
    white-space: nowrap;
  }
  .settings-nav-item svg {
    width: 15px;
    height: 15px;
    flex-shrink: 0;
    stroke: currentColor;
    stroke-width: 1.8;
    fill: none;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .settings-nav-item:hover { color: var(--t-primary); background: var(--s-hover); }
  .settings-nav-item.active { color: var(--t-bright); background: var(--s-medium); }
  .settings-content {
    flex: 1;
    padding: 16px;
    overflow-y: auto;
    min-width: 0;
  }
  .settings-panel.locked .settings-panel-header {
    cursor: default;
  }
  .settings-panel-backdrop {
    position: fixed;
    inset: 0;
    z-index: 299;
    pointer-events: none;
  }
  .settings-field {
    margin-bottom: 16px;
  }
  .settings-field label {
    display: block;
    font-size: var(--fs-sm);
    font-weight: 500;
    color: var(--t-primary);
    margin-bottom: 5px;
  }
  .settings-hint {
    font-size: var(--fs-xs);
    color: var(--t-muted);
    line-height: 1.4;
  }
  .settings-field .settings-hint {
    margin-top: 3px;
  }
  .settings-field input[type="text"],
  .settings-field input[type="password"] {
    width: 100%;
    box-sizing: border-box;
    font-size: var(--fs-md);
    font-family: 'JetBrains Mono', 'SF Mono', 'Consolas', monospace;
    padding: 7px 10px;
    border-radius: var(--r-small);
    background: var(--s-subtle);
    color: var(--t-bright);
    border: 1px solid var(--b-light);
    outline: none;
    transition: border-color var(--ease);
  }
  .settings-field input[type="text"]:focus,
  .settings-field input[type="password"]:focus {
    border-color: var(--accent-blue-border);
  }
  .settings-field input::placeholder {
    color: var(--t-muted);
  }
  .settings-key-row {
    display: flex;
    gap: 6px;
    align-items: center;
  }
  .settings-key-row input {
    flex: 1;
    font-size: var(--fs-md);
    font-family: 'JetBrains Mono', 'SF Mono', 'Consolas', monospace;
    padding: 7px 10px;
    border-radius: var(--r-small);
    background: var(--s-subtle);
    color: var(--t-bright);
    border: 1px solid var(--b-light);
    outline: none;
    transition: border-color var(--ease);
  }
  .settings-key-row input:focus {
    border-color: var(--accent-blue-border);
  }
  .settings-key-row input::placeholder {
    color: var(--t-muted);
    font-family: 'JetBrains Mono', 'SF Mono', 'Consolas', monospace;
  }
  .settings-toggle-vis {
    width: 32px;
    height: 32px;
    border-radius: var(--r-small);
    background: var(--s-subtle);
    border: 1px solid var(--b-light);
    color: var(--t-muted);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: all var(--ease);
  }
  .settings-toggle-vis:hover {
    background: var(--s-hover);
    color: var(--t-primary);
    border-color: var(--b-hover);
  }
  .settings-toggle-vis svg {
    width: 14px;
    height: 14px;
    stroke: currentColor;
    stroke-width: 2;
    fill: none;
  }
  .settings-status {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: var(--fs-sm);
    color: var(--t-secondary);
    margin-bottom: 16px;
    padding: 8px 10px;
    background: var(--s-subtle);
    border-radius: var(--r-small);
    border: 1px solid var(--b-subtle);
  }
  .settings-status-dot {
    width: 8px;
    height: 8px;
    border-radius: var(--r-circle);
    flex-shrink: 0;
  }
  .settings-status-dot.connected { background: #4caf50; box-shadow: 0 0 6px rgba(76,175,80,0.5); }
  .settings-status-dot.disconnected { background: var(--accent-red); box-shadow: 0 0 6px rgba(255,82,82,0.4); }
  /* ── Settings tabs ── */
  .settings-tab-body { display: none; }
  .settings-tab-body.active { display: block; }
  /* ── Range sliders ── */
  .gfx-group-title {
    font-size: var(--fs-xs);
    font-weight: 600;
    color: var(--t-muted);
    text-transform: uppercase;
    letter-spacing: 0.6px;
    margin: 14px 0 6px;
    padding-bottom: 4px;
    border-bottom: 1px solid var(--b-subtle);
  }
  .gfx-group-title:first-child { margin-top: 0; }
  .gfx-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 6px;
  }
  .gfx-label {
    font-size: var(--fs-sm);
    color: var(--t-secondary);
    min-width: 110px;
    flex-shrink: 0;
  }
  .gfx-row input[type="range"] {
    flex: 1;
    height: 4px;
    -webkit-appearance: none;
    appearance: none;
    background: var(--b-light);
    border-radius: 2px;
    outline: none;
    cursor: pointer;
  }
  .gfx-row input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--accent-blue);
    border: 2px solid rgba(0,0,0,0.4);
    cursor: pointer;
  }
  .gfx-val {
    font-size: var(--fs-xs);
    color: var(--t-muted);
    min-width: 36px;
    text-align: right;
    font-family: 'JetBrains Mono', 'SF Mono', 'Consolas', monospace;
  }
  .gfx-val-input {
    background: transparent;
    border: 1px solid transparent;
    border-radius: 4px;
    padding: 1px 2px;
    width: 38px;
    -moz-appearance: textfield;
    appearance: textfield;
  }
  .gfx-val-input:hover { border-color: var(--b-subtle); }
  .gfx-val-input:focus { border-color: var(--b-light); outline: none; background: rgba(255,255,255,0.04); }
  .gfx-val-input::-webkit-inner-spin-button,
  .gfx-val-input::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
  .gfx-reset-btn {
    margin-top: 12px;
    width: 100%;
    padding: 6px;
    font-size: var(--fs-sm);
    font-weight: 500;
    font-family: inherit;
    background: var(--accent-red-bg);
    border: 1px solid rgba(255,82,82,0.2);
    color: var(--accent-red);
    border-radius: var(--r-card);
    cursor: pointer;
    transition: all var(--ease);
  }
  .gfx-reset-btn:hover { background: var(--accent-red-hover); }

  /* Graphics presets */
  .gfx-presets {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
    margin-bottom: 16px;
  }
  .gfx-preset-card {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 3px;
    padding: 8px 6px;
    border-radius: 10px;
    border: 1px solid var(--b-subtle);
    background: var(--s-medium);
    cursor: pointer;
    transition: all 0.2s ease;
    overflow: hidden;
  }
  .gfx-preset-card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 10px;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
  }
  .gfx-preset-card:hover {
    border-color: rgba(255,255,255,0.15);
    background: var(--s-hover);
  }
  .gfx-preset-card:hover::before { opacity: 0.5; }
  .gfx-preset-card.active {
    border-color: var(--accent-blue);
    box-shadow: 0 0 12px rgba(79,195,247,0.15);
  }
  .gfx-preset-card.active::before { opacity: 1; }
  .gfx-preset-name {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--t-secondary);
  }
  .gfx-preset-card.active .gfx-preset-name { color: var(--t-bright); }
  .gfx-preset-desc {
    font-size: 9px;
    color: var(--t-muted);
    text-align: center;
    line-height: 1.3;
  }
  /* Per-preset gradient accents */
  .gfx-preset-card[data-preset="low"]::before {
    background: radial-gradient(ellipse at bottom, rgba(100,180,100,0.08) 0%, transparent 70%);
  }
  .gfx-preset-card[data-preset="medium"]::before {
    background: radial-gradient(ellipse at bottom, rgba(79,195,247,0.08) 0%, transparent 70%);
  }
  .gfx-preset-card[data-preset="high"]::before {
    background: radial-gradient(ellipse at bottom, rgba(171,71,188,0.1) 0%, transparent 70%);
  }
  .gfx-preset-card[data-preset="insane"]::before {
    background: radial-gradient(ellipse at bottom, rgba(255,145,0,0.12) 0%, transparent 70%);
  }
  .gfx-preset-card[data-preset="insane"].active {
    border-color: #ff9100;
    box-shadow: 0 0 16px rgba(255,145,0,0.2), 0 0 40px rgba(255,145,0,0.06);
    animation: insane-glow 2s ease-in-out infinite alternate;
  }
  @keyframes insane-glow {
    0% { box-shadow: 0 0 12px rgba(255,145,0,0.2), 0 0 30px rgba(255,145,0,0.05); }
    100% { box-shadow: 0 0 20px rgba(255,145,0,0.3), 0 0 50px rgba(255,145,0,0.1); }
  }

  /* ── Recall presets (Memory tab) ── */
  #recall-presets {
    grid-template-columns: repeat(3, 1fr);
  }
  #recall-presets .gfx-preset-card {
    padding: 10px 8px;
    gap: 2px;
  }
  .gfx-preset-card[data-recall-preset="150"]::before {
    background: radial-gradient(ellipse at bottom, rgba(76,175,80,0.1) 0%, transparent 70%);
  }
  .gfx-preset-card[data-recall-preset="150"].active {
    border-color: rgba(76,175,80,0.6);
    box-shadow: 0 0 12px rgba(76,175,80,0.15);
  }
  .gfx-preset-card[data-recall-preset="500"]::before {
    background: radial-gradient(ellipse at bottom, rgba(79,195,247,0.1) 0%, transparent 70%);
  }
  .gfx-preset-card[data-recall-preset="500"].active {
    border-color: rgba(79,195,247,0.6);
    box-shadow: 0 0 12px rgba(79,195,247,0.15);
  }
  .gfx-preset-card[data-recall-preset="0"]::before {
    background: radial-gradient(ellipse at bottom, rgba(171,71,188,0.1) 0%, transparent 70%);
  }
  .gfx-preset-card[data-recall-preset="0"].active {
    border-color: rgba(171,71,188,0.6);
    box-shadow: 0 0 12px rgba(171,71,188,0.15);
  }
  .recall-preview-box {
    margin-top: 14px;
    padding: 10px 12px;
    background: rgba(0,0,0,0.25);
    border: 1px solid var(--b-subtle);
    border-radius: 6px;
    font-family: 'SF Mono', 'Cascadia Code', 'JetBrains Mono', monospace;
    font-size: 10px;
    line-height: 1.5;
    color: var(--t-muted);
    max-height: 72px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-break: break-word;
  }

  /* ── Memory Sync ── */
  .sync-check-btn {
    background: var(--s-subtle);
    border: 1px solid var(--b-subtle);
    color: var(--t-secondary);
    font-size: var(--fs-sm);
    font-weight: 500;
    font-family: inherit;
    letter-spacing: 0.04em;
    padding: 6px 14px;
    border-radius: var(--r-pill);
    cursor: pointer;
    transition: all var(--ease);
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }
  .sync-check-btn:hover {
    background: var(--s-hover);
    color: var(--t-primary);
    border-color: var(--b-light);
  }
  .sync-check-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }
  .sync-check-btn .spinner {
    width: 12px;
    height: 12px;
    border: 1.5px solid var(--t-muted);
    border-top-color: var(--accent-blue);
    border-radius: 50%;
    animation: syncSpin 0.6s linear infinite;
    display: none;
  }
  .sync-check-btn.loading .spinner { display: inline-block; }
  .sync-check-btn.loading .btn-label { display: none; }

  @keyframes syncSpin {
    to { transform: rotate(360deg); }
  }

  .sync-results {
    margin-top: 12px;
  }
  .sync-summary {
    font-size: var(--fs-sm);
    color: var(--t-secondary);
    margin-bottom: 10px;
  }
  .sync-summary strong {
    color: var(--accent-gold);
    font-weight: 600;
  }
  .sync-summary.clean strong {
    color: #4ade80;
  }
  .sync-card {
    background: rgba(0,0,0,0.2);
    border: 1px solid var(--b-subtle);
    border-radius: var(--r-card);
    padding: 10px 12px;
    margin-bottom: 8px;
    transition: border-color var(--ease), background var(--ease);
    cursor: pointer;
    user-select: none;
  }
  .sync-card:hover {
    border-color: var(--b-hover);
  }
  .sync-card.selected {
    background: rgba(255,255,255,0.05);
    border-color: rgba(255,255,255,0.2);
  }
  .sync-card-check {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1.5px solid rgba(255,255,255,0.2);
    background: transparent;
    flex-shrink: 0;
    transition: all var(--ease);
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .sync-card.selected .sync-card-check {
    background: rgba(255,255,255,0.15);
    border-color: rgba(255,255,255,0.35);
  }
  .sync-card.selected .sync-card-check::after {
    content: '✓';
    font-size: 9px;
    color: var(--t-bright);
    line-height: 1;
  }
  .sync-select-all {
    font-size: var(--fs-xs);
    color: var(--t-muted);
    cursor: pointer;
    background: none;
    border: none;
    font-family: inherit;
    padding: 0;
    margin-bottom: 8px;
    transition: color var(--ease);
  }
  .sync-select-all:hover {
    color: var(--t-primary);
  }
  .sync-card-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 6px;
  }
  .sync-card-category {
    font-size: 9px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    padding: 2px 7px;
    border-radius: 10px;
    background: var(--accent-blue-bg);
    color: var(--accent-blue);
    border: 1px solid var(--accent-blue-border);
  }
  .sync-card-importance {
    font-size: 9px;
    font-weight: 600;
    padding: 2px 6px;
    border-radius: 10px;
    background: var(--accent-gold-bg);
    color: var(--accent-gold);
    border: 1px solid var(--accent-gold-border);
  }
  .sync-card-content {
    font-size: var(--fs-xs);
    color: var(--t-muted);
    line-height: 1.4;
    margin-bottom: 6px;
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
  }
  .sync-card-files {
    font-size: 9px;
    color: var(--t-faint);
    font-family: 'JetBrains Mono', monospace;
    margin-bottom: 8px;
  }
  .sync-card-files span {
    color: var(--accent-gold);
  }
  .sync-copy-btn {
    background: var(--accent-blue-bg);
    border: 1px solid var(--accent-blue-border);
    color: var(--accent-blue);
    font-size: 10px;
    font-weight: 500;
    font-family: inherit;
    padding: 4px 10px;
    border-radius: var(--r-pill);
    cursor: pointer;
    transition: all var(--ease);
    width: 100%;
  }
  .sync-copy-btn:hover {
    background: rgba(79,195,247,0.2);
    border-color: rgba(79,195,247,0.4);
  }
  .sync-copy-btn.copied {
    background: rgba(74,222,128,0.12);
    border-color: rgba(74,222,128,0.3);
    color: #4ade80;
  }

  /* Advanced section collapsible */
  .gfx-advanced-toggle {
    display: flex;
    align-items: center;
    gap: 6px;
    width: 100%;
    padding: 8px 0;
    margin-top: 8px;
    background: none;
    border: none;
    border-top: 1px solid var(--b-subtle);
    color: var(--t-muted);
    font-size: var(--fs-xs);
    font-weight: 600;
    font-family: inherit;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    cursor: pointer;
    transition: color 0.2s;
  }
  .gfx-advanced-toggle:hover { color: var(--t-secondary); }
  .gfx-advanced-toggle .arrow {
    display: inline-block;
    transition: transform 0.2s;
    font-size: 10px;
  }
  .gfx-advanced-toggle.open .arrow { transform: rotate(90deg); }
  .gfx-advanced-body {
    display: none;
    padding-top: 4px;
  }
  .gfx-advanced-body.open { display: block; }
  .gfx-preset-label {
    font-size: var(--fs-xs);
    color: var(--t-muted);
    margin-bottom: 8px;
  }
  .settings-restart-notice {
    margin-top: 12px;
    padding: 10px 12px;
    background: rgba(255,215,0,0.08);
    border: 1px solid rgba(255,215,0,0.2);
    border-radius: var(--r-small);
    font-size: var(--fs-sm);
    color: var(--accent-gold);
    display: none;
  }
  .settings-actions {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    margin-top: 20px;
  }
  .settings-actions button {
    font-family: inherit;
    font-size: var(--fs-md);
    font-weight: 500;
    padding: 7px 18px;
    border-radius: var(--r-card);
    cursor: pointer;
    transition: all var(--ease);
  }
  .settings-btn-cancel {
    background: var(--s-subtle);
    border: 1px solid var(--b-light);
    color: var(--t-secondary);
  }
  .settings-btn-cancel:hover {
    background: var(--s-hover);
    color: var(--t-primary);
  }
  .settings-btn-save {
    background: var(--accent-blue-bg);
    border: 1px solid var(--accent-blue-border);
    color: var(--accent-blue);
  }
  .settings-btn-save:hover {
    background: rgba(79,195,247,0.18);
  }
  #settings-btn {
    border-radius: var(--r-card);
    border: 1px dashed var(--b-light);
    background: var(--s-subtle);
    color: var(--t-muted);
    font-size: var(--fs-sm);
    font-weight: 500;
    font-family: inherit;
    letter-spacing: 0.3px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    transition: all var(--ease);
    padding: 7px 0;
  }
  #settings-btn:hover {
    background: var(--s-hover);
    border-color: var(--b-visible);
    color: var(--t-primary);
    border-style: solid;
  }
  #settings-btn svg {
    width: 13px;
    height: 13px;
    stroke: currentColor;
    stroke-width: 2;
    fill: none;
  }

  .tag-add-input {
    font-size: var(--fs-sm);
    font-weight: 500;
    padding: 3px 10px;
    border-radius: var(--r-pill);
    background: var(--s-subtle);
    color: var(--t-secondary);
    border: 1px dashed var(--b-light);
    outline: none;
    width: 90px;
    transition: all var(--ease);
    font-family: inherit;
  }
  .tag-add-input::placeholder {
    color: var(--t-faint);
  }
  .tag-add-input:focus {
    border-color: var(--b-visible);
    background: var(--s-hover);
    width: 120px;
  }

  .detail-meta {
    font-size: 15px;
    color: rgba(255,255,255,0.3);
    line-height: 1.9;
  }

  .detail-meta span { color: rgba(255,255,255,0.55); font-weight: 500; }

  .detail-meta-row {
    display: flex;
    justify-content: space-between;
    padding: 3px 0;
    border-bottom: 1px solid rgba(255,255,255,0.03);
  }

  .detail-meta-row:last-child { border-bottom: none; }

  .meta-copy-btn {
    background: none;
    border: 1px solid transparent;
    color: var(--t-muted);
    cursor: pointer;
    padding: 2px 5px;
    border-radius: var(--r-small);
    font-size: var(--fs-xs);
    margin-left: 6px;
    transition: all var(--ease);
    line-height: 1;
  }
  .meta-copy-btn:hover {
    color: var(--t-primary);
    background: var(--s-hover);
    border-color: var(--b-light);
  }
  .meta-copy-btn.copied {
    color: var(--accent-blue);
  }

  .delete-confirm-no {
    background: var(--s-subtle);
    color: var(--t-muted);
  }
  .delete-confirm-no:hover {
    background: var(--s-hover);
    color: var(--t-primary);
  }

  /* ═══════════════════════════════════════════
     CAMERA HUD
     ═══════════════════════════════════════════ */
  #camera-hud {
    position: fixed;
    bottom: 70px;
    right: 24px;
    z-index: 100;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.4s;
    font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', monospace;
  }
  #camera-hud.visible { opacity: 1; pointer-events: auto; }
  #camera-hud.pinned { opacity: 1; pointer-events: auto; }
  #camera-hud.dragging { transition: none; }

  /* Outer card wrapping entire HUD */
  .cam-card {
    width: 140px;
    background: rgba(18,18,20,0.65);
    backdrop-filter: blur(24px);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 12px;
    padding: 12px 14px 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    position: relative;
  }

  /* Pin button for camera HUD */
  .cam-pin {
    position: absolute;
    top: 6px;
    right: 6px;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    background: transparent;
    border: 1px solid transparent;
    cursor: pointer;
    pointer-events: auto;
    opacity: 0;
    transition: opacity 0.2s, background 0.15s, border-color 0.15s;
    z-index: 5;
    padding: 0;
  }
  .cam-card:hover .cam-pin,
  #camera-hud.pinned .cam-pin { opacity: 1; }
  .cam-pin:hover {
    background: rgba(255,255,255,0.08);
    border-color: rgba(255,255,255,0.1);
  }
  .cam-pin svg {
    width: 11px;
    height: 11px;
    stroke: rgba(255,255,255,0.3);
    fill: none;
    stroke-width: 2;
    transform: rotate(45deg);
    transition: stroke 0.15s, fill 0.15s, transform 0.15s;
  }
  .cam-pin:hover svg { stroke: rgba(255,255,255,0.5); }
  #camera-hud.pinned .cam-pin svg {
    stroke: rgba(110,200,255,0.7);
    fill: rgba(110,200,255,0.15);
    transform: rotate(0deg);
  }

  /* Drag grip for camera HUD */
  .cam-drag-grip {
    width: 24px;
    height: 3px;
    border-radius: 2px;
    background: rgba(255,255,255,0.06);
    margin: -2px auto 0;
    cursor: grab;
    pointer-events: auto;
    transition: background 0.2s;
  }
  .cam-card:hover .cam-drag-grip { background: rgba(255,255,255,0.12); }
  .cam-drag-grip:active { cursor: grabbing; background: rgba(110,200,255,0.25); }

  /* Compass ring */
  .cam-compass {
    width: 80px;
    height: 80px;
    position: relative;
  }
  .cam-compass svg {
    width: 100%;
    height: 100%;
  }
  .compass-ring {
    fill: none;
    stroke: rgba(255,255,255,0.08);
    stroke-width: 1.5;
  }
  .compass-tick {
    stroke: rgba(255,255,255,0.2);
    stroke-width: 1;
  }
  .compass-tick-major {
    stroke: rgba(255,255,255,0.4);
    stroke-width: 1.5;
  }
  .compass-label {
    fill: rgba(255,255,255,0.35);
    font-size: 7px;
    font-weight: 600;
    text-anchor: middle;
    dominant-baseline: central;
  }
  .compass-label-n { fill: rgba(110,200,255,0.7); }
  .compass-needle {
    fill: rgba(110,200,255,0.6);
    transition: none;
  }
  .compass-center {
    fill: rgba(255,255,255,0.15);
  }
  .compass-fov {
    fill: rgba(110,200,255,0.06);
    stroke: rgba(110,200,255,0.15);
    stroke-width: 0.5;
  }

  /* Divider between compass and controls */
  .cam-divider {
    width: 100%;
    height: 1px;
    background: rgba(255,255,255,0.06);
  }

  /* Keys + altitude row */
  .cam-controls-row {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  /* QWEASD key indicator */
  .cam-keys {
    display: grid;
    grid-template-columns: repeat(3, 22px);
    grid-template-rows: repeat(2, 22px);
    gap: 2px;
  }
  .cam-key {
    width: 22px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.08);
    color: rgba(255,255,255,0.25);
    font-size: 9px;
    font-weight: 600;
    transition: background 0.1s, color 0.1s, border-color 0.1s, box-shadow 0.1s;
  }
  .cam-key.active {
    background: rgba(110,200,255,0.15);
    border-color: rgba(110,200,255,0.35);
    color: rgba(110,200,255,0.9);
    box-shadow: 0 0 8px rgba(110,200,255,0.15);
  }

  /* Altitude (vertical bar beside keys) */
  .cam-altitude {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
  }
  .alt-label {
    font-size: 8px;
    color: rgba(255,255,255,0.25);
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }
  .alt-bar-v {
    width: 3px;
    height: 32px;
    background: rgba(255,255,255,0.06);
    border-radius: 2px;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column-reverse;
  }
  .alt-fill-v {
    width: 100%;
    background: linear-gradient(0deg, rgba(110,200,255,0.4), rgba(110,200,255,0.7));
    border-radius: 2px;
    transition: height 0.1s;
  }
  .alt-value {
    font-size: 9px;
    color: rgba(255,255,255,0.4);
    font-variant-numeric: tabular-nums;
    min-width: 28px;
    text-align: center;
  }

  /* Speed indicator */
  .cam-speed {
    font-size: 9px;
    color: rgba(255,255,255,0.25);
    letter-spacing: 0.06em;
    text-align: center;
  }
  .cam-speed .boost { color: rgba(255,180,60,0.7); }

  /* ═══════════════════════════════════════════
     STATS BAR (bottom)
     ═══════════════════════════════════════════ */
  #stats-bar {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    padding: 8px 22px;
    display: flex;
    align-items: center;
    gap: 20px;
    font-size: 13px;
    font-weight: 500;
    color: rgba(255,255,255,0.35);
    letter-spacing: 0.03em;
  }

  .stat-value { color: rgba(255,255,255,0.6); font-weight: 600; }

  .stat-divider {
    width: 1px;
    height: 14px;
    background: rgba(255,255,255,0.08);
  }

  /* ═══════════════════════════════════════════
     LOADING STATE
     ═══════════════════════════════════════════ */
  #loading-overlay {
    position: fixed;
    inset: 0;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: #000000;
    transition: opacity 0.8s;
  }

  #loading-overlay.hidden {
    opacity: 0;
    pointer-events: none;
  }

  #loading-text {
    font-size: 15px;
    font-weight: 500;
    letter-spacing: 0.4em;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.45);
    animation: pulse 2.5s ease-in-out infinite;
  }

  #loading-sub {
    font-size: 15px;
    font-weight: 400;
    color: rgba(255,255,255,0.15);
    margin-top: 12px;
    letter-spacing: 0.1em;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.4; }
    50% { opacity: 1; }
  }

  /* Docker / Qdrant down state */
  #loading-overlay.error #loading-text { animation: none; opacity: 0.7; }
  #loading-overlay.error #loading-sub { color: rgba(255,255,255,0.3); }
  #loading-action {
    display: none;
    margin-top: 24px;
    text-align: center;
  }
  #loading-overlay.error #loading-action { display: block; }
  #loading-action-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 10px 24px;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.15);
    color: rgba(255,255,255,0.7);
    border-radius: 8px;
    font-size: 13px;
    font-family: inherit;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    letter-spacing: 0.05em;
  }
  #loading-action-btn:hover {
    background: rgba(255,255,255,0.12);
    border-color: rgba(255,255,255,0.25);
    color: rgba(255,255,255,0.9);
  }
  #loading-action-btn:disabled {
    opacity: 0.4;
    cursor: wait;
  }
  #loading-action-btn svg { width: 16px; height: 16px; fill: none; stroke: currentColor; stroke-width: 2; }
  #loading-action-status {
    margin-top: 10px;
    font-size: 11px;
    color: rgba(255,255,255,0.25);
    letter-spacing: 0.05em;
  }

  /* Server offline — mascot + start command */
  #loading-mascot {
    display: none;
    margin-bottom: 28px;
    position: relative;
    animation: mascot-sleep 4s ease-in-out infinite;
  }
  #loading-overlay.server-offline #loading-mascot { display: block; }
  @keyframes mascot-sleep {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-4px); }
  }
  #loading-zzz {
    position: absolute;
    top: -2px;
    right: -18px;
    font-size: 16px;
    opacity: 0;
    animation: zzz-float 3s ease-in-out infinite;
  }
  @keyframes zzz-float {
    0% { opacity: 0; transform: translate(0, 0) scale(0.7); }
    15% { opacity: 0.35; }
    60% { opacity: 0.2; transform: translate(8px, -18px) scale(1); }
    100% { opacity: 0; transform: translate(14px, -30px) scale(1.1); }
  }
  #loading-server-cmd {
    display: none;
    margin-top: 28px;
    text-align: center;
  }
  #loading-overlay.server-offline #loading-server-cmd { display: block; }
  #loading-server-cmd-hint {
    font-size: 12px;
    color: rgba(255,255,255,0.25);
    letter-spacing: 0.08em;
    margin-bottom: 12px;
  }
  #loading-server-cmd-box {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    padding: 10px 16px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.10);
    border-radius: 8px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    color: rgba(255,255,255,0.6);
    user-select: all;
  }
  #loading-cmd-copy {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 6px;
    cursor: pointer;
    color: rgba(255,255,255,0.4);
    transition: all 0.2s;
    flex-shrink: 0;
  }
  #loading-cmd-copy:hover {
    background: rgba(255,255,255,0.12);
    color: rgba(255,255,255,0.8);
    border-color: rgba(255,255,255,0.22);
  }
  #loading-cmd-copy svg { width: 14px; height: 14px; fill: none; stroke: currentColor; stroke-width: 2; }
  #loading-retry-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    margin-top: 18px;
    padding: 8px 20px;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.12);
    color: rgba(255,255,255,0.45);
    border-radius: 8px;
    font-size: 12px;
    font-family: inherit;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    letter-spacing: 0.06em;
  }
  #loading-retry-btn:hover {
    background: rgba(255,255,255,0.10);
    border-color: rgba(255,255,255,0.22);
    color: rgba(255,255,255,0.7);
  }
  #loading-retry-btn svg { width: 14px; height: 14px; fill: none; stroke: currentColor; stroke-width: 2; }
  #loading-retry-status {
    margin-top: 8px;
    font-size: 11px;
    color: rgba(255,255,255,0.2);
    letter-spacing: 0.05em;
    min-height: 16px;
  }

  /* ═══════════════════════════════════════════
     TOOLTIP
     ═══════════════════════════════════════════ */
  #tooltip {
    position: fixed;
    z-index: 200;
    padding: 10px 18px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.15s;
    font-size: 15px;
    max-width: 320px;
  }

  #tooltip.visible { opacity: 1; }
  #tooltip-category { font-size: 13px; letter-spacing: 0.15em; text-transform: uppercase; }
  #tooltip-preview { color: rgba(255,255,255,0.6); margin-top: 5px; font-size: 14px; line-height: 1.45; }
  #tooltip-importance { color: #FFD700; font-size: 14px; margin-top: 4px; }

  /* ── Multi-select action bar ── */
  #multi-select-bar {
    position: fixed;
    top: 62px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 95;
    padding: 8px 18px;
    display: none;
    gap: 12px;
    align-items: center;
    font-size: 13px;
    color: var(--t-primary);
  }
  #multi-select-bar.open { display: flex; }
  #multi-select-bar button {
    font-size: 12px;
    font-weight: 500;
    font-family: inherit;
    padding: 4px 12px;
    border-radius: var(--r-small);
    border: 1px solid var(--b-subtle);
    background: var(--s-subtle);
    color: var(--t-secondary);
    cursor: pointer;
    transition: all var(--ease);
  }
  #multi-select-bar button:hover {
    background: var(--s-hover);
    color: var(--t-bright);
    border-color: var(--b-hover);
  }

  /* ── 3D Controls Reference Panel ── */
  #controls-panel {
    position: fixed;
    bottom: 52px;
    right: 12px;
    width: 190px;
    z-index: 90;
    border-radius: 10px;
    overflow: hidden;
    background: rgba(28,28,30,0.72);
    backdrop-filter: blur(40px) saturate(1.4);
    -webkit-backdrop-filter: blur(40px) saturate(1.4);
    border: 1px solid rgba(255,255,255,0.06);
    box-shadow: 0 2px 20px rgba(0,0,0,0.4);
    padding: 12px 14px;
    transition: opacity 0.2s;
    display: none;
  }
  #controls-panel.visible { display: block; }
  #controls-panel .ctrl-title {
    font-size: 9px;
    font-weight: 600;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: rgba(255,255,255,0.25);
    margin-bottom: 8px;
  }
  #controls-panel .ctrl-section {
    margin-bottom: 8px;
  }
  #controls-panel .ctrl-section:last-child { margin-bottom: 0; }
  #controls-panel .ctrl-section-label {
    font-size: 8px;
    font-weight: 600;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: rgba(255,255,255,0.15);
    margin-bottom: 5px;
  }
  #controls-panel .ctrl-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 3px;
  }
  #controls-panel .ctrl-row:last-child { margin-bottom: 0; }
  #controls-panel .ctrl-keys {
    display: flex;
    gap: 2px;
    flex-shrink: 0;
  }
  #controls-panel .ctrl-key {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-width: 20px;
    height: 18px;
    padding: 0 4px;
    font-size: 9px;
    font-weight: 600;
    font-family: 'SF Mono', 'Fira Code', monospace;
    color: rgba(255,255,255,0.45);
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 3px;
  }
  #controls-panel .ctrl-desc {
    font-size: 10px;
    color: rgba(255,255,255,0.3);
    white-space: nowrap;
  }
</style>
</head>
<body>

<!-- Loading -->
<div id="loading-overlay">
  <div id="loading-mascot">
    <svg viewBox="0 0 280 140" width="160" height="80" style="overflow:visible">
      <!-- Left eye (closed/sleeping) -->
      <g class="syna-eye">
        <g class="syna-lid" transform="translate(0,60) scale(1,0.08) translate(0,-60)">
          <rect x="80" y="24" width="38" height="72" rx="19" fill="#ffffff"/>
        </g>
      </g>
      <!-- Right eye (closed/sleeping) -->
      <g class="syna-eye">
        <g class="syna-lid" transform="translate(0,60) scale(1,0.08) translate(0,-60)">
          <rect x="162" y="24" width="38" height="72" rx="19" fill="#ffffff"/>
        </g>
      </g>
      <!-- Mouth (neutral) -->
      <path d="M125,112 Q140,118 155,112" fill="none" stroke="rgba(255,255,255,0.15)" stroke-width="2.5" stroke-linecap="round"/>
    </svg>
    <span id="loading-zzz">z</span>
  </div>
  <div id="loading-text">Connecting</div>
  <div id="loading-sub">Initializing neural pathways...</div>
  <div id="loading-action">
    <button id="loading-action-btn" type="button">
      <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>
      <span id="loading-action-label">Start Docker</span>
    </button>
    <div id="loading-action-status"></div>
  </div>
  <div id="loading-server-cmd">
    <div id="loading-server-cmd-hint">Run this command to start the server:</div>
    <div id="loading-server-cmd-box">
      <code id="loading-cmd-text">node J:\Sites\Apps\Synabun\neural-interface\server.js</code>
      <button id="loading-cmd-copy" title="Copy to clipboard">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
      </button>
    </div>
    <br>
    <button id="loading-retry-btn" type="button">
      <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/></svg>
      Retry Connection
    </button>
    <div id="loading-retry-status"></div>
    <img src="synabun.png?v=2" alt="SynaBun" style="margin-top:6px;height:32px;width:auto;filter:grayscale(0.5);opacity:0.18;">
  </div>
</div>

<!-- Tooltip -->
<div id="tooltip" class="glass">
  <div id="tooltip-category"></div>
  <div id="tooltip-preview"></div>
  <div id="tooltip-importance"></div>
</div>

<!-- Top Menu Bar (unified) -->
<div id="title-bar">
  <!-- Left: Logo + View Controls -->
  <div class="bar-left">
    <img src="synabun.png?v=2" alt="SynaBun" style="height:24px;width:auto;opacity:0.7;">
    <div class="bar-sep"></div>
    <div class="view-toggle">
      <a class="view-toggle-btn active" href="#">3D</a>
      <a class="view-toggle-btn" href="/index2d.html" id="view-switch-2d">2D</a>
    </div>
    <div class="bar-sep"></div>
    <button id="toggle-links-btn" class="bar-pill" data-tooltip="Toggle links: Off / Intra / All">All Links</button>
    <button id="link-type-btn" class="bar-pill" data-tooltip="Filter by connection type">Show: All Types</button>
    <button id="reset-positions-btn" class="bar-pill">Reset Layout</button>
    <div class="bar-sep"></div>
    <button id="controls-toggle-btn" class="bar-pill" data-tooltip="Toggle 3D controls reference (C)">3D Controls</button>
    <div class="bar-sep"></div>
    <button id="toggle-categories-btn" class="toolbar-btn active"><svg viewBox="0 0 24 24"><circle cx="5" cy="6" r="2"/><circle cx="5" cy="12" r="2"/><circle cx="5" cy="18" r="2"/><line x1="10" y1="6" x2="21" y2="6"/><line x1="10" y1="12" x2="21" y2="12"/><line x1="10" y1="18" x2="21" y2="18"/></svg>Categories</button>
    <div style="position:relative">
      <button id="bookmarks-btn" class="toolbar-btn"><svg viewBox="0 0 24 24"><path d="M5 5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16l-7-4-7 4V5z"/></svg>Bookmarks<span class="count-badge count-badge--gold" id="bookmark-count"></span></button>
      <div id="bookmarks-panel" class="glass dropdown-panel">
        <div id="bookmarks-list"></div>
      </div>
    </div>
    <div style="position:relative">
      <button id="layouts-btn" class="toolbar-btn">Layouts</button>
      <div id="layouts-panel" class="glass dropdown-panel">
        <div class="preset-save-bar">
          <input type="text" id="preset-name-input" placeholder="Layout name..." autocomplete="off" spellcheck="false" maxlength="40">
          <button id="preset-save-btn">Save</button>
        </div>
        <div class="preset-warning" id="preset-warning">No pinned nodes to save</div>
        <div class="preset-list" id="preset-list"></div>
      </div>
    </div>
  </div>

  <!-- Center: Search -->
  <div class="bar-center" id="search-container">
    <div id="search-wrapper">
      <input type="text" id="search-input" placeholder="Search memories..." autocomplete="off" spellcheck="false">
      <span id="search-badge"></span>
      <button id="search-clear">&times;</button>
    </div>
  </div>

  <!-- Right: Utility Icons -->
  <div class="bar-right">
    <button id="help-btn" class="bar-icon" data-tooltip="Shortcuts">?</button>
    <button id="titlebar-trash-btn" class="bar-icon" data-tooltip="Trash"><svg viewBox="0 0 24 24"><path d="M3 6h18"/><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><path d="M19 6l-.7 12.1a2 2 0 0 1-2 1.9H7.7a2 2 0 0 1-2-1.9L5 6"/></svg><span class="count-badge count-badge--red" id="titlebar-trash-count"></span></button>
    <button id="titlebar-settings-btn" class="bar-icon" data-tooltip="Settings"><svg viewBox="0 0 24 24"><path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg></button>
  </div>
</div>

<!-- Help Modal -->
<div id="help-overlay">
  <div id="help-modal" class="glass" style="position:relative;">
    <button id="help-close">&times;</button>
    <h2>Controls</h2>

    <div class="help-section">
      <div class="help-section-title">Keyboard</div>
      <div class="help-row"><div class="help-keys"><span class="help-key">/</span></div><span class="help-desc">Focus search</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Esc</span></div><span class="help-desc">Close panel / clear search</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Enter</span></div><span class="help-desc">Save layout (when naming)</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">?</span></div><span class="help-desc">Toggle this help</span></div>
    </div>

    <div class="help-section">
      <div class="help-section-title">Mouse &mdash; Graph</div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Click</span><span class="help-key">Node</span></div><span class="help-desc">Select &amp; inspect memory</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Drag</span><span class="help-key">Node</span></div><span class="help-desc">Move &amp; pin node in place</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Hover</span><span class="help-key">Node</span></div><span class="help-desc">Show tooltip preview</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Click</span><span class="help-key">Background</span></div><span class="help-desc">Deselect / close detail panel</span></div>
    </div>

    <div class="help-section">
      <div class="help-section-title">Mouse &mdash; Camera (Orbit)</div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Left Drag</span></div><span class="help-desc">Rotate camera</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Right Drag</span></div><span class="help-desc">Pan camera</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Scroll</span></div><span class="help-desc">Zoom in / out</span></div>
    </div>

    <div class="help-section">
      <div class="help-section-title">Keyboard &mdash; Camera (Fly)</div>
      <div class="help-row"><div class="help-keys"><span class="help-key">W</span><span class="help-key">A</span><span class="help-key">S</span><span class="help-key">D</span></div><span class="help-desc">Move forward / left / back / right</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Q</span></div><span class="help-desc">Move down</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">E</span> / <span class="help-key">Space</span></div><span class="help-desc">Move up</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Shift</span></div><span class="help-desc">Boost speed (3x)</span></div>
    </div>

    <div class="help-section">
      <div class="help-section-title">Panels</div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Drag</span><span class="help-key">Grip</span></div><span class="help-desc">Move panel</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Drag</span><span class="help-key">Edge</span></div><span class="help-desc">Resize panel</span></div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Pin</span><span class="help-key">&#x1F4CC;</span></div><span class="help-desc">Lock panel position &amp; size</span></div>
    </div>

    <div class="help-section">
      <div class="help-section-title">Sidebar</div>
      <div class="help-row"><div class="help-keys"><span class="help-key">Click</span><span class="help-key">Category</span></div><span class="help-desc">Toggle category visibility</span></div>
    </div>
  </div>
</div>

<!-- (Search in .bar-center, Bookmarks + Layouts in .bar-left) -->

<!-- Category Sidebar -->
<div id="category-sidebar" class="glass resizable">
  <div class="resize-handle resize-handle-t" data-resize="t"></div>
  <div class="resize-handle resize-handle-b" data-resize="b"></div>
  <div class="resize-handle resize-handle-l" data-resize="l"></div>
  <div class="resize-handle resize-handle-r" data-resize="r"></div>
  <div class="resize-handle resize-handle-tl" data-resize="tl"></div>
  <div class="resize-handle resize-handle-tr" data-resize="tr"></div>
  <div class="resize-handle resize-handle-bl" data-resize="bl"></div>
  <div class="resize-handle resize-handle-br" data-resize="br"></div>
  <div class="sidebar-header drag-handle" data-drag="category-sidebar">
    <div class="sidebar-header-actions">
      <button class="detail-action-btn" id="category-select-all-btn" data-tooltip="Select all"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="3"/><polyline points="9 12 11 14 16 9"/></svg></button>
      <button class="detail-action-btn" id="category-clear-btn" data-tooltip="Deselect all"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="3"/><line x1="9" y1="9" x2="15" y2="15"/><line x1="15" y1="9" x2="9" y2="15"/></svg></button>
      <div class="detail-action-sep"></div>
      <button class="detail-action-btn" id="label-toggle-btn" data-tooltip="Toggle labels"><svg viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg></button>
      <button class="detail-action-btn" id="label-size-btn" data-tooltip="Label size"><svg viewBox="0 0 24 24"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg></button>
      <div class="detail-action-sep"></div>
      <button class="detail-action-btn pin-btn" data-pin="category-sidebar" data-tooltip="Pin"><svg viewBox="0 0 24 24"><path d="M9 4v4.5L7.5 10H6v2h4v7l2 1 2-1v-7h4v-2h-1.5L15 8.5V4H9z" stroke-linejoin="round" stroke-linecap="round"/></svg></button>
      <button class="detail-action-btn detail-action-btn--close" id="sidebar-close" data-tooltip="Close">&times;</button>
    </div>
    <div class="sidebar-header-title">Categories</div>
  </div>
  <div id="category-sidebar-body">
  <div id="sidebar-label-controls">
    <input type="range" id="label-size-slider" min="0.3" max="2.5" step="0.1" value="1.0" style="flex:1;height:3px;accent-color:var(--t-muted);cursor:pointer;opacity:0;transition:opacity 0.2s;pointer-events:none;" data-tooltip="Label size">
  </div>
  <div id="category-list"></div>
  <div style="display:flex;gap:8px;padding:0 12px;margin-bottom:8px;">
    <button id="category-add-btn" style="flex:1;" data-tooltip="Add category"><svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>Category</button>
    <button id="category-add-parent-btn" style="flex:1;" data-tooltip="Add parent"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>Parent</button>
  </div>
  <div style="display:flex;gap:8px;padding:0 12px;margin-bottom:8px;">
    <button id="settings-btn" style="flex:1;" data-tooltip="Settings"><svg viewBox="0 0 24 24"><path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>Settings</button>
  </div>
  <div id="category-create-form" data-mode="child">
    <div id="cat-form-title" style="font-weight:600;padding:8px 12px 4px;color:#aaa;font-size:11px;text-transform:uppercase;letter-spacing:0.5px;">Create Category</div>
    <input class="category-create-input" id="cat-name-input" placeholder="category-name" maxlength="30" spellcheck="false">
    <input class="category-create-input" id="cat-desc-input" placeholder="Short description...">
    <select class="modal-select" id="cat-parent-select">
      <option value="">(None - standalone category)</option>
    </select>
    <div class="color-swatch-row" id="color-swatch-row"></div>
    <div class="category-form-error" id="cat-form-error"></div>
    <div class="category-form-actions">
      <button class="category-form-btn-cancel" id="cat-form-cancel">Cancel</button>
      <button class="category-form-btn-create" id="cat-form-create" disabled>Create</button>
    </div>
  </div>
  </div><!-- /category-sidebar-body -->
</div>

<!-- Detail Panel -->
<div id="detail-panel" class="glass resizable">
  <div class="resize-handle resize-handle-t" data-resize="t"></div>
  <div class="resize-handle resize-handle-b" data-resize="b"></div>
  <div class="resize-handle resize-handle-l" data-resize="l"></div>
  <div class="resize-handle resize-handle-r" data-resize="r"></div>
  <div class="resize-handle resize-handle-tl" data-resize="tl"></div>
  <div class="resize-handle resize-handle-tr" data-resize="tr"></div>
  <div class="resize-handle resize-handle-bl" data-resize="bl"></div>
  <div class="resize-handle resize-handle-br" data-resize="br"></div>
  <!-- Header -->
  <div class="detail-header drag-handle" data-drag="detail-panel">
    <div class="detail-header-actions">
      <button class="detail-action-btn" id="content-edit-btn" data-tooltip="Edit"><svg viewBox="0 0 24 24"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg></button>
      <button class="detail-action-btn detail-action-btn--gold" id="detail-bookmark-btn" data-tooltip="Bookmark"><svg viewBox="0 0 24 24"><path d="M5 5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16l-7-4-7 4V5z"/></svg></button>
      <button class="detail-action-btn" id="detail-change-cat-btn" data-tooltip="Move"><svg viewBox="0 0 24 24"><path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"/><polyline points="10 17 15 12 10 7"/><line x1="15" y1="12" x2="3" y2="12"/></svg></button>
      <button class="detail-action-btn" id="detail-export-md-btn" data-tooltip="Export MD"><svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></button>
      <button class="detail-action-btn detail-action-btn--danger" id="detail-delete-inline-btn" data-tooltip="Delete"><svg viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/></svg></button>
      <div class="detail-action-sep"></div>
      <button class="detail-action-btn pin-btn" data-pin="detail-panel" data-tooltip="Pin"><svg viewBox="0 0 24 24"><path d="M9 4v4.5L7.5 10H6v2h4v7l2 1 2-1v-7h4v-2h-1.5L15 8.5V4H9z" stroke-linejoin="round" stroke-linecap="round"/></svg></button>
      <button class="detail-action-btn detail-action-btn--close" id="detail-close" data-tooltip="Close">&times;</button>
    </div>
    <div class="detail-header-category">
      <div class="detail-header-dot" id="detail-header-dot"></div>
      <span class="detail-header-name" id="detail-category-label"></span>
    </div>
  </div>

  <!-- Body -->
  <div class="detail-body">
    <div class="detail-subheader">
      <div id="detail-importance"></div>
      <button class="detail-chip" id="detail-focus-btn" data-tooltip="Show only linked memories"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"/><path d="M12 2v4m0 12v4m-7.07-14.93l2.83 2.83m8.48 8.48l2.83 2.83M2 12h4m12 0h4M4.93 4.93l2.83 2.83m8.48 8.48l2.83 2.83"/></svg>Linked</button>
    </div>
    <div class="content-edit-wrap">
      <div id="detail-content"></div>
    </div>
    <div id="detail-tags" class="detail-section">
      <div class="detail-label">Tags</div>
      <div class="tag-chips" id="detail-tag-chips"></div>
    </div>
    <div id="detail-meta" class="detail-section">
      <div class="detail-label">Metadata</div>
      <div class="detail-meta" id="detail-meta-content"></div>
    </div>
    <div id="detail-files" class="detail-section" style="display:none">
      <div class="detail-label">Related Files</div>
      <div class="detail-meta" id="detail-files-content"></div>
    </div>
  </div>
</div>

<!-- Camera HUD -->
<div id="camera-hud">
  <div class="cam-card">
    <!-- Pin button -->
    <button class="cam-pin" id="cam-pin-btn" title="Pin HUD"><svg viewBox="0 0 24 24"><path d="M9 4v4.5L7.5 10H6v2h4v7l2 1 2-1v-7h4v-2h-1.5L15 8.5V4H9z" stroke-linejoin="round" stroke-linecap="round"/></svg></button>

    <!-- Drag grip -->
    <div class="cam-drag-grip" id="cam-drag-grip"></div>

    <!-- Compass -->
    <div class="cam-compass">
      <svg viewBox="0 0 72 72">
        <circle class="compass-ring" cx="36" cy="36" r="32"/>
        <g id="compass-ticks"></g>
        <path id="compass-fov" class="compass-fov" d=""/>
        <polygon id="compass-needle" class="compass-needle" points="36,8 34,16 38,16"/>
        <circle class="compass-center" cx="36" cy="36" r="2.5"/>
        <text class="compass-label compass-label-n" x="36" y="6">N</text>
        <text class="compass-label" x="66" y="37">E</text>
        <text class="compass-label" x="36" y="69">S</text>
        <text class="compass-label" x="6" y="37">W</text>
      </svg>
    </div>

    <div class="cam-divider"></div>

    <!-- Keys + Altitude side-by-side -->
    <div class="cam-controls-row">
      <!-- QWEASD keys -->
      <div class="cam-keys">
        <div class="cam-key" id="key-q">Q</div>
        <div class="cam-key" id="key-w">W</div>
        <div class="cam-key" id="key-e">E</div>
        <div class="cam-key" id="key-a">A</div>
        <div class="cam-key" id="key-s">S</div>
        <div class="cam-key" id="key-d">D</div>
      </div>

      <!-- Vertical altitude bar -->
      <div class="cam-altitude">
        <span class="alt-label">ALT</span>
        <div class="alt-bar-v"><div class="alt-fill-v" id="alt-fill"></div></div>
        <span class="alt-value" id="alt-value">0</span>
      </div>
    </div>

    <!-- Speed -->
    <div class="cam-speed" id="cam-speed-label">MOVE</div>
  </div>
</div>

<!-- Multi-select action bar -->
<div id="multi-select-bar" class="glass">
  <span id="multi-select-count">0 selected</span>
  <button id="multi-select-export">Export</button>
  <button id="multi-select-trash">Trash</button>
  <button id="multi-select-clear">Clear</button>
</div>

<!-- 3D Controls Reference Panel -->
<div id="controls-panel">
  <div class="ctrl-title">3D Controls</div>
  <div class="ctrl-section">
    <div class="ctrl-section-label">Movement</div>
    <div class="ctrl-row"><div class="ctrl-keys"><span class="ctrl-key">W</span><span class="ctrl-key">A</span><span class="ctrl-key">S</span><span class="ctrl-key">D</span></div><span class="ctrl-desc">Move</span></div>
    <div class="ctrl-row"><div class="ctrl-keys"><span class="ctrl-key">Q</span></div><span class="ctrl-desc">Down</span></div>
    <div class="ctrl-row"><div class="ctrl-keys"><span class="ctrl-key">E</span></div><span class="ctrl-desc">Up</span></div>
    <div class="ctrl-row"><div class="ctrl-keys"><span class="ctrl-key">Shift</span></div><span class="ctrl-desc">Boost 3x</span></div>
  </div>
  <div class="ctrl-section">
    <div class="ctrl-section-label">Camera</div>
    <div class="ctrl-row"><div class="ctrl-keys"><span class="ctrl-key">L-Drag</span></div><span class="ctrl-desc">Rotate</span></div>
    <div class="ctrl-row"><div class="ctrl-keys"><span class="ctrl-key">R-Drag</span></div><span class="ctrl-desc">Pan</span></div>
    <div class="ctrl-row"><div class="ctrl-keys"><span class="ctrl-key">Scroll</span></div><span class="ctrl-desc">Zoom</span></div>
  </div>
</div>

<!-- Stats Bar -->
<div id="stats-bar" class="glass">
  <div>Memories: <span class="stat-value" id="stat-total">0</span></div>
  <div class="stat-divider"></div>
  <div>Visible: <span class="stat-value" id="stat-visible">0</span></div>
  <div class="stat-divider"></div>
  <div>Links: <span class="stat-value" id="stat-links">0</span></div>
  <div class="stat-divider"></div>
  <div id="stat-search-status"></div>
</div>

<!-- Graph -->
<div id="graph-container"></div>

<script type="module">
// ═══════════════════════════════════════════
// IMPORTS (all ESM, pinned Three.js version)
// ═══════════════════════════════════════════
import * as THREE from 'https://esm.sh/three@0.169.0';
import ForceGraph3D from 'https://esm.sh/3d-force-graph@1.73.4?deps=three@0.169.0';
import { UnrealBloomPass } from 'https://esm.sh/three@0.169.0/examples/jsm/postprocessing/UnrealBloomPass.js';
import TWEEN from 'https://esm.sh/@tweenjs/tween.js@23.1.3';

// ═══════════════════════════════════════════
// TOOLTIP SYSTEM (body-appended, overflow-proof)
// ═══════════════════════════════════════════
{
  const tip = document.createElement('div');
  tip.className = 'ui-tooltip';
  tip.innerHTML = '<span class="ui-tooltip-arrow"></span><span class="ui-tooltip-text"></span>';
  document.body.appendChild(tip);

  let showTimer = null;
  let hideTimer = null;
  let currentTarget = null;

  function positionTip(el) {
    const r = el.getBoundingClientRect();
    const tw = tip.offsetWidth;
    const th = tip.offsetHeight;
    const gap = 8;
    let top = r.top - th - gap;
    let placement = 'above';
    if (top < 4) {
      top = r.bottom + gap;
      placement = 'below';
    }
    let left = r.left + r.width / 2 - tw / 2;
    if (left < 4) left = 4;
    if (left + tw > window.innerWidth - 4) left = window.innerWidth - 4 - tw;
    tip.className = 'ui-tooltip ' + placement;
    tip.style.top = top + 'px';
    tip.style.left = left + 'px';
    const arrowLeft = r.left + r.width / 2 - left;
    tip.querySelector('.ui-tooltip-arrow').style.left = arrowLeft + 'px';
    tip.querySelector('.ui-tooltip-arrow').style.transform = 'translateX(-50%)';
  }

  function show(el) {
    const text = el.getAttribute('data-tooltip');
    if (!text) return;
    clearTimeout(hideTimer);
    tip.querySelector('.ui-tooltip-text').textContent = text;
    currentTarget = el;
    tip.style.display = 'block';
    tip.offsetHeight; // force reflow
    positionTip(el);
    tip.classList.add('visible');
  }

  function hide() {
    clearTimeout(showTimer);
    clearTimeout(hideTimer);
    showTimer = null;
    currentTarget = null;
    tip.classList.remove('visible');
    hideTimer = setTimeout(() => { tip.style.display = 'none'; }, 150);
  }

  // mouseover/mouseout bubble through children — reliable for delegation
  document.addEventListener('mouseover', (e) => {
    const el = e.target.closest('[data-tooltip]');
    if (!el) return;
    // Already tracking this element — cancel any pending hide
    if (el === currentTarget) { clearTimeout(hideTimer); return; }
    clearTimeout(showTimer);
    clearTimeout(hideTimer);
    // If switching between tooltip targets, show immediately
    if (currentTarget) {
      hide();
      show(el);
    } else {
      showTimer = setTimeout(() => show(el), 300);
    }
  });

  document.addEventListener('mouseout', (e) => {
    const el = e.target.closest('[data-tooltip]');
    if (!el) return;
    // Check if we're moving to another child of the same tooltip target
    const related = e.relatedTarget;
    if (related && el.contains(related)) return;
    hide();
  });

  document.addEventListener('scroll', hide, true);
  document.addEventListener('pointerdown', hide, true);
}

// ═══════════════════════════════════════════
// CONSTANTS
// ═══════════════════════════════════════════
const DEFAULT_COLOR = '#888888';

const COLOR_PALETTE = [
  '#7BA3C4', '#8AAF7A', '#C4A84E', '#C08050', '#6BAABE',
  '#9A9A9A', '#6B8AC4', '#C47A8E', '#C4AA5E', '#A870B8',
  '#5EA898', '#C47A5E', '#7E6AAE', '#5EB0B8', '#B0B85E',
  '#B06A4E', '#6AB898', '#B090C0', '#C4A060', '#60A0B8',
  '#90B060', '#50A8B8', '#9080B0', '#C06868', '#A05050',
  '#60B8A8', '#6A80B8', '#C06080',
];

// All known category names (fetched from server)
let allCategoryNames = [];
let categoryDescriptions = {};

function catColor(category) {
  // 1. User override from localStorage (highest priority)
  try {
    const overrides = JSON.parse(localStorage.getItem('neural-category-colors') || '{}');
    if (overrides[category]) return overrides[category];
  } catch {}
  // 2. Backend color from category metadata
  if (categoryMetadata[category]?.color) {
    return categoryMetadata[category].color;
  }
  // 3. Index-based from palette (deterministic — same position = same color)
  const idx = allCategoryNames.indexOf(category);
  if (idx >= 0) return COLOR_PALETTE[idx % COLOR_PALETTE.length];
  // 4. Hash-based fallback for unknown categories
  let hash = 0;
  for (let i = 0; i < category.length; i++) hash = ((hash << 5) - hash + category.charCodeAt(i)) | 0;
  return COLOR_PALETTE[Math.abs(hash) % COLOR_PALETTE.length];
}

/**
 * Replace a native <select> with a styled custom dropdown.
 * Keeps the hidden <select> synced so .value still works.
 * Adds category color dots via catColor() when values match categories.
 */
function upgradeSelect(selectEl) {
  if (!selectEl) return null;

  // If already upgraded, refresh the existing wrapper
  if (selectEl.dataset.upgraded) {
    const existing = selectEl.closest('.styled-select');
    if (existing && existing._refresh) { existing._refresh(); return existing; }
  }

  selectEl.dataset.upgraded = '1';
  selectEl.style.display = 'none';

  const wrapper = document.createElement('div');
  wrapper.className = 'styled-select';

  const trigger = document.createElement('button');
  trigger.type = 'button';
  trigger.className = 'styled-select-trigger';

  const menu = document.createElement('div');
  menu.className = 'styled-select-menu';

  function updateTrigger() {
    trigger.innerHTML = '';
    const sel = selectEl.options[selectEl.selectedIndex];
    if (sel && sel.value) {
      const dot = document.createElement('span');
      dot.className = 'styled-select-dot';
      dot.style.background = catColor(sel.value);
      trigger.appendChild(dot);
    }
    const lbl = document.createElement('span');
    lbl.className = 'styled-select-label';
    lbl.textContent = sel ? sel.textContent : '';
    trigger.appendChild(lbl);
  }

  function buildOptions() {
    menu.innerHTML = '';
    Array.from(selectEl.options).forEach(opt => {
      const row = document.createElement('div');
      row.className = 'styled-select-option' + (opt.value === selectEl.value ? ' active' : '');
      if (opt.value) {
        const dot = document.createElement('span');
        dot.className = 'styled-select-dot';
        dot.style.background = catColor(opt.value);
        row.appendChild(dot);
      }
      const lbl = document.createElement('span');
      lbl.textContent = opt.textContent;
      row.appendChild(lbl);
      row.addEventListener('click', () => {
        selectEl.value = opt.value;
        selectEl.dispatchEvent(new Event('change', { bubbles: true }));
        updateTrigger();
        buildOptions();
        wrapper.classList.remove('open');
      });
      menu.appendChild(row);
    });
  }

  trigger.addEventListener('click', (e) => {
    e.stopPropagation();
    // Close any other open styled selects first
    document.querySelectorAll('.styled-select.open').forEach(s => {
      if (s !== wrapper) s.classList.remove('open');
    });
    const opening = wrapper.classList.toggle('open');
    if (opening) buildOptions();
  });

  document.addEventListener('click', (e) => {
    if (!wrapper.contains(e.target)) wrapper.classList.remove('open');
  });

  selectEl.parentNode.insertBefore(wrapper, selectEl);
  wrapper.appendChild(trigger);
  wrapper.appendChild(menu);
  wrapper.appendChild(selectEl);

  wrapper._refresh = () => { updateTrigger(); buildOptions(); };
  updateTrigger();
  return wrapper;
}

function hexAlpha(hex, alpha) {
  const c = parseInt(hex.replace('#', ''), 16);
  return `rgba(${(c >> 16) & 255},${(c >> 8) & 255},${c & 255},${alpha})`;
}

function importanceToRadius(importance) {
  return 2 + (importance - 1) * 0.5; // 2 to 6.5
}

// ═══════════════════════════════════════════
// GRAPH CONFIG (persisted to localStorage)
// ═══════════════════════════════════════════
const GFX_DEFAULTS = {
  // Physics
  chargeStrength: -80,
  linkDistanceBase: 50,
  alphaDecay: 0.025,
  velocityDecay: 0.35,
  // Links
  linkOpacity: 0.08,
  linkCurvatureBase: 0.15,
  linkGlowOpacity: 0.06,
  linkGlowStrength: 0.10,
  // Node visuals
  coreOpacity: 0.7,
  glowOpacity: 0.4,
  glowScale: 4.5,
  colorDarken: 0.5,
  // Camera
  clickZoom: 120,
  gentleZoom: 180,
  // Selection
  selectedGlow: 1.4,
  selectedScale: 1.3,
  // Background
  bgIntensity: 0.5,
  bgParticleCount: 2000,
  bgTheme: 'deep-grid',
  floorStyle: 'grid', // 'grid' | 'dots' | 'hex' | 'ripples' | 'fog' | 'none'
};

// Graphics quality presets
const GFX_PRESETS = {
  low: {
    label: 'Low', icon: '🍃', desc: 'Battery saver',
    values: {
      chargeStrength: -50, linkDistanceBase: 40, alphaDecay: 0.04, velocityDecay: 0.4,
      linkOpacity: 0.05, linkCurvatureBase: 0, linkGlowOpacity: 0, linkGlowStrength: 0,
      coreOpacity: 0.5, glowOpacity: 0.15, glowScale: 3,
      colorDarken: 0.5, clickZoom: 120, gentleZoom: 180,
      selectedGlow: 0.8, selectedScale: 1.15,
      bgIntensity: 0.2, bgParticleCount: 800, bgTheme: 'deep-grid', floorStyle: 'grid',
    },
  },
  medium: {
    label: 'Medium', icon: '✨', desc: 'Balanced',
    values: {
      chargeStrength: -80, linkDistanceBase: 50, alphaDecay: 0.025, velocityDecay: 0.35,
      linkOpacity: 0.08, linkCurvatureBase: 0.15, linkGlowOpacity: 0.06, linkGlowStrength: 0.10,
      coreOpacity: 0.7, glowOpacity: 0.4, glowScale: 4.5,
      colorDarken: 0.5, clickZoom: 120, gentleZoom: 180,
      selectedGlow: 1.4, selectedScale: 1.3,
      bgIntensity: 0.5, bgParticleCount: 2000, bgTheme: 'deep-grid', floorStyle: 'grid',
    },
  },
  high: {
    label: 'High', icon: '🔮', desc: 'Rich visuals',
    values: {
      chargeStrength: -120, linkDistanceBase: 60, alphaDecay: 0.018, velocityDecay: 0.28,
      linkOpacity: 0.12, linkCurvatureBase: 0.2, linkGlowOpacity: 0.10, linkGlowStrength: 0.15,
      coreOpacity: 0.85, glowOpacity: 0.55, glowScale: 5.5,
      colorDarken: 0.45, clickZoom: 140, gentleZoom: 200,
      selectedGlow: 1.6, selectedScale: 1.4,
      bgIntensity: 0.7, bgParticleCount: 3000, bgTheme: 'deep-grid', floorStyle: 'grid',
    },
  },
  insane: {
    label: 'Insane', icon: '🌋', desc: 'Max everything',
    values: {
      chargeStrength: -160, linkDistanceBase: 75, alphaDecay: 0.012, velocityDecay: 0.22,
      linkOpacity: 0.2, linkCurvatureBase: 0.3, linkGlowOpacity: 0.18, linkGlowStrength: 0.25,
      coreOpacity: 0.95, glowOpacity: 0.7, glowScale: 7,
      colorDarken: 0.4, clickZoom: 160, gentleZoom: 230,
      selectedGlow: 2.0, selectedScale: 1.5,
      bgIntensity: 1.0, bgParticleCount: 4000, bgTheme: 'deep-grid', floorStyle: 'grid',
    },
  },
};

function getActivePreset() {
  return localStorage.getItem('neural-gfx-preset') || null;
}

function applyGfxPreset(presetKey) {
  const preset = GFX_PRESETS[presetKey];
  if (!preset) return;
  Object.assign(gfx, preset.values);
  saveGfxConfig(gfx);
  localStorage.setItem('neural-gfx-preset', presetKey);

  if (graph) {
    // Live-update all node materials and scales
    const scene = graph.scene();
    scene.traverse(obj => {
      if (!obj.userData || !obj.userData.nodeId) return;
      const r = obj.userData.baseRadius;
      if (!r) return;

      // Update dot sprite opacity
      const dot = obj.userData.dot;
      if (dot && dot.material) {
        dot.material.opacity = obj.userData.baseOpacity || 0.1;
      }
    });

  }

  // Update slider UI if settings panel is open
  const panel = document.getElementById('settings-panel');
  if (panel) {
    panel.querySelectorAll('input[type="range"][data-key]').forEach(input => {
      const key = input.dataset.key;
      if (gfx[key] !== undefined) {
        input.value = gfx[key];
        const step = parseFloat(input.step);
        const valSpan = panel.querySelector(`[data-val="${key}"]`);
        if (valSpan) valSpan.textContent = Number(gfx[key]).toFixed(step < 1 ? 2 : 0);
      }
    });
    panel.querySelectorAll('.gfx-preset-card[data-preset]').forEach(c => {
      c.classList.toggle('active', c.dataset.preset === presetKey);
    });
    panel.querySelectorAll('.floor-card').forEach(c => {
      c.classList.toggle('active', c.dataset.floorStyle === gfx.floorStyle);
    });
  }

  // Apply background theme if it changed
  applyBgTheme(gfx.bgTheme || 'deep-grid');
}

function loadGfxConfig() {
  try {
    const saved = JSON.parse(localStorage.getItem('neural-gfx-config') || '{}');
    return { ...GFX_DEFAULTS, ...saved };
  } catch { return { ...GFX_DEFAULTS }; }
}
function saveGfxConfig(cfg) {
  // Only save non-default values
  const diff = {};
  for (const k in cfg) {
    if (cfg[k] !== GFX_DEFAULTS[k]) diff[k] = cfg[k];
  }
  localStorage.setItem('neural-gfx-config', JSON.stringify(diff));
}
const gfx = loadGfxConfig();

// Apply saved UI scale on load
(function() {
  const s = parseFloat(localStorage.getItem('neural-ui-scale') || '1');
  if (s !== 1) document.documentElement.style.setProperty('--ui-scale', s);
})();

function truncate(str, len) {
  if (!str) return '';
  return str.length > len ? str.slice(0, len) + '...' : str;
}

// ═══════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════

// Category logos — preloaded map for parent category anchor nodes
const _categoryLogos = new Map();
function preloadCategoryLogos(categories) {
  const names = new Set(categories.map(c => c.name));
  for (const [k] of _categoryLogos) { if (!names.has(k)) _categoryLogos.delete(k); }
  for (const cat of categories) {
    if (!cat.logo) continue;
    const existing = _categoryLogos.get(cat.name);
    if (existing && existing.src === cat.logo) continue;
    const img = new Image();
    const entry = { img, ready: false, src: cat.logo };
    img.onload = () => { entry.ready = true; };
    img.onerror = () => { _categoryLogos.delete(cat.name); };
    img.src = cat.logo;
    _categoryLogos.set(cat.name, entry);
  }
}

// Legacy fallback: hardcoded OpenClaw logo
const _openclawLogo = new Image();
_openclawLogo.src = '/openclaw-logo-text.png';
let _openclawLogoReady = false;
_openclawLogo.onload = () => { _openclawLogoReady = true; };

let allNodes = [];
let allLinks = [];
let activeCategories = new Set();
let selectedNodeId = null;
let hoveredNodeId = null;
let focusedNodeId = null;
let _multiSelected = new Set();
let searchResults = null; // null = no search, Set of IDs = search active
let labelsVisible = true;
let labelSizeMultiplier = 1.0;
let graph = null;
let animFrameId = null;
let graphRemovalTimer = null; // delayed node removal for smooth category toggle
let _bloomPass = null; // reference to bloom post-processing pass
const _worldPos = new THREE.Vector3(); // reused in animate loop — no per-frame alloc
const _mouseDir = new THREE.Vector3(); // reused in updateMouse3D — no per-frame alloc

// ── Frustum culling — skip per-node animate work for off-screen nodes ──
const _frustum = new THREE.Frustum();
const _frustumPadded = new THREE.Frustum();  // expanded frustum for fade margin
const _projScreenMatrix = new THREE.Matrix4();

// ── Batch link rendering — single draw call for ALL visible links ──
// Visual links are NOT in graph.graphData() — only structural hierarchy links are.
// This eliminates 6000+ dummy Object3D creations and per-frame library iterations.
let _linkBatch = null;       // THREE.LineSegments
let _linkBatchGeo = null;    // shared BufferGeometry
let _linkBatchDirty = true;  // rebuild visible list + colors on next frame
let _batchLinks = [];        // filtered link references for current frame
let _visualLinks = [];       // all visual (non-structural) links — separate from graph data
let _nodeById = new Map();   // node ID → node object for resolving link endpoints
const _MAX_BATCH_LINKS = 15000;
let _linkBatchPositions = new Float32Array(_MAX_BATCH_LINKS * 6);
let _linkBatchColors = new Float32Array(_MAX_BATCH_LINKS * 6);

// ─── Drag state (single source of truth, outer scope for animate() access) ───
const _drag = {
  active: false,
  node: null,
  type: null,              // 'anchor' | 'tag' | 'memory'
  dragSet: new Set(),      // Node IDs moving as rigid body
  frozenSet: new Set(),    // Node IDs frozen during drag
  prevPos: null,
};

function scheduleGraphRemoval(delay = 600) {
  _linkBatchDirty = true; // immediately hide links for hidden categories
  if (graphRemovalTimer) clearTimeout(graphRemovalTimer);
  graphRemovalTimer = setTimeout(() => {
    graphRemovalTimer = null;
    applyGraphData();
    updateStats();
  }, delay);
}
function cancelScheduledRemoval() {
  if (graphRemovalTimer) {
    clearTimeout(graphRemovalTimer);
    graphRemovalTimer = null;
  }
}

// ═══════════════════════════════════════════
// DOM REFS
// ═══════════════════════════════════════════
const $loading = document.getElementById('loading-overlay');
const $statusDot = document.getElementById('status-dot');
const $searchInput = document.getElementById('search-input');
const $searchWrapper = document.getElementById('search-wrapper');
const $searchBadge = document.getElementById('search-badge');
const $searchClear = document.getElementById('search-clear');
const $categoryList = document.getElementById('category-list');
const $detailPanel = document.getElementById('detail-panel');
const $statTotal = document.getElementById('stat-total');
const $statVisible = document.getElementById('stat-visible');
const $statLinks = document.getElementById('stat-links');
const $statSearch = document.getElementById('stat-search-status');
const $tooltip = document.getElementById('tooltip');

document.getElementById('category-clear-btn').addEventListener('click', () => {
  activeCategories.clear();
  document.querySelectorAll('.category-chip').forEach(c => c.classList.add('inactive'));
  document.querySelectorAll('.category-cluster-header').forEach(c => c.classList.add('inactive'));
  scheduleGraphRemoval();
});

document.getElementById('category-select-all-btn').addEventListener('click', () => {
  const presentCats = new Set(allNodes.map(n => n.payload.category));
  activeCategories = new Set([...presentCats, ...allCategoryNames]);
  document.querySelectorAll('.category-chip').forEach(c => c.classList.remove('inactive'));
  document.querySelectorAll('.category-cluster-header').forEach(c => c.classList.remove('inactive'));
  cancelScheduledRemoval();
  applyGraphData();
  updateStats();
});

// ── Label controls ──
const $labelToggle = document.getElementById('label-toggle-btn');
const $labelSlider = document.getElementById('label-size-slider');
const $labelSizeBtn = document.getElementById('label-size-btn');
let sliderOpen = false;

$labelToggle.addEventListener('click', () => {
  labelsVisible = !labelsVisible;
  $labelToggle.style.color = labelsVisible ? 'var(--t-primary)' : 'var(--t-muted)';
  $labelToggle.innerHTML = labelsVisible
    ? '<svg viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>'
    : '<svg viewBox="0 0 24 24"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94"/><path d="M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19"/><line x1="1" y1="1" x2="23" y2="23"/></svg>';
});

$labelSizeBtn.addEventListener('click', () => {
  sliderOpen = !sliderOpen;
  $labelSlider.style.opacity = sliderOpen ? '1' : '0';
  $labelSlider.style.pointerEvents = sliderOpen ? 'auto' : 'none';
  $labelSizeBtn.style.color = sliderOpen ? 'var(--t-primary)' : 'var(--t-muted)';
});

$labelSlider.addEventListener('input', (e) => {
  labelSizeMultiplier = parseFloat(e.target.value);
});

// ═══════════════════════════════════════════
// GRAPH INIT
// ═══════════════════════════════════════════
function showLoadingError(title, sub, canStart, serverOffline) {
  const $overlay = document.getElementById('loading-overlay');
  $overlay.classList.add('error');
  if (serverOffline) $overlay.classList.add('server-offline');
  else $overlay.classList.remove('server-offline');
  if ($statusDot) $statusDot.classList.add('error');
  document.getElementById('loading-text').textContent = title;
  document.getElementById('loading-sub').textContent = sub;
  const $action = document.getElementById('loading-action');
  if (canStart) {
    $action.style.display = 'block';
    document.getElementById('loading-action-label').textContent = 'Start';
  } else {
    $action.style.display = 'none';
  }
  document.getElementById('loading-action-status').textContent = '';
}

async function handleStartAction() {
  const btn = document.getElementById('loading-action-btn');
  const $status = document.getElementById('loading-action-status');
  btn.disabled = true;
  document.getElementById('loading-action-label').textContent = 'Starting...';
  $status.textContent = 'This may take a moment...';

  try {
    const res = await fetch('/api/health/start', { method: 'POST' });
    const data = await res.json();
    if (data.ok && data.ready) {
      // Success — reset and load
      const $overlay = document.getElementById('loading-overlay');
      $overlay.classList.remove('error');
      document.getElementById('loading-text').textContent = 'Connecting';
      document.getElementById('loading-sub').textContent = 'Initializing neural pathways...';
      document.getElementById('loading-action').style.display = 'none';
      $status.textContent = '';
      if ($statusDot) $statusDot.classList.remove('error');
      init();
    } else {
      $status.textContent = data.error || 'Could not start. Try again.';
      btn.disabled = false;
      document.getElementById('loading-action-label').textContent = 'Retry';
    }
  } catch (err) {
    $status.textContent = 'Something went wrong. Try again.';
    btn.disabled = false;
    document.getElementById('loading-action-label').textContent = 'Retry';
  }
}

document.getElementById('loading-action-btn').addEventListener('click', handleStartAction);

// Copy command to clipboard
document.getElementById('loading-cmd-copy').addEventListener('click', () => {
  const cmd = document.getElementById('loading-cmd-text').textContent;
  navigator.clipboard.writeText(cmd).then(() => {
    const btn = document.getElementById('loading-cmd-copy');
    btn.innerHTML = '<svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>';
    btn.style.color = 'rgba(100,255,100,0.7)';
    setTimeout(() => {
      btn.innerHTML = '<svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>';
      btn.style.color = '';
    }, 1500);
  });
});

// Retry connection
document.getElementById('loading-retry-btn').addEventListener('click', async () => {
  const $status = document.getElementById('loading-retry-status');
  $status.textContent = 'Checking...';
  try {
    const res = await fetch('/api/health', { signal: AbortSignal.timeout(3000) });
    if (res.ok) {
      $status.textContent = 'Connected! Loading...';
      const $overlay = document.getElementById('loading-overlay');
      $overlay.classList.remove('error', 'server-offline');
      document.getElementById('loading-text').textContent = 'Connecting';
      document.getElementById('loading-sub').textContent = 'Initializing neural pathways...';
      if ($statusDot) $statusDot.classList.remove('error');
      init();
    } else {
      $status.textContent = 'Server responded but is not ready yet';
      setTimeout(() => { $status.textContent = ''; }, 3000);
    }
  } catch {
    $status.textContent = 'Still offline — start the server and try again';
    setTimeout(() => { $status.textContent = ''; }, 3000);
  }
});

async function init() {
  try {
    // Pre-flight: check if the database is reachable
    try {
      const healthRes = await fetch('/api/health');
      const health = await healthRes.json();
      if (!health.ok) {
        const messages = {
          docker_not_running: ['Database Offline', 'The memory database needs to be started'],
          container_stopped:  ['Database Stopped', 'The memory database was stopped'],
          qdrant_unreachable: ['Database Unreachable', 'The database engine is not responding'],
          remote_unreachable: ['Connection Failed', health.detail || 'Cannot reach the remote database'],
          auth_error:         ['Authentication Error', health.detail || 'The database rejected the connection'],
        };
        const [title, sub] = messages[health.reason] || ['Connection Error', health.detail || 'Cannot connect to the database'];
        showLoadingError(title, sub, !!health.canAutoStart);
        return;
      }
    } catch {
      // /api/health itself failed — continue to try /api/memories directly
    }

    // Fetch all memories
    const res = await fetch('/api/memories');
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();

    allNodes = data.nodes;
    allLinks = data.links;

    if ($statusDot) $statusDot.classList.add('connected');
    $statTotal.textContent = allNodes.length;

    // Fetch category definitions from server
    await fetchCategories();

    // Discover all categories present
    const presentCats = new Set(allNodes.map(n => n.payload.category));
    activeCategories = new Set([...presentCats, ...allCategoryNames]);

    buildCategorySidebar(presentCats);
    buildGraph();
    updateStats();

    // Restore last selected memory
    const savedNodeId = localStorage.getItem('neural-selected-node');
    if (savedNodeId) {
      const savedNode = allNodes.find(n => n.id === savedNodeId);
      if (savedNode) {
        selectedNodeId = savedNodeId;
        showDetailPanel(savedNode);
      }
    }

    // Fetch trash count for badge
    try { fetchTrashItems(); } catch {}

    // Fade out loading
    setTimeout(() => $loading.classList.add('hidden'), 400);

  } catch (err) {
    console.error('Init error:', err);
    const isNetworkError = err.message === 'Failed to fetch' || err.name === 'TypeError';
    showLoadingError(
      isNetworkError ? 'Server Offline' : 'Connection Failed',
      isNetworkError ? 'The Neural Interface server is not running' : err.message,
      false,
      isNetworkError
    );
  }
}

// --- Node position persistence ---
const _posStorageKey = 'synabun-node-positions';

function saveNodePositions() {
  if (!graph) return;
  const gd = graph.graphData();
  const positions = {};
  for (const n of gd.nodes) {
    // Save all nodes including anchors/tags (they're part of the layout)
    if (n.x != null) {
      positions[n.id] = { x: n.x, y: n.y, z: n.z };
    }
  }
  try { localStorage.setItem(_posStorageKey, JSON.stringify(positions)); } catch (_) {}
}

function restoreNodePositions(nodes) {
  try {
    const saved = JSON.parse(localStorage.getItem(_posStorageKey) || '{}');
    if (!Object.keys(saved).length) return;
    for (const n of nodes) {
      if (saved[n.id]) {
        const pos = saved[n.id];
        n.x = pos.x; n.y = pos.y; n.z = pos.z;
        n.fx = pos.x; n.fy = pos.y; n.fz = pos.z;
      }
    }
  } catch (_) {}
}

// Auto-save positions periodically once simulation is stable
let _posSaveTimer = null;
function schedulePositionSave() {
  if (_posSaveTimer) clearTimeout(_posSaveTimer);
  _posSaveTimer = setTimeout(saveNodePositions, 2000);
}

function initLinkBatch() {
  if (!graph) return;
  _linkBatchGeo = new THREE.BufferGeometry();
  _linkBatchGeo.setAttribute('position', new THREE.BufferAttribute(_linkBatchPositions, 3));
  _linkBatchGeo.setAttribute('color', new THREE.BufferAttribute(_linkBatchColors, 3));
  _linkBatchGeo.setDrawRange(0, 0);
  const mat = new THREE.LineBasicMaterial({
    vertexColors: true, transparent: true,
    opacity: gfx.linkOpacity || 0.12, depthWrite: false,
  });
  _linkBatch = new THREE.LineSegments(_linkBatchGeo, mat);
  _linkBatch.frustumCulled = false;
  _linkBatch.renderOrder = -1;
  graph.scene().add(_linkBatch);
}

function buildGraph() {
  const container = document.getElementById('graph-container');

  graph = ForceGraph3D({ controlType: 'orbit' })(container)
    .backgroundColor('#050505')
    .showNavInfo(false)
    .nodeId('id')
    .nodeLabel(() => '')
    .nodeThreeObject(createNodeObject)
    .nodeThreeObjectExtend(false)
    .linkSource('source')
    .linkTarget('target')
    // Links rendered via batch LineSegments — library link objects disabled
    .linkThreeObject(() => { const o = new THREE.Object3D(); o.visible = false; return o; })
    .linkWidth(0)
    .linkCurvature(0)
    .linkDirectionalParticles(0)
    .linkVisibility(() => false)
    .onNodeHover(handleNodeHover)
    .onNodeClick(handleNodeClick)
    .onBackgroundClick(handleBackgroundClick)
    .onNodeDrag((node) => {
      const gd = graph.graphData();

      if (!_drag.active) {
        _drag.active = true;
        _drag.node = node;

        const { type, dragSet } = _buildDragSet(node, gd.nodes);
        _drag.type = type;
        _drag.dragSet = dragSet;

        document.body.style.cursor = 'grabbing';
      }

      // Rigid-body translate: move all group members by same delta
      if (_drag.prevPos) {
        const dx = (node.x || 0) - _drag.prevPos.x;
        const dy = (node.y || 0) - _drag.prevPos.y;
        const dz = (node.z || 0) - _drag.prevPos.z;

        if (dx !== 0 || dy !== 0 || dz !== 0) {
          for (const n of gd.nodes) {
            if (n === node) continue;
            if (_drag.dragSet.has(n.id)) {
              n.x = (n.x || 0) + dx;
              n.y = (n.y || 0) + dy;
              n.z = (n.z || 0) + dz;
              n.fx = n.x; n.fy = n.y; n.fz = n.z;
            }
          }
        }
      }
      _drag.prevPos = { x: node.x || 0, y: node.y || 0, z: node.z || 0 };
    })
    .onNodeDragEnd(node => {
      if (!_drag.active) return;

      // Keep all positions pinned — no simulation reheat, no jitter
      node.fx = node.x; node.fy = node.y; node.fz = node.z;

      document.body.style.cursor = hoveredNodeId ? 'grab' : 'default';
      _drag.active = false;
      _drag.node = null;
      _drag.type = null;
      _drag.dragSet = new Set();
      _drag.prevPos = null;
      schedulePositionSave();
    })
    .warmupTicks(1)
    .cooldownTicks(0)
    .d3AlphaDecay(1)
    .d3VelocityDecay(1);

  // ─── Forces disabled — layout is computed by computeLayout() ───
  // Kill charge and center forces: positions are pinned with fx/fy/fz
  // KEEP link force (strength 0) so d3 resolves source/target IDs to node refs
  graph.d3Force('charge', null);
  graph.d3Force('center', null);
  graph.d3Force('link').strength(0);

  // Determine which nodes move rigidly with the dragged node
  function _buildDragSet(node, allNodes) {
    const dragSet = new Set();
    dragSet.add(node.id);

    if (node.payload && node.payload._isAnchor) {
      // Anchor drag: move anchor + all tags + all memories in this tree
      const anchorCat = node.payload._anchorCategory;
      const childCats = Object.entries(categoryMetadata)
        .filter(([, m]) => m.parent === anchorCat)
        .map(([name]) => name);
      const treeCats = new Set([anchorCat, ...childCats]);
      for (const n of allNodes) {
        if (n === node) continue;
        if (n.payload._isTag && treeCats.has(n.payload._tagCategory)) dragSet.add(n.id);
        if (!n.payload._isAnchor && !n.payload._isTag && treeCats.has(n.payload.category)) dragSet.add(n.id);
      }
      return { type: 'anchor', dragSet };
    }

    if (node.payload && node.payload._isTag) {
      // Tag drag: move tag + its memories
      const tagCat = node.payload._tagCategory;
      for (const n of allNodes) {
        if (!n.payload._isAnchor && !n.payload._isTag && n.payload.category === tagCat) {
          dragSet.add(n.id);
        }
      }
      return { type: 'tag', dragSet };
    }

    // Multi-select drag: if this memory is in the multi-selection, drag them all
    if (_multiSelected.size > 0 && _multiSelected.has(node.id)) {
      for (const id of _multiSelected) dragSet.add(id);
      return { type: 'multi', dragSet };
    }

    return { type: 'memory', dragSet };
  }

  // Enable hardware acceleration and performance optimizations
  const renderer = graph.renderer();
  if (renderer) {
    renderer.antialias = true;
    renderer.powerPreference = 'high-performance';
    renderer.precision = 'highp';

    // Enable hardware acceleration features
    const gl = renderer.getContext();
    if (gl) {
      gl.enable(gl.DEPTH_TEST);
      gl.enable(gl.CULL_FACE);
    }

    // Optimize rendering
    renderer.sortObjects = false; // Skip sorting for better performance
    renderer.info.autoReset = false; // Manual reset for perf monitoring
  }

  // Apply data (layout is computed, positions are pinned)
  applyGraphData();

  // One-time reset: clear saved positions for new hierarchical layout (v2)
  if (localStorage.getItem('synabun-layout-version') !== 'v4-spacing') {
    try { localStorage.removeItem(_posStorageKey); } catch (_) {}
    localStorage.setItem('synabun-layout-version', 'v4-spacing');
  }

  // Apply link visibility respecting structural filter and saved link mode
  applyLinkVisibility();

  // Bloom post-processing — subtle ambient glow, not neon
  _bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    0.3,   // strength — soft, matte feel
    0.4,   // radius — tight spread
    0.45   // threshold — only brightest elements bloom
  );
  graph.postProcessingComposer().addPass(_bloomPass);

  // Add background based on theme setting
  applyBgTheme(gfx.bgTheme || 'deep-grid');

  // Init batch link renderer (single draw call for all links)
  initLinkBatch();

  // Start animation loop
  animate();
}

// ═══════════════════════════════════════════
// SOFT DOT TEXTURE — website-inspired smoothstep falloff
// Single shared texture, tinted per-sprite via SpriteMaterial.color
// ═══════════════════════════════════════════
let _softDotTex = null;
function getSoftDotTexture() {
  if (_softDotTex) return _softDotTex;
  const size = 64;
  const canvas = document.createElement('canvas');
  canvas.width = size; canvas.height = size;
  const ctx = canvas.getContext('2d');
  const c = size / 2;
  const imgData = ctx.createImageData(size, size);
  const d = imgData.data;
  for (let py = 0; py < size; py++) {
    for (let px = 0; px < size; px++) {
      const dx = (px - c) / c, dy = (py - c) / c;
      const dist = Math.sqrt(dx * dx + dy * dy);
      // smoothstep(0.5, 0.15, dist) — bright center, soft falloff
      const t = Math.max(0, Math.min(1, (0.5 - dist) / (0.5 - 0.15)));
      const alpha = t * t * (3 - 2 * t);
      const idx = (py * size + px) * 4;
      d[idx] = 255; d[idx + 1] = 255; d[idx + 2] = 255;
      d[idx + 3] = alpha * 255 | 0;
    }
  }
  ctx.putImageData(imgData, 0, 0);
  _softDotTex = new THREE.CanvasTexture(canvas);
  _softDotTex.needsUpdate = true;
  return _softDotTex;
}

// Plexus interaction radius — nodes/links within this distance from
// the 3D mouse point glow brighter and form visible connections
const PLEXUS_RADIUS = 200;
const _MULTI_SELECT_BLUE = new THREE.Color(0.4, 0.7, 1.0);

// 3D mouse position tracking via raycasting
const _mouse = new THREE.Vector2();
const _raycaster = new THREE.Raycaster();
const _mousePlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
const _mouse3D = new THREE.Vector3();
let _mouse3DValid = false;

document.addEventListener('mousemove', (e) => {
  _mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  _mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  _mouse3DValid = true;
});

function updateMouse3D() {
  if (!graph || !_mouse3DValid) return;
  const cam = graph.camera();
  _raycaster.setFromCamera(_mouse, cam);
  // Project mouse onto a plane at the orbit target depth
  const controls = graph.controls();
  const target = controls && controls.target ? controls.target : _mouseDir.set(0, 0, 0);
  _mousePlane.setFromNormalAndCoplanarPoint(
    cam.getWorldDirection(_mouseDir).negate(),
    target
  );
  _raycaster.ray.intersectPlane(_mousePlane, _mouse3D);
}

// ═══════════════════════════════════════════
// ANCHOR NODE — Parent category (flat glass card with logo/label)
// ═══════════════════════════════════════════
function createAnchorObject(node) {
  const parentName = node.payload._anchorCategory;
  const color = catColor(parentName);
  const hex = new THREE.Color(color);
  const dotSize = 20;

  const group = new THREE.Group();

  // No dot sphere for parent categories — only text/image label is shown

  // Label sprite — tightly sized canvas so hitbox matches content precisely
  const _logoEntry = _categoryLogos.get(parentName);
  const useLogo = (_logoEntry && _logoEntry.ready) || (parentName === 'openclaw' && _openclawLogoReady);
  const logoImage = (_logoEntry && _logoEntry.ready) ? _logoEntry.img : _openclawLogo;

  // Measure content to size canvas tightly
  let contentW, contentH;
  const PAD = 16; // small padding around content

  if (useLogo) {
    const aspect = logoImage.naturalWidth / (logoImage.naturalHeight || 1);
    const maxW = 380, maxH = 100;
    if (aspect >= maxW / maxH) { contentW = maxW; contentH = maxW / aspect; }
    else { contentH = maxH; contentW = maxH * aspect; }
  } else {
    // Measure text width
    const measureCanvas = document.createElement('canvas');
    const measureCtx = measureCanvas.getContext('2d');
    measureCtx.font = '600 36px "Space Grotesk", "Inter", system-ui, sans-serif';
    const metrics = measureCtx.measureText(parentName.toUpperCase());
    contentW = Math.ceil(metrics.width);
    contentH = 44; // font size + descenders
  }

  const canvasW = Math.ceil(contentW + PAD * 2);
  const canvasH = Math.ceil(contentH + PAD * 2);

  const labelCanvas = document.createElement('canvas');
  const labelCtx = labelCanvas.getContext('2d');
  labelCanvas.width = canvasW;
  labelCanvas.height = canvasH;
  labelCtx.clearRect(0, 0, canvasW, canvasH);

  if (useLogo) {
    labelCtx.globalAlpha = 0.85;
    labelCtx.drawImage(logoImage, PAD, PAD, contentW, contentH);
    labelCtx.globalAlpha = 1.0;
  } else {
    labelCtx.font = '600 36px "Space Grotesk", "Inter", system-ui, sans-serif';
    labelCtx.textAlign = 'center';
    labelCtx.textBaseline = 'middle';
    labelCtx.fillStyle = 'rgba(255,255,255,0.85)';
    labelCtx.fillText(parentName.toUpperCase(), canvasW / 2, canvasH / 2);
  }

  const labelTex = new THREE.CanvasTexture(labelCanvas);
  const labelMat = new THREE.SpriteMaterial({
    map: labelTex,
    transparent: true,
    opacity: 0.85,
    depthWrite: false,
  });
  const label = new THREE.Sprite(labelMat);
  // Scale sprite to match content — world units proportional to canvas pixels
  // ~0.2 world units per canvas pixel gives readable size
  const SCALE = 0.2;
  const labelW = canvasW * SCALE;
  const labelH = canvasH * SCALE;
  label.scale.set(labelW, labelH, 1);
  label.position.set(0, 0, 0.5);
  // Label IS the hitbox — precisely sized to content bounds
  group.add(label);

  // Flat plane hitbox — precisely matches label dimensions for click/drag
  const hitGeo = new THREE.PlaneGeometry(labelW, labelH);
  const hitMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthWrite: false, side: THREE.DoubleSide });
  const hitbox = new THREE.Mesh(hitGeo, hitMat);
  hitbox.position.set(0, 0, 0.5);
  group.add(hitbox);

  group.userData.nodeId = node.id;
  group.userData.isAnchor = true;
  group.userData.anchorCategory = parentName;
  group.userData.dot = null; // no dot sphere for parent categories
  group.userData.label = label;
  group.userData.baseLabelScale = { x: labelW, y: labelH };
  group.userData.baseLabelY = 0;
  group.userData.baseRadius = dotSize;
  group.userData.category = parentName;
  group.userData.phase = parentName.length * 0.7;
  group.userData.importance = 10;
  group.userData.baseOpacity = 0.8;

  group.userData._currentScale = 0.01;
  group.scale.setScalar(0.01);

  return group;
}

// ═══════════════════════════════════════════
// TAG NODE — Child category (subtle dot + small label)
// ═══════════════════════════════════════════
function createTagObject(node) {
  const catName = node.payload._tagCategory;
  const color = catColor(catName);
  const hex = new THREE.Color(color);
  const dotSize = 10;

  const group = new THREE.Group();

  // Visible dot sprite — category color, matte
  const dotMat = new THREE.SpriteMaterial({
    map: getSoftDotTexture(),
    color: hex,
    transparent: true,
    opacity: 0.35,
    blending: THREE.NormalBlending,
    depthWrite: false,
  });
  const dot = new THREE.Sprite(dotMat);
  dot.scale.set(dotSize, dotSize, 1);
  dot.raycast = () => {};
  group.add(dot);

  // Small text label — tightly sized canvas
  const measureCanvas = document.createElement('canvas');
  const measureCtx = measureCanvas.getContext('2d');
  measureCtx.font = '500 28px "JetBrains Mono", "Space Grotesk", monospace';
  const tagMetrics = measureCtx.measureText(catName);
  const tagTextW = Math.ceil(tagMetrics.width);
  const tagTextH = 36;
  const tagPad = 12;
  const tagCanvasW = tagTextW + tagPad * 2;
  const tagCanvasH = tagTextH + tagPad * 2;

  const labelCanvas = document.createElement('canvas');
  const labelCtx = labelCanvas.getContext('2d');
  labelCanvas.width = tagCanvasW;
  labelCanvas.height = tagCanvasH;
  labelCtx.clearRect(0, 0, tagCanvasW, tagCanvasH);
  labelCtx.font = '500 28px "JetBrains Mono", "Space Grotesk", monospace';
  labelCtx.textAlign = 'center';
  labelCtx.textBaseline = 'middle';
  labelCtx.fillStyle = color;
  labelCtx.fillText(catName, tagCanvasW / 2, tagCanvasH / 2);

  const labelTex = new THREE.CanvasTexture(labelCanvas);
  const labelMat = new THREE.SpriteMaterial({ map: labelTex, transparent: true, opacity: 0.6, depthWrite: false });
  const label = new THREE.Sprite(labelMat);
  const TAG_SCALE = 0.15;
  const tagLabelW = tagCanvasW * TAG_SCALE;
  const tagLabelH = tagCanvasH * TAG_SCALE;
  label.scale.set(tagLabelW, tagLabelH, 1);
  label.position.set(0, dotSize * 0.8, 0);
  group.add(label);

  // Flat plane hitbox — precisely matches label + dot area
  const hitW = Math.max(tagLabelW, dotSize);
  const hitH = tagLabelH + dotSize;
  const hitGeo = new THREE.PlaneGeometry(hitW, hitH);
  const hitMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthWrite: false, side: THREE.DoubleSide });
  const hitbox = new THREE.Mesh(hitGeo, hitMat);
  hitbox.position.set(0, dotSize * 0.4, 0);
  group.add(hitbox);

  group.userData.nodeId = node.id;
  group.userData.isTag = true;
  group.userData.tagCategory = catName;
  group.userData.dot = dot;
  group.userData.label = label;
  group.userData.baseLabelScale = { x: tagLabelW, y: tagLabelH };
  group.userData.baseLabelY = dotSize * 0.8;
  group.userData.baseRadius = dotSize;
  group.userData.category = catName;
  group.userData.phase = catName.split('').reduce((a, c) => a + c.charCodeAt(0), 0) * 0.3;
  group.userData.importance = 8;
  group.userData.baseOpacity = 0.6;

  group.userData._currentScale = 0.01;
  group.scale.setScalar(0.01);

  return group;
}

// ═══════════════════════════════════════════
// MEMORY NODE — Wireframe geodesic with inner glow
// ═══════════════════════════════════════════

// Shared geometries (one per detail level, reused across all nodes)
let _icoGeoLow = null;   // importance 1-4
let _icoGeoMed = null;   // importance 5-7
let _icoGeoHigh = null;  // importance 8-10
function getIcoGeo(importance) {
  if (importance >= 8) {
    if (!_icoGeoHigh) _icoGeoHigh = new THREE.IcosahedronGeometry(1, 2); // 162 verts
    return _icoGeoHigh;
  }
  if (importance >= 5) {
    if (!_icoGeoMed) _icoGeoMed = new THREE.IcosahedronGeometry(1, 1);   // 42 verts
    return _icoGeoMed;
  }
  if (!_icoGeoLow) _icoGeoLow = new THREE.IcosahedronGeometry(1, 0);     // 12 verts
  return _icoGeoLow;
}

function createNodeObject(node) {
  if (node.payload && node.payload._isAnchor) return createAnchorObject(node);
  if (node.payload && node.payload._isTag) return createTagObject(node);

  const color = catColor(node.payload.category);
  const importance = node.payload.importance || 5;
  const hex = new THREE.Color(color);
  // Radius: 2-5 based on importance
  const radius = 2 + (importance - 1) * 0.33;
  // Base opacity: subtle wireframe, 0.18-0.38 based on importance
  const baseOpacity = 0.18 + (importance - 1) * 0.022;

  const group = new THREE.Group();

  // Wireframe geodesic sphere — muted category color
  const mutedHex = hex.clone().lerp(new THREE.Color(0.35, 0.35, 0.35), 0.35);
  const wireMat = new THREE.MeshBasicMaterial({
    color: mutedHex,
    wireframe: true,
    transparent: true,
    opacity: baseOpacity,
    depthWrite: false,
  });
  const wire = new THREE.Mesh(getIcoGeo(importance), wireMat);
  wire.scale.setScalar(radius);
  // Random initial rotation for variety
  wire.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
  wire.raycast = () => {};
  group.add(wire);

  // Subtle inner core — matte, no additive blending
  const glowMat = new THREE.SpriteMaterial({
    map: getSoftDotTexture(),
    color: mutedHex,
    transparent: true,
    opacity: baseOpacity * 0.35,
    blending: THREE.NormalBlending,
    depthWrite: false,
  });
  const glow = new THREE.Sprite(glowMat);
  glow.scale.set(radius * 0.9, radius * 0.9, 1);
  glow.raycast = () => {};
  group.add(glow);

  // Hitbox — tightly matches the wireframe radius
  const hitboxGeo = new THREE.SphereGeometry(radius * 1.1, 6, 6);
  const hitboxMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthWrite: false });
  group.add(new THREE.Mesh(hitboxGeo, hitboxMat));

  group.userData.nodeId = node.id;
  group.userData.dot = wire;       // animate loop reads .dot.material.opacity
  group.userData.glow = glow;
  group.userData.baseRadius = radius;
  group.userData.baseOpacity = baseOpacity;
  group.userData.baseColor = mutedHex.clone();
  group.userData.category = node.payload.category;
  group.userData.phase = Math.random() * Math.PI * 2;
  group.userData.importance = importance;

  group.userData._currentScale = 0.01;
  group.scale.setScalar(0.01);

  return group;
}

// ═══════════════════════════════════════════
// BACKGROUND — Spherical particle shells + depth fog
// Creates true 3D depth with concentric shells of particles
// ═══════════════════════════════════════════
// Deep Grid theme objects
let bgGrid = null;
let bgGridPillars = null;
let bgWorldParticles = null;
let bgGridFloor2 = null;
let bgSkyDome = null;
let _cloudPlanes = [];
let bgSkyParticles = null;
let _origControlsUpdate = null; // saved reference for cleanup

// Floor effect objects (independent of bg theme)
let floorMesh = null;
let floorParticles = null;
const FLOOR_Y_CONST = -200;

// ═══════════════════════════════════════════
// FLOOR EFFECTS — Selectable floor styles
// ═══════════════════════════════════════════

function removeFloor() {
  const scene = graph.scene();
  if (floorMesh) { scene.remove(floorMesh); floorMesh.geometry.dispose(); floorMesh.material.dispose(); floorMesh = null; }
  if (floorParticles) { scene.remove(floorParticles); floorParticles.geometry.dispose(); floorParticles.material.dispose(); floorParticles = null; }
}

// ── Floor: Grid ──
function addFloorGrid() {
  const scene = graph.scene();
  const gridSize = 8000;
  const gridGeo = new THREE.PlaneGeometry(gridSize, gridSize, 1, 1);
  gridGeo.rotateX(-Math.PI / 2);

  const gridMat = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    side: THREE.DoubleSide,
    uniforms: {
      uTime: { value: 0 },
      uCamY: { value: 300 },
    },
    vertexShader: `
      varying vec3 vWorldPos;
      void main() {
        vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec3 vWorldPos;
      uniform float uTime;
      uniform float uCamY;

      float softLine(float coord, float spacing, float sharpness) {
        float d = abs(mod(coord + spacing * 0.5, spacing) - spacing * 0.5);
        // Combine gaussian glow with screen-space AA to kill edge aliasing
        float fw = fwidth(coord / spacing) * spacing * 1.5;
        float aa = 1.0 - smoothstep(0.0, max(fw, 0.5), d);
        float glow = exp(-d * d * sharpness);
        return max(aa * 0.6, glow);
      }

      void main() {
        float distFromCenter = length(vWorldPos.xz);
        float fade = 1.0 - smoothstep(1200.0, 3800.0, distFromCenter);

        // Sharpness decreases with distance — lines get softer/wider further out
        float sharpness = mix(1.2, 0.15, smoothstep(0.0, 2500.0, distFromCenter));

        float lx = softLine(vWorldPos.x, 200.0, sharpness);
        float lz = softLine(vWorldPos.z, 200.0, sharpness);
        float grid = max(lx, lz);

        float dot = lx * lz;
        float pulse = sin(uTime * 2.0 + vWorldPos.x * 0.04 + vWorldPos.z * 0.03) * 0.5 + 0.5;
        float dotGlow = dot * (0.08 + pulse * 0.08);

        vec3 col = vec3(1.0);
        float alpha = (grid * 0.045 + dotGlow) * fade;

        float camFade = smoothstep(0.0, 10.0, abs(uCamY - ${FLOOR_Y_CONST}.0));
        alpha *= 0.4 + camFade * 0.6;

        if (alpha < 0.002) discard;
        gl_FragColor = vec4(col, alpha);
      }
    `,
  });

  floorMesh = new THREE.Mesh(gridGeo, gridMat);
  floorMesh.position.y = FLOOR_Y_CONST;
  floorMesh.renderOrder = -10;
  scene.add(floorMesh);
}

// ── Floor: Dot Field with proximity glow ──
function addFloorDots() {
  const scene = graph.scene();
  const spacing = 40;
  const extent = 3200;
  const count = Math.pow(Math.floor(extent * 2 / spacing) + 1, 2);
  const positions = new Float32Array(count * 3);
  const phases = new Float32Array(count);
  let idx = 0;

  for (let x = -extent; x <= extent; x += spacing) {
    for (let z = -extent; z <= extent; z += spacing) {
      positions[idx * 3] = x + (Math.random() - 0.5) * 6;
      positions[idx * 3 + 1] = FLOOR_Y_CONST;
      positions[idx * 3 + 2] = z + (Math.random() - 0.5) * 6;
      phases[idx] = Math.random() * Math.PI * 2;
      idx++;
    }
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(positions.slice(0, idx * 3), 3));
  geo.setAttribute('aPhase', new THREE.Float32BufferAttribute(phases.slice(0, idx), 1));

  const mat = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    uniforms: {
      uTime: { value: 0 },
      uCamPos: { value: new THREE.Vector3(0, 300, 0) },
    },
    vertexShader: `
      attribute float aPhase;
      varying float vAlpha;
      varying float vProximity;
      varying float vWave;
      uniform float uTime;
      uniform vec3 uCamPos;
      void main() {
        vec4 worldPos = modelMatrix * vec4(position, 1.0);
        float distFromCenter = length(worldPos.xz);
        float fade = 1.0 - smoothstep(1500.0, 3200.0, distFromCenter);

        // Proximity glow — wide, strong falloff around camera xz
        float camDist = length(worldPos.xz - uCamPos.xz);
        vProximity = exp(-camDist * camDist * 0.0000008);

        // Ripple wave expanding outward from camera
        float wave = sin(camDist * 0.015 - uTime * 2.5) * 0.5 + 0.5;
        wave *= exp(-camDist * 0.0008);
        vWave = wave;

        float twinkle = 0.5 + 0.5 * sin(uTime * 2.0 + aPhase * 6.28);
        vAlpha = fade * (0.15 + twinkle * 0.1 + vProximity * 0.55 + wave * 0.2);

        vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
        float size = (3.0 + vProximity * 8.0 + wave * 3.0) * (300.0 / max(-mvPos.z, 1.0));
        gl_PointSize = size;
        gl_Position = projectionMatrix * mvPos;
      }
    `,
    fragmentShader: `
      varying float vAlpha;
      varying float vProximity;
      varying float vWave;
      void main() {
        float dist = length(gl_PointCoord - vec2(0.5));
        if (dist > 0.5) discard;
        float core = exp(-dist * dist * 16.0);
        float glow = exp(-dist * dist * 4.0) * 0.5;
        float alpha = (core + glow) * vAlpha;
        vec3 baseCol = vec3(0.55, 0.62, 0.95);
        vec3 hotCol = vec3(0.85, 0.9, 1.0);
        vec3 col = mix(baseCol, hotCol, vProximity * 0.8 + vWave * 0.3);
        gl_FragColor = vec4(col, alpha);
      }
    `,
  });

  floorParticles = new THREE.Points(geo, mat);
  floorParticles.renderOrder = -10;
  scene.add(floorParticles);
}

// ── Floor: Hex Grid ──
function addFloorHex() {
  const scene = graph.scene();
  const gridSize = 8000;
  const gridGeo = new THREE.PlaneGeometry(gridSize, gridSize, 1, 1);
  gridGeo.rotateX(-Math.PI / 2);

  const hexMat = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    side: THREE.DoubleSide,
    uniforms: {
      uTime: { value: 0 },
      uCamY: { value: 300 },
    },
    vertexShader: `
      varying vec3 vWorldPos;
      void main() {
        vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec3 vWorldPos;
      uniform float uTime;
      uniform float uCamY;

      // Hex distance field — returns distance to nearest hex edge
      float hexDist(vec2 p) {
        p = abs(p);
        return max(dot(p, normalize(vec2(1.0, 1.732))), p.x);
      }

      vec4 hexCoords(vec2 uv) {
        vec2 r = vec2(1.0, 1.732);
        vec2 h = r * 0.5;
        vec2 a = mod(uv, r) - h;
        vec2 b = mod(uv - h, r) - h;
        vec2 gv = length(a) < length(b) ? a : b;
        vec2 id = uv - gv;
        return vec4(gv, id);
      }

      void main() {
        float distFromCenter = length(vWorldPos.xz);
        float fade = 1.0 - smoothstep(1500.0, 3800.0, distFromCenter);

        float scale = 220.0;
        vec2 uv = vWorldPos.xz / scale;
        vec4 hc = hexCoords(uv);

        // Thin crisp edge — slightly thicker than 1px for clean reads at distance
        float d = 0.5 - hexDist(hc.xy);
        float fw = fwidth(d);
        float edge = 1.0 - smoothstep(fw * 0.3, fw * 1.8, d);

        vec3 col = vec3(0.7, 0.75, 0.95);
        float alpha = edge * 0.07 * fade;

        float camFade = smoothstep(0.0, 10.0, abs(uCamY - ${FLOOR_Y_CONST}.0));
        alpha *= 0.4 + camFade * 0.6;

        if (alpha < 0.002) discard;
        gl_FragColor = vec4(col, alpha);
      }
    `,
  });

  floorMesh = new THREE.Mesh(gridGeo, hexMat);
  floorMesh.position.y = FLOOR_Y_CONST;
  floorMesh.renderOrder = -10;
  scene.add(floorMesh);
}

// ── Floor: Concentric Ripples ──
function addFloorRipples() {
  const scene = graph.scene();
  const gridSize = 8000;
  const gridGeo = new THREE.PlaneGeometry(gridSize, gridSize, 1, 1);
  gridGeo.rotateX(-Math.PI / 2);

  const rippleMat = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    side: THREE.DoubleSide,
    uniforms: {
      uTime: { value: 0 },
      uCamY: { value: 300 },
    },
    vertexShader: `
      varying vec3 vWorldPos;
      void main() {
        vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec3 vWorldPos;
      uniform float uTime;
      uniform float uCamY;

      void main() {
        float distFromCenter = length(vWorldPos.xz);
        float fade = 1.0 - smoothstep(1200.0, 3800.0, distFromCenter);

        // Concentric rings expanding outward
        float ringSpacing = 80.0;
        float scrollDist = distFromCenter - uTime * 15.0;
        float ring = abs(mod(scrollDist, ringSpacing) - ringSpacing * 0.5);
        float ringLine = exp(-ring * ring * 0.08);

        // Static rings for structure
        float staticRing = abs(mod(distFromCenter, ringSpacing * 2.5) - ringSpacing * 1.25);
        float staticLine = exp(-staticRing * staticRing * 0.04);

        // Radial spokes — very subtle
        float angle = atan(vWorldPos.z, vWorldPos.x);
        float spoke = exp(-pow(mod(angle + 3.1416, 0.3927) - 0.19635, 2.0) * 600.0);
        float spokeFade = smoothstep(0.0, 400.0, distFromCenter) * 0.3;

        vec3 col = vec3(1.0);
        float alpha = (ringLine * 0.06 + staticLine * 0.03 + spoke * spokeFade * 0.04) * fade;

        float camFade = smoothstep(0.0, 10.0, abs(uCamY - ${FLOOR_Y_CONST}.0));
        alpha *= 0.4 + camFade * 0.6;

        if (alpha < 0.002) discard;
        gl_FragColor = vec4(col, alpha);
      }
    `,
  });

  floorMesh = new THREE.Mesh(gridGeo, rippleMat);
  floorMesh.position.y = FLOOR_Y_CONST;
  floorMesh.renderOrder = -10;
  scene.add(floorMesh);
}

// ── Floor: Ground Fog Particles ──
function addFloorFog() {
  const scene = graph.scene();
  const count = 3000;
  const positions = new Float32Array(count * 3);
  const sizes = new Float32Array(count);
  const alphas = new Float32Array(count);
  const phases = new Float32Array(count);

  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const radius = Math.random() * 3000;
    positions[i * 3] = Math.cos(angle) * radius;
    positions[i * 3 + 1] = FLOOR_Y_CONST + Math.random() * 60;
    positions[i * 3 + 2] = Math.sin(angle) * radius;
    sizes[i] = 8 + Math.random() * 25;
    alphas[i] = 0.01 + Math.random() * 0.04;
    phases[i] = Math.random() * Math.PI * 2;
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geo.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
  geo.setAttribute('aAlpha', new THREE.Float32BufferAttribute(alphas, 1));
  geo.setAttribute('aPhase', new THREE.Float32BufferAttribute(phases, 1));

  const mat = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    uniforms: { uTime: { value: 0 } },
    vertexShader: `
      attribute float aSize;
      attribute float aAlpha;
      attribute float aPhase;
      varying float vAlpha;
      uniform float uTime;
      void main() {
        vec3 pos = position;
        float t = uTime * 0.15 + aPhase;
        pos.x += sin(t * 0.7 + aPhase * 3.0) * 8.0;
        pos.z += cos(t * 0.5 + aPhase * 2.0) * 8.0;
        pos.y += sin(t) * 3.0;

        vec4 mvPos = modelViewMatrix * vec4(pos, 1.0);
        float camDist = length(mvPos.xyz);
        float distFade = 1.0 - smoothstep(500.0, 3000.0, camDist);
        float breathe = 0.6 + 0.4 * sin(uTime * 0.4 + aPhase * 6.28);

        vAlpha = aAlpha * distFade * breathe;
        gl_PointSize = aSize * (400.0 / max(-mvPos.z, 1.0));
        gl_Position = projectionMatrix * mvPos;
      }
    `,
    fragmentShader: `
      varying float vAlpha;
      void main() {
        float dist = length(gl_PointCoord - vec2(0.5));
        if (dist > 0.5) discard;
        float soft = exp(-dist * dist * 8.0);
        gl_FragColor = vec4(0.75, 0.78, 0.88, soft * vAlpha);
      }
    `,
  });

  floorParticles = new THREE.Points(geo, mat);
  floorParticles.renderOrder = -10;
  scene.add(floorParticles);
}

// ── Floor dispatcher ──
function applyFloorStyle(style) {
  if (!graph) return;
  removeFloor();
  switch (style) {
    case 'grid': addFloorGrid(); break;
    case 'dots': addFloorDots(); break;
    case 'hex': addFloorHex(); break;
    case 'ripples': addFloorRipples(); break;
    case 'fog': addFloorFog(); break;
    case 'none': break;
  }
}

// ═══════════════════════════════════════════
// BACKGROUND — Deep Grid theme
// Perspective grid floor + world-space particles + vertical pillars
// Gives true spatial depth and grounding
// ═══════════════════════════════════════════
function addBackgroundDeepGrid() {
  const scene = graph.scene();
  const FLOOR_Y = -200;

  // Floor is now handled by applyFloorStyle() — separate system

  // ── Layer B: Vertical Accent Pillars ──
  // Muted grey-blue, very subtle
  const pillarCount = 90;
  const pillarPositions = new Float32Array(pillarCount * 6);
  const pillarAlphas = new Float32Array(pillarCount * 2);
  const pillarPhases = new Float32Array(pillarCount * 2);
  const pillarSpacing = 70;
  const pillarSpread = 2000;

  for (let i = 0; i < pillarCount; i++) {
    const gx = (Math.floor(Math.random() * (pillarSpread / pillarSpacing) * 2) - pillarSpread / pillarSpacing) * pillarSpacing;
    const gz = (Math.floor(Math.random() * (pillarSpread / pillarSpacing) * 2) - pillarSpread / pillarSpacing) * pillarSpacing;
    const height = 30 + Math.random() * 120;

    pillarPositions[i * 6]     = gx;
    pillarPositions[i * 6 + 1] = FLOOR_Y;
    pillarPositions[i * 6 + 2] = gz;
    pillarPositions[i * 6 + 3] = gx;
    pillarPositions[i * 6 + 4] = FLOOR_Y + height;
    pillarPositions[i * 6 + 5] = gz;

    const a = 0.04 + Math.random() * 0.08;
    const ph = Math.random() * Math.PI * 2;
    pillarAlphas[i * 2] = a * 0.2;
    pillarAlphas[i * 2 + 1] = a;
    pillarPhases[i * 2] = ph;
    pillarPhases[i * 2 + 1] = ph;
  }

  const pillarGeo = new THREE.BufferGeometry();
  pillarGeo.setAttribute('position', new THREE.Float32BufferAttribute(pillarPositions, 3));
  pillarGeo.setAttribute('aAlpha', new THREE.Float32BufferAttribute(pillarAlphas, 1));
  pillarGeo.setAttribute('aPhase', new THREE.Float32BufferAttribute(pillarPhases, 1));

  const pillarMat = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    uniforms: { uTime: { value: 0 } },
    vertexShader: `
      attribute float aAlpha;
      attribute float aPhase;
      varying float vAlpha;
      uniform float uTime;
      void main() {
        vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
        float camDist = length(mvPos.xyz);
        float distFade = 1.0 - smoothstep(300.0, 1500.0, camDist);
        vAlpha = aAlpha * (0.6 + 0.4 * sin(uTime * 0.3 + aPhase * 6.28)) * distFade;
        gl_Position = projectionMatrix * mvPos;
      }
    `,
    fragmentShader: `
      varying float vAlpha;
      void main() {
        if (vAlpha < 0.003) discard;
        gl_FragColor = vec4(0.50, 0.56, 0.75, vAlpha);
      }
    `,
  });

  bgGridPillars = new THREE.LineSegments(pillarGeo, pillarMat);
  bgGridPillars.renderOrder = -9;
  scene.add(bgGridPillars);

  // ── Layer C: World-Space Floating Particles ──
  // Muted blue-grey dots — NOT camera-attached (real parallax)
  const pCount = Math.max(200, gfx.bgParticleCount || 2000);
  const pPositions = new Float32Array(pCount * 3);
  const pSizes = new Float32Array(pCount);
  const pAlphas = new Float32Array(pCount);
  const pColors = new Float32Array(pCount * 3);
  const pPhases = new Float32Array(pCount);

  for (let i = 0; i < pCount; i++) {
    const angle = Math.random() * Math.PI * 2;
    const radius = 50 + Math.random() * 2800;
    const height = FLOOR_Y + 10 + Math.random() * 600;

    pPositions[i * 3]     = Math.cos(angle) * radius;
    pPositions[i * 3 + 1] = height;
    pPositions[i * 3 + 2] = Math.sin(angle) * radius;

    const distNorm = radius / 2800;
    pSizes[i] = (1.0 - distNorm * 0.5) * (1.2 + Math.random() * 2.0);
    pAlphas[i] = (1.0 - distNorm * 0.6) * (0.03 + Math.random() * 0.09);

    // Muted blue-grey palette (matching website rgba(130,145,195))
    const v = Math.random();
    // Base: desaturated blue-grey with slight variation
    pColors[i * 3]     = 0.45 + (Math.random() - 0.5) * 0.12;
    pColors[i * 3 + 1] = 0.50 + (Math.random() - 0.5) * 0.12;
    pColors[i * 3 + 2] = 0.68 + (Math.random() - 0.5) * 0.12;
    // 15% chance of slightly warmer accent
    if (v > 0.85) {
      pColors[i * 3]     = 0.58 + Math.random() * 0.08;
      pColors[i * 3 + 1] = 0.55 + Math.random() * 0.06;
      pColors[i * 3 + 2] = 0.72 + Math.random() * 0.08;
    }

    pPhases[i] = Math.random() * Math.PI * 2;
  }

  const pGeo = new THREE.BufferGeometry();
  pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
  pGeo.setAttribute('aSize', new THREE.Float32BufferAttribute(pSizes, 1));
  pGeo.setAttribute('aAlpha', new THREE.Float32BufferAttribute(pAlphas, 1));
  pGeo.setAttribute('aColor', new THREE.Float32BufferAttribute(pColors, 3));
  pGeo.setAttribute('aPhase', new THREE.Float32BufferAttribute(pPhases, 1));

  const pMat = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    uniforms: { uTime: { value: 0 }, uIntensity: { value: gfx.bgIntensity } },
    vertexShader: `
      attribute float aSize;
      attribute float aAlpha;
      attribute vec3 aColor;
      attribute float aPhase;
      varying float vAlpha;
      varying vec3 vColor;
      uniform float uTime;
      uniform float uIntensity;
      void main() {
        vColor = aColor;
        vec3 pos = position;
        float t = uTime * 0.08 + aPhase;
        pos.y += sin(t) * 6.0;
        pos.x += cos(t * 0.7 + aPhase * 3.0) * 3.0;
        pos.z += sin(t * 0.5 + aPhase * 2.0) * 3.0;

        vec4 mvPos = modelViewMatrix * vec4(pos, 1.0);
        float camDist = length(mvPos.xyz);
        float distFade = 1.0 - smoothstep(200.0, 2800.0, camDist);

        vAlpha = aAlpha * (0.5 + 0.5 * sin(uTime * 0.4 + aPhase * 6.28)) * distFade * uIntensity;
        gl_PointSize = aSize * (400.0 / max(-mvPos.z, 1.0));
        gl_Position = projectionMatrix * mvPos;
      }
    `,
    fragmentShader: `
      varying float vAlpha;
      varying vec3 vColor;
      void main() {
        float dist = length(gl_PointCoord - vec2(0.5));
        if (dist > 0.5) discard;
        float core = smoothstep(0.5, 0.0, dist);
        float glow = smoothstep(0.5, 0.15, dist);
        float alpha = (core * 0.6 + glow * 0.4) * vAlpha;
        gl_FragColor = vec4(vColor * (0.7 + core * 0.3), alpha);
      }
    `,
  });

  bgWorldParticles = new THREE.Points(pGeo, pMat);
  bgWorldParticles.renderOrder = -8;
  scene.add(bgWorldParticles);

  // ── Layer D: Horizon Glow ──
  // Cylindrical band at the grid edge creating a soft horizon line
  const horizGeo = new THREE.CylinderGeometry(3800, 3800, 800, 64, 1, true);
  const horizMat = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    side: THREE.DoubleSide,
    blending: THREE.AdditiveBlending,
    uniforms: { uTime: { value: 0 } },
    vertexShader: `
      varying vec2 vUv;
      varying vec3 vWorldPos;
      void main() {
        vUv = uv;
        vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;
      varying vec3 vWorldPos;
      uniform float uTime;
      void main() {
        // Wide, soft gaussian-like glow centered at lower-mid height
        float center = 0.3;
        float spread = 0.4; // very wide spread
        float yFade = exp(-pow((vUv.y - center) / spread, 2.0));

        // Muted blue-grey glow
        vec3 col = vec3(0.22, 0.28, 0.42);

        // Very subtle shimmer
        float shimmer = 0.9 + 0.1 * sin(vUv.x * 20.0 + uTime * 0.15);

        float alpha = yFade * 0.025 * shimmer;
        gl_FragColor = vec4(col, alpha);
      }
    `,
  });

  bgGridFloor2 = new THREE.Mesh(horizGeo, horizMat);
  bgGridFloor2.position.y = FLOOR_Y + 20;
  bgGridFloor2.renderOrder = -7;
  scene.add(bgGridFloor2);

  // ── Layer E: Sky gradient sphere — atmospheric perspective ──
  // Inverted sphere behind everything: zenith=black, horizon=faint warm-purple
  const skyGradGeo = new THREE.SphereGeometry(30000, 24, 16);
  const skyGradMat = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    transparent: true,
    depthWrite: false,
    vertexShader: `
      varying vec3 vWorldPos;
      void main() {
        vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec3 vWorldPos;
      void main() {
        // Normalized height: 0 at bottom, 1 at top
        float h = normalize(vWorldPos).y;
        // Zenith (h=1): pure black
        vec3 zenith  = vec3(0.003, 0.003, 0.004);
        // Mid-sky (h~0.4): barely-there dark grey
        vec3 midSky  = vec3(0.01, 0.01, 0.012);
        // Horizon (h=0): subtle dark grey
        vec3 horizon = vec3(0.022, 0.02, 0.022);
        // Below horizon: black
        vec3 below   = vec3(0.002, 0.002, 0.002);

        vec3 col;
        if (h > 0.4) {
          col = mix(midSky, zenith, smoothstep(0.4, 1.0, h));
        } else if (h > 0.0) {
          col = mix(horizon, midSky, smoothstep(0.0, 0.4, h));
        } else {
          col = mix(below, horizon, smoothstep(-0.3, 0.0, h));
        }
        gl_FragColor = vec4(col, 0.95);
      }
    `,
  });
  bgSkyDome = new THREE.Mesh(skyGradGeo, skyGradMat);
  bgSkyDome.renderOrder = -10;
  scene.add(bgSkyDome);
  _cloudPlanes = [];

  // ── Layer F: World-space parallax star field ──
  // 3 shells at increasing radii with color temperature variation
  // NOT camera-attached — real parallax as camera orbits
  const shells = [
    { start: 0,    count: 600,  rMin: 3500,  rMax: 5000,  sMin: 3.0, sMax: 6.0,  aMin: 0.20, aMax: 0.50, col: [0.78, 0.74, 0.68] },  // near: warm white-gold
    { start: 600,  count: 1000, rMin: 6000,  rMax: 10000, sMin: 4.0, sMax: 8.0,  aMin: 0.15, aMax: 0.35, col: [0.62, 0.66, 0.80] },  // mid: neutral blue-white
    { start: 1600, count: 1400, rMin: 14000, rMax: 25000, sMin: 6.0, sMax: 14.0, aMin: 0.10, aMax: 0.25, col: [0.48, 0.50, 0.75] },  // far: cool blue-violet
  ];
  const spCount = 3000;
  const spPositions = new Float32Array(spCount * 3);
  const spSizes = new Float32Array(spCount);
  const spAlphas = new Float32Array(spCount);
  const spColors = new Float32Array(spCount * 3);
  const spPhases = new Float32Array(spCount);

  for (const shell of shells) {
    for (let i = 0; i < shell.count; i++) {
      const idx = shell.start + i;
      // Fibonacci sphere, upper hemisphere bias
      const y = 1 - (i / shell.count) * 1.5; // range 1 to -0.5
      const xyRadius = Math.sqrt(Math.max(0, 1 - y * y));
      const theta = Math.PI * (1 + Math.sqrt(5)) * i;
      const r = shell.rMin + Math.random() * (shell.rMax - shell.rMin);

      spPositions[idx * 3]     = Math.cos(theta) * xyRadius * r;
      spPositions[idx * 3 + 1] = y * r;
      spPositions[idx * 3 + 2] = Math.sin(theta) * xyRadius * r;

      spSizes[idx] = shell.sMin + Math.random() * (shell.sMax - shell.sMin);
      spAlphas[idx] = shell.aMin + Math.random() * (shell.aMax - shell.aMin);
      // Color with slight per-star variation
      spColors[idx * 3]     = shell.col[0] + (Math.random() - 0.5) * 0.08;
      spColors[idx * 3 + 1] = shell.col[1] + (Math.random() - 0.5) * 0.08;
      spColors[idx * 3 + 2] = shell.col[2] + (Math.random() - 0.5) * 0.08;
      spPhases[idx] = Math.random() * Math.PI * 2;
    }
  }

  const spGeo = new THREE.BufferGeometry();
  spGeo.setAttribute('position', new THREE.Float32BufferAttribute(spPositions, 3));
  spGeo.setAttribute('aSize', new THREE.Float32BufferAttribute(spSizes, 1));
  spGeo.setAttribute('aAlpha', new THREE.Float32BufferAttribute(spAlphas, 1));
  spGeo.setAttribute('aColor', new THREE.Float32BufferAttribute(spColors, 3));
  spGeo.setAttribute('aPhase', new THREE.Float32BufferAttribute(spPhases, 1));

  const spMat = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    uniforms: { uTime: { value: 0 } },
    vertexShader: `
      attribute float aSize;
      attribute float aAlpha;
      attribute vec3 aColor;
      attribute float aPhase;
      varying float vAlpha;
      varying vec3 vColor;
      uniform float uTime;
      void main() {
        vColor = aColor;
        // Differential Y-axis rotation: near stars drift faster than far stars
        float r = length(position);
        float rotSpeed = mix(0.003, 0.0008, smoothstep(3500.0, 25000.0, r));
        float angle = uTime * rotSpeed;
        float cs = cos(angle);
        float sn = sin(angle);
        vec3 rotPos = vec3(
          position.x * cs - position.z * sn,
          position.y,
          position.x * sn + position.z * cs
        );
        vec4 mvPos = modelViewMatrix * vec4(rotPos, 1.0);
        vAlpha = aAlpha * (0.3 + 0.7 * sin(uTime * 0.6 + aPhase * 6.28));
        // Perspective size with floor so distant stars stay visible
        gl_PointSize = max(1.0, aSize * (3000.0 / max(-mvPos.z, 1.0)));
        gl_Position = projectionMatrix * mvPos;
      }
    `,
    fragmentShader: `
      varying float vAlpha;
      varying vec3 vColor;
      void main() {
        float dist = length(gl_PointCoord - vec2(0.5));
        if (dist > 0.5) discard;
        float core = exp(-dist * dist * 80.0);
        float glow = exp(-dist * dist * 12.0) * 0.2;
        gl_FragColor = vec4(vColor, (core + glow) * vAlpha);
      }
    `,
  });

  bgSkyParticles = new THREE.Points(spGeo, spMat);
  bgSkyParticles.renderOrder = -6;
  scene.add(bgSkyParticles);

  // ── Scene fog for atmospheric depth ──
  scene.fog = new THREE.FogExp2(0x000000, 0.00012);

  // ── Camera constraints & orbit polish ──
  const controls = graph.controls();
  if (controls) {
    // Zoom limit: keep camera inside the sky dome
    controls.maxDistance = 2800;
    controls.minDistance = 30;

    // Enable damping for smooth, polished orbit feel
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;

    // Smoother zoom
    controls.zoomSpeed = 0.8;

    // Smoother rotation
    controls.rotateSpeed = 0.6;

    // Smoother pan
    controls.panSpeed = 0.6;

    // Don't auto-rotate
    controls.autoRotate = false;

    // Floor + ceiling constraint via update override
    _origControlsUpdate = controls.update.bind(controls);
    controls.update = function() {
      _origControlsUpdate();
      const cam = graph.camera();
      if (cam.position.y < FLOOR_Y + 15) cam.position.y = FLOOR_Y + 15;
      if (cam.position.y > 2500) cam.position.y = 2500;
    };
  }
}

// ═══════════════════════════════════════════
// BACKGROUND — Dispatcher
// Calls the right background builder based on theme
// ═══════════════════════════════════════════
function removeBackground() {
  const scene = graph.scene();
  // Remove deep-grid objects (floor is managed separately by removeFloor)
  if (bgGridPillars) { scene.remove(bgGridPillars); bgGridPillars.geometry.dispose(); bgGridPillars.material.dispose(); bgGridPillars = null; }
  if (bgWorldParticles) { scene.remove(bgWorldParticles); bgWorldParticles.geometry.dispose(); bgWorldParticles.material.dispose(); bgWorldParticles = null; }
  if (bgGridFloor2) { scene.remove(bgGridFloor2); bgGridFloor2.geometry.dispose(); bgGridFloor2.material.dispose(); bgGridFloor2 = null; }
  if (bgSkyDome) {
    scene.remove(bgSkyDome);
    if (bgSkyDome.isGroup) {
      bgSkyDome.children.forEach(c => { c.geometry.dispose(); c.material.dispose(); });
    } else {
      bgSkyDome.geometry.dispose(); bgSkyDome.material.dispose();
    }
    bgSkyDome = null; _cloudPlanes = [];
  }
  if (bgSkyParticles) { scene.remove(bgSkyParticles); bgSkyParticles.geometry.dispose(); bgSkyParticles.material.dispose(); bgSkyParticles = null; }
  // Restore original controls if overridden
  const controls = graph.controls();
  if (controls && _origControlsUpdate) {
    controls.update = _origControlsUpdate;
    _origControlsUpdate = null;
    controls.maxDistance = Infinity;
    controls.minDistance = 0;
  }
  // Clear scene fog
  scene.fog = null;
}

function applyBgTheme() {
  if (!graph) return;
  removeBackground();
  addBackgroundDeepGrid();
  graph.backgroundColor('#000000');
  if (_bloomPass) {
    _bloomPass.strength = 0.2;
    _bloomPass.threshold = 0.5;
    _bloomPass.radius = 0.3;
  }
  applyFloorStyle(gfx.floorStyle || 'grid');
}

// ═══════════════════════════════════════════
// ANIMATION LOOP
// ═══════════════════════════════════════════
function animate() {
  animFrameId = requestAnimationFrame(animate);
  const time = performance.now() * 0.001;

  TWEEN.update();

  // WASD camera movement (every frame)
  updateCameraMovement();

  // Update 3D mouse position via raycasting
  updateMouse3D();

  // ── Floor effect (independent of bg theme) ──
  if (floorMesh && floorMesh.material.uniforms) {
    if (floorMesh.material.uniforms.uTime) floorMesh.material.uniforms.uTime.value = time;
    if (floorMesh.material.uniforms.uCamY && graph) floorMesh.material.uniforms.uCamY.value = graph.camera().position.y;
  }
  if (floorParticles && floorParticles.material.uniforms) {
    if (floorParticles.material.uniforms.uTime) floorParticles.material.uniforms.uTime.value = time;
    if (floorParticles.material.uniforms.uCamPos && graph) floorParticles.material.uniforms.uCamPos.value.copy(graph.camera().position);
  }

  // ── Background — Deep Grid theme (world-space, real depth) ──
  if (bgGridPillars) {
    bgGridPillars.material.uniforms.uTime.value = time;
  }
  if (bgWorldParticles) {
    bgWorldParticles.material.uniforms.uTime.value = time;
    bgWorldParticles.material.uniforms.uIntensity.value = gfx.bgIntensity;
  }
  if (bgGridFloor2) {
    bgGridFloor2.material.uniforms.uTime.value = time;
  }
  // Layer F: world-space stars (no camera-attach — real parallax)
  if (bgSkyParticles) {
    bgSkyParticles.material.uniforms.uTime.value = time;
  }

  // ── Mouse-reactive plexus ──
  if (graph) {
    // ── NODE PASS — iterate graph nodes directly (avoids costly scene.traverse) ──
    const gd = graph.graphData();
    const _cam = graph.camera();

    // Build frustum once per frame for CPU-side culling
    _cam.updateMatrixWorld();
    _projScreenMatrix.multiplyMatrices(_cam.projectionMatrix, _cam.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix);
    // Padded frustum — 60-unit margin for labels that scale up to 6x
    _frustumPadded.copy(_frustum);
    for (let _pi = 0; _pi < 6; _pi++) _frustumPadded.planes[_pi].constant += 60;

    for (let _ni = 0, _nlen = gd.nodes.length; _ni < _nlen; _ni++) {
      const obj = gd.nodes[_ni].__threeObj;
      if (!obj || !obj.userData || !obj.userData.nodeId) continue;

      const dot = obj.userData.dot;
      const label = obj.userData.label;
      const phase = obj.userData.phase || 0;
      const isCatHidden = !activeCategories.has(obj.userData.category);
      const isHovered = obj.userData.nodeId === hoveredNodeId;
      const isSelected = obj.userData.nodeId === selectedNodeId;
      const isMultiSelected = _multiSelected.has(obj.userData.nodeId);

      // Frustum culling — skip expensive per-node work for off-screen nodes
      obj.getWorldPosition(_worldPos);
      let _cullZone = 0; // 0=inside, 1=margin (fading), 2=fully outside
      if (!_frustum.containsPoint(_worldPos)) {
        _cullZone = _frustumPadded.containsPoint(_worldPos) ? 1 : 2;
      }
      // Force-include interactive nodes — never cull what the user is touching
      if (isHovered || isSelected || (_drag.active && _drag.dragSet.has(obj.userData.nodeId))) {
        _cullZone = 0;
      }
      // Zone 2: fully outside — decay to invisible, skip everything else
      if (_cullZone === 2) {
        if (dot) {
          dot.material.opacity *= 0.85;
          if (dot.material.opacity < 0.005) dot.material.opacity = 0;
        }
        if (label) {
          label.material.opacity *= 0.85;
          if (label.material.opacity < 0.005) label.material.opacity = 0;
        }
        const _glowCull = obj.userData.glow;
        if (_glowCull) {
          _glowCull.material.opacity *= 0.85;
          if (_glowCull.material.opacity < 0.005) _glowCull.material.opacity = 0;
        }
        if (obj.userData._currentScale > 0.01) {
          obj.userData._currentScale *= 0.9;
          obj.scale.setScalar(obj.userData._currentScale);
        }
        continue;
      }

      // Compute mouse proximity (0=far, 1=touching) — skip for margin zone
      let mouseProx = 0;
      if (_cullZone === 0 && _mouse3DValid && _mouse3D.lengthSq() > 0) {
        const mouseDist = _mouse3D.distanceTo(_worldPos);
        mouseProx = 1 - Math.min(mouseDist / PLEXUS_RADIUS, 1);
        mouseProx = mouseProx * mouseProx; // quadratic
      }

      // Breathe
      const breathe = 1 + Math.sin(time * 0.5 + phase) * 0.03;

      // ── Anchor nodes — ALWAYS visible with readable labels ──
      if (obj.userData.isAnchor) {
        const baseOp = obj.userData.baseOpacity;
        let dotTarget = baseOp + mouseProx * 0.2;
        let labelTarget = 0.85;
        if (!labelsVisible) labelTarget = 0;

        if (isCatHidden) { dotTarget = 0; labelTarget = 0; }
        else if (searchResults !== null && !searchResults.has(obj.userData.nodeId)) {
          dotTarget *= 0.4; labelTarget *= 0.4;
        }
        if (_drag.active && !isCatHidden) {
          if (_drag.dragSet.has(obj.userData.nodeId)) dotTarget = Math.max(dotTarget, 0.9);
          else { dotTarget *= 0.5; labelTarget *= 0.4; }
        }
        if (isHovered) { dotTarget = 1.0; labelTarget = 1.0; }
        if (isSelected) dotTarget = 1.0;
        if (_cullZone === 1) { dotTarget *= 0.3; labelTarget *= 0.3; }

        const fade = isCatHidden ? 0.15 : 0.1;
        if (dot) dot.material.opacity += (dotTarget * breathe - dot.material.opacity) * fade;
        if (label) label.material.opacity += (labelTarget - label.material.opacity) * fade;

        // Distance-adaptive label scaling — stays readable from far away
        if (label && obj.userData.baseLabelScale) {
          const camDist = _cam.position.distanceTo(_worldPos);
          // Scale up more aggressively with distance so labels stay legible
          const scaleFactor = Math.max(1.0, Math.min(6.0, camDist / 100)) * labelSizeMultiplier;
          const bls = obj.userData.baseLabelScale;
          label.scale.set(bls.x * scaleFactor, bls.y * scaleFactor, 1);
        }

        // Anchor always full size (no mouse-based swell, just breathe)
        let targetScale = isCatHidden ? 0 : breathe;
        if (isHovered) targetScale *= 1.15;
        if (obj.userData._currentScale == null) obj.userData._currentScale = 0.01;
        obj.userData._currentScale += (targetScale - obj.userData._currentScale) * 0.1;
        obj.scale.setScalar(obj.userData._currentScale);
        continue;
      }

      // ── Tag nodes — visible labels that scale with distance ──
      if (obj.userData.isTag) {
        const baseOp = obj.userData.baseOpacity;
        let dotTarget = baseOp + mouseProx * 0.3;
        let labelTarget = 0.6;
        if (!labelsVisible) labelTarget = 0;

        if (isCatHidden) { dotTarget = 0; labelTarget = 0; }
        else if (searchResults !== null && !searchResults.has(obj.userData.nodeId)) {
          dotTarget *= 0.35; labelTarget *= 0.35;
        }
        if (_drag.active && !isCatHidden) {
          if (_drag.dragSet.has(obj.userData.nodeId)) dotTarget = Math.max(dotTarget, 0.8);
          else { dotTarget *= 0.4; labelTarget *= 0.3; }
        }
        if (isHovered) { dotTarget = 0.9; labelTarget = 0.9; }
        if (isSelected) dotTarget = 1.0;
        if (_cullZone === 1) { dotTarget *= 0.3; labelTarget *= 0.3; }

        const fade = isCatHidden ? 0.15 : 0.1;
        if (dot) dot.material.opacity += (dotTarget * breathe - dot.material.opacity) * fade;
        if (label) label.material.opacity += (labelTarget - label.material.opacity) * fade;

        // Distance-adaptive label scaling
        if (label && obj.userData.baseLabelScale) {
          const camDist = _cam.position.distanceTo(_worldPos);
          const scaleFactor = Math.max(0.8, Math.min(4.0, camDist / 80)) * labelSizeMultiplier;
          const bls = obj.userData.baseLabelScale;
          label.scale.set(bls.x * scaleFactor, bls.y * scaleFactor, 1);
          label.position.y = (obj.userData.baseLabelY || obj.userData.baseRadius * 1.0) * scaleFactor;
        }

        let targetScale = isCatHidden ? 0 : breathe * (1 + mouseProx * 0.1);
        if (isHovered) targetScale *= 1.1;
        if (obj.userData._currentScale == null) obj.userData._currentScale = 0.01;
        obj.userData._currentScale += (targetScale - obj.userData._currentScale) * 0.1;
        obj.scale.setScalar(obj.userData._currentScale);
        continue;
      }

      // ── Memory nodes — wireframe geodesic ──
      if (!dot) continue;

      const baseOp = obj.userData.baseOpacity;
      let dotTarget = baseOp + mouseProx * 0.15;

      if (searchResults !== null) {
        dotTarget = searchResults.has(obj.userData.nodeId) ? 0.5 : 0.02;
      }
      if (isCatHidden) dotTarget = 0;
      if (_drag.active && !isCatHidden) {
        if (_drag.dragSet.has(obj.userData.nodeId)) dotTarget = Math.max(dotTarget, 0.35);
        else dotTarget *= 0.35;
      }
      if (isHovered) dotTarget = 0.45;
      if (isSelected) dotTarget = 0.55 + 0.05 * Math.sin(time * 2.5);
      if (isMultiSelected) dotTarget = 0.5;
      if (_cullZone === 1) dotTarget *= 0.3;

      const fadeSpeed = isCatHidden ? 0.18 : 0.12;
      dot.material.opacity += (dotTarget * breathe - dot.material.opacity) * fadeSpeed;

      // Sync glow sprite opacity
      const glowSprite = obj.userData.glow;
      if (glowSprite) {
        glowSprite.material.opacity += (dotTarget * 0.3 * breathe - glowSprite.material.opacity) * fadeSpeed;
      }

      // Multi-select: tint wireframe blue, or restore original color
      if (isMultiSelected) {
        dot.material.color.lerp(_MULTI_SELECT_BLUE, 0.15);
        if (glowSprite) glowSprite.material.color.lerp(_MULTI_SELECT_BLUE, 0.15);
      } else if (obj.userData.baseColor) {
        dot.material.color.lerp(obj.userData.baseColor, 0.1);
        if (glowSprite) glowSprite.material.color.lerp(obj.userData.baseColor, 0.1);
      }

      // Slow rotation — each node spins at its own rate
      const rotSpeed = 0.15 + (obj.userData.importance || 5) * 0.02;
      dot.rotation.y += rotSpeed * 0.016; // ~per frame at 60fps
      dot.rotation.x += rotSpeed * 0.008;

      // Scale: mouse proximity swells nodes, hovered/selected bigger
      let scaleMultiplier = 1 + mouseProx * 0.3;
      if (isCatHidden) scaleMultiplier = 0;
      else if (isSelected) scaleMultiplier = 2.0;
      else if (isMultiSelected) scaleMultiplier = 1.5;
      else if (isHovered) scaleMultiplier = 1.6;
      const targetScale = breathe * scaleMultiplier * noLinksScaleBoost;
      if (obj.userData._currentScale == null) obj.userData._currentScale = 0.01;
      obj.userData._currentScale += (targetScale - obj.userData._currentScale) * 0.12;
      obj.scale.setScalar(obj.userData._currentScale);
    }

    // ── LINK BATCH — single draw call for all visible links ──
    // Visual links are stored in _visualLinks (NOT in gd.links). Positions
    // resolved via _nodeById map since links aren't in the force graph.
    if (_linkBatch) {
      // Rebuild visible link list + colors when data or mode changed
      if (_linkBatchDirty && _nodeById.size > 0) {
        _batchLinks.length = 0;
        if (_linkMode !== 'off') {
          const grey = { r: 0.45, g: 0.45, b: 0.45 };
          const colorCache = new Map();
          function _getMuted(cat) {
            let c = colorCache.get(cat);
            if (!c) {
              const base = new THREE.Color(catColor(cat));
              c = { r: base.r + (grey.r - base.r) * 0.5, g: base.g + (grey.g - base.g) * 0.5, b: base.b + (grey.b - base.b) * 0.5 };
              colorCache.set(cat, c);
            }
            return c;
          }
          const cols = _linkBatchColors;
          let ci = 0;
          for (let li = 0, ll = _visualLinks.length; li < ll; li++) {
            const link = _visualLinks[li];
            if (_linkMode === 'intra' && link._crossCategory) continue;
            if (_linkTypeFilter !== 'all' && (!link.types || !link.types.includes(_linkTypeFilter))) continue;
            const srcId = link.source.id || link.source;
            const tgtId = link.target.id || link.target;
            const srcNode = _nodeById.get(srcId);
            const tgtNode = _nodeById.get(tgtId);
            if (!srcNode || !tgtNode) continue;
            // Hide links when either endpoint's category is deselected
            const srcCat = srcNode.payload ? srcNode.payload.category : null;
            const tgtCat = tgtNode.payload ? tgtNode.payload.category : null;
            if (srcCat && !activeCategories.has(srcCat)) continue;
            if (tgtCat && !activeCategories.has(tgtCat)) continue;
            if (ci + 6 > cols.length) break;
            // Store resolved node refs for fast position lookup per frame
            link._srcNode = srcNode;
            link._tgtNode = tgtNode;
            _batchLinks.push(link);
            const sc = _getMuted(srcNode.payload ? srcNode.payload.category : '_fallback');
            const tc = _getMuted(tgtNode.payload ? tgtNode.payload.category : '_fallback');
            cols[ci] = sc.r; cols[ci + 1] = sc.g; cols[ci + 2] = sc.b;
            cols[ci + 3] = tc.r; cols[ci + 4] = tc.g; cols[ci + 5] = tc.b;
            ci += 6;
          }
          _linkBatchGeo.attributes.color.needsUpdate = true;
        }
        _linkBatchDirty = false;
      }

      // Update positions every frame (nodes move during drag)
      const bl = _batchLinks;
      const blen = bl.length;
      if (blen > 0) {
        const pos = _linkBatchPositions;
        let pi = 0;
        for (let i = 0; i < blen; i++) {
          const s = bl[i]._srcNode, t = bl[i]._tgtNode;
          pos[pi] = s.x; pos[pi + 1] = s.y; pos[pi + 2] = s.z;
          pos[pi + 3] = t.x; pos[pi + 4] = t.y; pos[pi + 5] = t.z;
          pi += 6;
        }
        _linkBatchGeo.attributes.position.needsUpdate = true;
        _linkBatchGeo.setDrawRange(0, blen * 2);
      } else {
        _linkBatchGeo.setDrawRange(0, 0);
      }

      // Sync opacity from GFX slider
      const targetOp = gfx.linkOpacity || 0.12;
      if (_linkBatch.material.opacity !== targetOp) _linkBatch.material.opacity = targetOp;
    }
  }
}

// ═══════════════════════════════════════════
// INTERACTIONS
// ═══════════════════════════════════════════
let _pointerOverUI = false;
document.querySelectorAll('.glass, #title-bar, #search-container, #stats-bar').forEach(el => {
  el.addEventListener('pointerenter', () => { _pointerOverUI = true; }, true);
  el.addEventListener('pointerleave', () => { _pointerOverUI = false; }, true);
});

function handleNodeHover(node, prevNode) {
  if (_pointerOverUI) {
    $tooltip.classList.remove('visible');
    if ($tooltip._moveHandler) {
      document.removeEventListener('mousemove', $tooltip._moveHandler);
    }
    document.body.style.cursor = 'default';
    return;
  }
  if (_drag.active) {
    document.body.style.cursor = 'grabbing';
  } else {
    document.body.style.cursor = node ? 'grab' : 'default';
  }
  hoveredNodeId = node ? node.id : null;

  if (node) {
    const cat = node.payload.category;

    // Anchor / tag nodes get simplified tooltips
    if (node.payload._isAnchor) {
      document.getElementById('tooltip-category').textContent = cat.toUpperCase();
      document.getElementById('tooltip-category').style.color = catColor(cat);
      const childCount = Object.entries(categoryMetadata).filter(([, m]) => m.parent === cat).length;
      document.getElementById('tooltip-preview').textContent = `Parent category \u2022 ${childCount} sub-categories`;
      document.getElementById('tooltip-importance').textContent = '\u2606';
    } else if (node.payload._isTag) {
      document.getElementById('tooltip-category').textContent = cat;
      document.getElementById('tooltip-category').style.color = catColor(cat);
      const memCount = allNodes.filter(n => n.payload.category === cat).length;
      document.getElementById('tooltip-preview').textContent = `${memCount} memories`;
      document.getElementById('tooltip-importance').textContent = '\u25cf';
    } else {
      const imp = node.payload.importance || 5;
      const preview = truncate(node.payload.content, 100);
      const catText = node.payload._isOpenClaw ? '[OC] ' + cat : cat;
      document.getElementById('tooltip-category').textContent = catText;
      document.getElementById('tooltip-category').style.color = catColor(cat);
      document.getElementById('tooltip-preview').textContent = preview;
      document.getElementById('tooltip-importance').textContent = '\u2605'.repeat(Math.min(imp, 10));
    }

    // Position tooltip near cursor
    const moveTooltip = (e) => {
      $tooltip.style.left = (e.clientX + 16) + 'px';
      $tooltip.style.top = (e.clientY + 16) + 'px';
    };
    document.addEventListener('mousemove', moveTooltip);
    $tooltip._moveHandler = moveTooltip;
    $tooltip.classList.add('visible');
  } else {
    $tooltip.classList.remove('visible');
    if ($tooltip._moveHandler) {
      document.removeEventListener('mousemove', $tooltip._moveHandler);
    }
  }
}

function updateMultiSelectBar() {
  const bar = document.getElementById('multi-select-bar');
  if (_multiSelected.size > 0) {
    document.getElementById('multi-select-count').textContent = _multiSelected.size + ' selected';
    bar.classList.add('open');
  } else {
    bar.classList.remove('open');
  }
}

function clearMultiSelect() {
  _multiSelected.clear();
  updateMultiSelectBar();
}

function handleNodeClick(node, event) {
  if (!node || _pointerOverUI) return;
  // Anchor nodes: zoom to fit entire category cluster
  if (node.payload._isAnchor) {
    const parentName = node.payload._anchorCategory;
    const gd = graph.graphData();
    // Find all nodes belonging to this parent's tree
    const childCats = Object.entries(categoryMetadata)
      .filter(([, m]) => m.parent === parentName)
      .map(([name]) => name);
    const treeCats = new Set([parentName, ...childCats]);
    const treeNodes = gd.nodes.filter(n =>
      n.payload && (treeCats.has(n.payload.category) || n.payload._anchorCategory === parentName || (n.payload._tagCategory && treeCats.has(n.payload._tagCategory)))
    );
    if (treeNodes.length === 0) return;

    // Compute bounding box center and size
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    for (const n of treeNodes) {
      const x = n.x || 0, y = n.y || 0, z = n.z || 0;
      if (x < minX) minX = x; if (x > maxX) maxX = x;
      if (y < minY) minY = y; if (y > maxY) maxY = y;
      if (z < minZ) minZ = z; if (z > maxZ) maxZ = z;
    }
    const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2, cz = (minZ + maxZ) / 2;
    const span = Math.max(maxX - minX, maxY - minY, maxZ - minZ, 30);
    // Camera distance = enough to see the whole cluster with padding
    const dist = span * 1.2 + 40;
    graph.cameraPosition(
      { x: cx + dist * 0.5, y: cy + dist * 0.35, z: cz + dist * 0.5 },
      { x: cx, y: cy, z: cz },
      1500
    );
    return;
  }
  // Tag nodes: zoom to show tag + its memory sphere
  if (node.payload._isTag) {
    const tagCat = node.payload._tagCategory;
    const gd = graph.graphData();
    const tagMems = gd.nodes.filter(n => n.payload && n.payload.category === tagCat && !n.payload._isAnchor && !n.payload._isTag);
    if (tagMems.length > 0) {
      // Compute bounding box of tag + its memories
      let minX = node.x, maxX = node.x, minY = node.y, maxY = node.y, minZ = node.z, maxZ = node.z;
      for (const n of tagMems) {
        const x = n.x || 0, y = n.y || 0, z = n.z || 0;
        if (x < minX) minX = x; if (x > maxX) maxX = x;
        if (y < minY) minY = y; if (y > maxY) maxY = y;
        if (z < minZ) minZ = z; if (z > maxZ) maxZ = z;
      }
      const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2, cz = (minZ + maxZ) / 2;
      const span = Math.max(maxX - minX, maxY - minY, maxZ - minZ, 30);
      const dist = span * 1.1 + 30;
      graph.cameraPosition(
        { x: cx + dist * 0.5, y: cy + dist * 0.3, z: cz + dist * 0.5 },
        { x: cx, y: cy, z: cz },
        1500
      );
    } else {
      const dist = gfx.gentleZoom;
      graph.cameraPosition(
        { x: node.x + dist, y: node.y + dist * 0.4, z: node.z + dist },
        { x: node.x, y: node.y, z: node.z },
        1500
      );
    }
    return;
  }

  // Ctrl+Click: toggle multi-select
  if (event && (event.ctrlKey || event.metaKey)) {
    if (_multiSelected.has(node.id)) {
      _multiSelected.delete(node.id);
    } else {
      _multiSelected.add(node.id);
    }
    updateMultiSelectBar();
    return;
  }

  // Regular click: clear multi-select, do normal navigation
  if (_multiSelected.size > 0) clearMultiSelect();
  navigateToNode(node);
}

function navigateToNode(node, { zoom = 'close' } = {}) {
  if (!node) return;
  // Don't select virtual nodes as regular selections
  if (node.payload && (node.payload._isAnchor || node.payload._isTag)) return;
  selectedNodeId = node.id;
  localStorage.setItem('neural-selected-node', node.id);

  // Ensure category is visible
  if (!activeCategories.has(node.payload.category)) {
    activeCategories.add(node.payload.category);
    buildCategorySidebar();
  }

  // If focus mode is on, switch focus to the newly clicked node
  if (focusedNodeId !== null) {
    focusedNodeId = node.id;
    applyGraphData();
    updateStats();
  }

  // Camera transition
  const dist = zoom === 'gentle' ? gfx.gentleZoom : gfx.clickZoom;
  graph.cameraPosition(
    { x: node.x + dist, y: node.y + dist * 0.4, z: node.z + dist },
    { x: node.x, y: node.y, z: node.z },
    1500
  );

  showDetailPanel(node);
}

function closeDetailPanel() {
  const wasFocused = focusedNodeId !== null;
  selectedNodeId = null;
  focusedNodeId = null;
  if (_multiSelected.size > 0) clearMultiSelect();
  localStorage.removeItem('neural-selected-node');
  $detailPanel.classList.remove('open');
  document.getElementById('detail-focus-btn').classList.remove('active');
  // Reset to CSS-default so the slide-out works even if user dragged it
  $detailPanel.style.left = '';
  $detailPanel.style.top = '';
  $detailPanel.style.right = '';
  // Restore full graph if focus was active
  if (wasFocused) {
    applyGraphData();
    updateStats();
  }
}


function exportMemoryAsMarkdown(node) {
  const p = node.payload;
  const lines = [];

  // Title — first meaningful line of content, or category
  const firstLine = (p.content || '').split('\n').find(l => l.trim()) || p.category || 'Memory';
  const title = firstLine.length > 80 ? firstLine.slice(0, 80) + '...' : firstLine;
  lines.push(`# ${title}`);
  lines.push('');

  // Metadata table
  lines.push('| Field | Value |');
  lines.push('|-------|-------|');
  lines.push(`| Category | ${p.category}${p.subcategory ? ' / ' + p.subcategory : ''} |`);
  lines.push(`| Importance | ${p.importance || 5}/10 |`);
  if (p.project) lines.push(`| Project | ${p.project} |`);
  if (p.source) lines.push(`| Source | ${p.source} |`);
  if (p.created_at) lines.push(`| Created | ${new Date(p.created_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} |`);
  if (p.updated_at) lines.push(`| Updated | ${new Date(p.updated_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} |`);
  lines.push(`| ID | \`${node.id}\` |`);
  lines.push('');

  // Tags
  const tags = (p.tags && Array.isArray(p.tags) && p.tags.length) ? p.tags : null;
  if (tags) {
    lines.push(`**Tags:** ${tags.map(t => '`' + t + '`').join(' ')}`);
    lines.push('');
  }

  // Content
  lines.push('## Content');
  lines.push('');
  lines.push(p.content || '*(empty)*');
  lines.push('');

  // Related files
  if (p.related_files && p.related_files.length) {
    lines.push('## Related Files');
    lines.push('');
    p.related_files.forEach(f => lines.push(`- \`${f}\``));
    lines.push('');
  }

  const md = lines.join('\n');

  // Build filename from category + truncated content
  const slug = (p.category + (p.subcategory ? '-' + p.subcategory : '')).replace(/[^a-zA-Z0-9-]/g, '-').toLowerCase();
  const contentSlug = (p.content || 'memory').split('\n')[0].trim().slice(0, 40).replace(/[^a-zA-Z0-9 ]/g, '').trim().replace(/\s+/g, '-').toLowerCase();
  const filename = `${slug}--${contentSlug || 'memory'}.md`;

  // Trigger download
  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

async function deleteMemoryFromUI(node) {

  try {
    const res = await fetch('/api/memory/' + encodeURIComponent(node.id), { method: 'DELETE' });
    if (!res.ok) {
      let errMsg = 'Delete failed (' + res.status + ')';
      try { const err = await res.json(); errMsg = err.error || errMsg; } catch {}
      console.error('deleteMemory error:', errMsg);
      if (confirmBtn) { confirmBtn.textContent = errMsg; confirmBtn.disabled = false; }
      return;
    }

    // Remove from local data
    allNodes = allNodes.filter(n => n.id !== node.id);
    allLinks = allLinks.filter(l => l.source !== node.id && l.target !== node.id &&
      l.source?.id !== node.id && l.target?.id !== node.id);

    // Close detail panel and rebuild
    closeDetailPanel();
    const presentCats = new Set(allNodes.map(n => n.payload.category));
    buildCategorySidebar(presentCats);
    applyGraphData();
    updateStats();

    // Update trash badge (memory moved to trash)
    try { fetchTrashItems(); } catch {}
  } catch (e) {
    console.error('deleteMemory fetch error:', e);
    if (confirmBtn) { confirmBtn.textContent = e.message || 'Network error'; confirmBtn.disabled = false; }
  }
}

function handleBackgroundClick() {
  // Don't close detail panel on background click — bad UX
  // Panel should only close via the X button
}

function formatMemoryContent(text) {
  if (!text) return '';

  const esc = s => s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');

  // Inline formatting: `code`, **bold**, *italic*, em-dash descriptions
  function inlineFmt(s) {
    let out = esc(s);
    // Backtick code spans
    out = out.replace(/`([^`]+)`/g, '<code>$1</code>');
    // Bold
    out = out.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    // Italic
    out = out.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<em>$1</em>');
    // Em-dash description split (` — ` becomes dimmed after)
    out = out.replace(/ — (.+)$/, ' <span class="kv-desc">\u2014 $1</span>');
    return out;
  }

  const lines = text.split('\n');
  let html = '';
  let inList = false;
  let inCode = false;

  function closeList() { if (inList) { html += '</ul>'; inList = false; } }

  for (let i = 0; i < lines.length; i++) {
    const raw = lines[i];
    const trimmed = raw.trim();

    // Empty line
    if (!trimmed) {
      if (inCode) { html += '\n'; continue; }
      closeList();
      continue;
    }

    // Code block fences
    if (trimmed.startsWith('```')) {
      if (inCode) { html += '</div>'; inCode = false; }
      else { closeList(); inCode = true; html += '<div class="mc-codeblock">'; }
      continue;
    }
    if (inCode) { html += esc(raw) + '\n'; continue; }

    // Markdown headings ## / ### / ####
    const headingMatch = trimmed.match(/^(#{1,4})\s+(.+)$/);
    if (headingMatch) {
      closeList();
      const level = headingMatch[1].length;
      const cls = level <= 2 ? 'mc-h2' : level === 3 ? 'mc-h3' : 'mc-h4';
      html += `<div class="${cls}">${inlineFmt(headingMatch[2])}</div>`;
      continue;
    }

    // Separator lines
    if (/^[-=_]{3,}$/.test(trimmed)) {
      closeList();
      html += '<div class="mc-divider"></div>';
      continue;
    }

    // Standalone backtick line (full line is a code key pattern)
    if (trimmed.startsWith('`') && trimmed.endsWith('`') && !trimmed.includes(' ')) {
      closeList();
      html += `<p>${inlineFmt(trimmed)}</p>`;
      continue;
    }

    // Backtick line followed by em-dash description
    if (/^`[^`]+`\s+—\s+/.test(trimmed)) {
      closeList();
      html += `<p>${inlineFmt(trimmed)}</p>`;
      continue;
    }

    // List items (- or * or numbered)
    if (/^[-*\u2022]\s/.test(trimmed) || /^\d+[.)]\s/.test(trimmed)) {
      if (!inList) { html += '<ul>'; inList = true; }
      const content = trimmed.replace(/^[-*\u2022]\s+/, '').replace(/^\d+[.)]\s+/, '');
      html += `<li>${inlineFmt(content)}</li>`;
      continue;
    }

    // Heading-like: short line ending with colon (not containing backticks — those are code patterns)
    if (trimmed.endsWith(':') && trimmed.length < 50 && !trimmed.includes('`') && !/\s{2,}/.test(trimmed)) {
      closeList();
      html += `<div class="mc-h3">${inlineFmt(trimmed.slice(0, -1))}</div>`;
      continue;
    }

    // Key: Value (label < 25 chars, then colon + space + value)
    const kvMatch = trimmed.match(/^([A-Za-z][\w\s/().,-]{0,24}?)\s{2,}(.+)$/);
    if (kvMatch) {
      closeList();
      html += `<div class="mc-kv"><span class="mc-kv-key">${esc(kvMatch[1])}</span> <span class="mc-kv-val">${inlineFmt(kvMatch[2])}</span></div>`;
      continue;
    }

    // Regular paragraph
    closeList();
    html += `<p>${inlineFmt(trimmed)}</p>`;
  }

  closeList();
  if (inCode) html += '</div>';
  return html;
}

function showTagDeleteModal(tagName, onConfirm) {
  const overlay = document.createElement('div');
  overlay.className = 'tag-delete-overlay';
  overlay.innerHTML = `
    <div class="tag-delete-modal">
      <div class="tag-delete-modal-title">Remove tag</div>
      <div class="tag-delete-modal-tag">${tagName}</div>
      <div class="tag-delete-modal-actions">
        <button class="action-btn action-btn--ghost tag-modal-cancel">Cancel</button>
        <button class="action-btn action-btn--danger tag-modal-confirm">Delete</button>
      </div>
    </div>
  `;
  document.body.appendChild(overlay);
  overlay.querySelector('.tag-modal-cancel').addEventListener('click', () => overlay.remove());
  overlay.querySelector('.tag-modal-confirm').addEventListener('click', () => { overlay.remove(); onConfirm(); });
  overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
}

// ── Markdown Content Editor ──
let _editingNode = null;

function enterEditMode(node) {
  _editingNode = node;
  const contentEl = document.getElementById('detail-content');
  const wrap = contentEl.parentElement; // .content-edit-wrap
  contentEl.style.display = 'none';

  // Remove any previous editor
  const prev = wrap.querySelector('.md-editor-wrap');
  if (prev) prev.remove();

  const editor = document.createElement('div');
  editor.className = 'md-editor-wrap';

  // Toolbar
  const toolbar = document.createElement('div');
  toolbar.className = 'md-toolbar';

  const btnBold = document.createElement('button');
  btnBold.textContent = 'B';
  btnBold.title = 'Bold (**text**)';
  btnBold.style.fontWeight = '700';

  const btnList = document.createElement('button');
  btnList.textContent = '• List';
  btnList.title = 'Toggle list (- item)';

  const btnHeading = document.createElement('button');
  btnHeading.textContent = 'H';
  btnHeading.title = 'Cycle heading (## / ### / none)';

  toolbar.append(btnBold, btnList, btnHeading);

  // Textarea
  const textarea = document.createElement('textarea');
  textarea.className = 'md-textarea';
  textarea.value = node.payload.content || '';
  textarea.spellcheck = false;

  // Auto-resize textarea to fit content
  function autoResize() {
    textarea.style.height = 'auto';
    textarea.style.height = Math.min(360, Math.max(120, textarea.scrollHeight)) + 'px';
  }
  textarea.addEventListener('input', autoResize);

  // Actions
  const actions = document.createElement('div');
  actions.className = 'md-editor-actions';

  const btnCancel = document.createElement('button');
  btnCancel.className = 'md-btn-cancel';
  btnCancel.textContent = 'Cancel';

  const btnSave = document.createElement('button');
  btnSave.className = 'md-btn-save';
  btnSave.textContent = 'Save';

  actions.append(btnCancel, btnSave);
  editor.append(toolbar, textarea, actions);
  wrap.appendChild(editor);

  // Focus and auto-resize after insert
  requestAnimationFrame(() => { textarea.focus(); autoResize(); });

  // ── Toolbar actions ──

  // Bold: wrap/unwrap selection with **
  btnBold.addEventListener('click', () => {
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const val = textarea.value;
    const sel = val.substring(start, end);

    if (sel.startsWith('**') && sel.endsWith('**') && sel.length > 4) {
      // Unwrap
      textarea.value = val.substring(0, start) + sel.slice(2, -2) + val.substring(end);
      textarea.selectionStart = start;
      textarea.selectionEnd = end - 4;
    } else if (start >= 2 && val.substring(start - 2, start) === '**' && val.substring(end, end + 2) === '**') {
      // Unwrap (cursor inside bold markers)
      textarea.value = val.substring(0, start - 2) + sel + val.substring(end + 2);
      textarea.selectionStart = start - 2;
      textarea.selectionEnd = end - 2;
    } else {
      // Wrap
      textarea.value = val.substring(0, start) + '**' + sel + '**' + val.substring(end);
      textarea.selectionStart = start + 2;
      textarea.selectionEnd = end + 2;
    }
    textarea.focus();
  });

  // List: toggle "- " prefix on each selected line
  btnList.addEventListener('click', () => {
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const val = textarea.value;

    // Find line boundaries
    const lineStart = val.lastIndexOf('\n', start - 1) + 1;
    const lineEnd = val.indexOf('\n', end);
    const blockEnd = lineEnd === -1 ? val.length : lineEnd;
    const block = val.substring(lineStart, blockEnd);
    const lines = block.split('\n');

    const allList = lines.every(l => /^- /.test(l));
    const newLines = allList
      ? lines.map(l => l.replace(/^- /, ''))
      : lines.map(l => '- ' + l);

    const newBlock = newLines.join('\n');
    textarea.value = val.substring(0, lineStart) + newBlock + val.substring(blockEnd);

    const diff = newBlock.length - block.length;
    textarea.selectionStart = lineStart;
    textarea.selectionEnd = blockEnd + diff;
    textarea.focus();
  });

  // Heading: cycle none → ## → ### → none on selected lines
  btnHeading.addEventListener('click', () => {
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const val = textarea.value;

    const lineStart = val.lastIndexOf('\n', start - 1) + 1;
    const lineEnd = val.indexOf('\n', end);
    const blockEnd = lineEnd === -1 ? val.length : lineEnd;
    const block = val.substring(lineStart, blockEnd);
    const lines = block.split('\n');

    const newLines = lines.map(l => {
      if (l.startsWith('### ')) return l.slice(4); // ### → none
      if (l.startsWith('## ')) return '### ' + l.slice(3); // ## → ###
      return '## ' + l; // none → ##
    });

    const newBlock = newLines.join('\n');
    textarea.value = val.substring(0, lineStart) + newBlock + val.substring(blockEnd);

    const diff = newBlock.length - block.length;
    textarea.selectionStart = lineStart;
    textarea.selectionEnd = blockEnd + diff;
    textarea.focus();
  });

  // ── Save / Cancel ──
  btnCancel.addEventListener('click', () => exitEditMode(node, false));
  btnSave.addEventListener('click', () => exitEditMode(node, true));

  // Escape key cancels
  textarea.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') { e.preventDefault(); exitEditMode(node, false); }
  });
}

async function exitEditMode(node, save) {
  const contentEl = document.getElementById('detail-content');
  const wrap = contentEl.parentElement;
  const editor = wrap.querySelector('.md-editor-wrap');

  if (save && editor) {
    const textarea = editor.querySelector('.md-textarea');
    const newContent = textarea.value;

    try {
      const res = await fetch(`/api/memory/${node.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: newContent }),
      });
      if (!res.ok) throw new Error('Save failed');
      node.payload.content = newContent;
    } catch (err) {
      console.error('Content save failed:', err);
      // Still exit edit mode but don't update display
    }
  }

  if (editor) editor.remove();
  contentEl.style.display = '';
  contentEl.innerHTML = formatMemoryContent(node.payload.content);
  _editingNode = null;
}

function showDetailPanel(node) {
  const p = node.payload;
  const color = catColor(p.category);

  // Header — category dot + label
  const headerDot = document.getElementById('detail-header-dot');
  headerDot.style.color = color;
  headerDot.style.background = color;
  const catLabel = document.getElementById('detail-category-label');
  catLabel.textContent = (p._isOpenClaw ? '[OC] ' : '') + p.category + (p.subcategory ? ' / ' + p.subcategory : '');
  catLabel.style.color = color;

  // OpenClaw nodes are read-only (file-backed, not Qdrant)
  const isOC = !!p._isOpenClaw;
  document.getElementById('detail-change-cat-btn').style.display = isOC ? 'none' : '';
  document.getElementById('detail-delete-inline-btn').style.display = isOC ? 'none' : '';
  document.getElementById('content-edit-btn').style.display = isOC ? 'none' : '';

  // Show/hide OpenClaw source indicator
  let ocSourceEl = document.getElementById('detail-openclaw-source');
  if (isOC) {
    if (!ocSourceEl) {
      ocSourceEl = document.createElement('div');
      ocSourceEl.id = 'detail-openclaw-source';
      ocSourceEl.style.cssText = 'font-size:11px;color:#f97316;margin-bottom:8px;font-family:"JetBrains Mono",monospace;';
      const contentEl = document.getElementById('detail-content');
      contentEl.parentNode.insertBefore(ocSourceEl, contentEl);
    }
    const source = p._openClawFile ? p._openClawFile : p.category.includes('longterm') ? 'MEMORY.md' : 'Daily Log';
    ocSourceEl.textContent = 'Source: OpenClaw \u2022 ' + source;
    ocSourceEl.style.display = '';
  } else if (ocSourceEl) {
    ocSourceEl.style.display = 'none';
  }

  document.getElementById('detail-change-cat-btn').onclick = () => {
    openCategoryChangeModal(node);
  };

  // Inline delete button — opens confirmation modal
  document.getElementById('detail-delete-inline-btn').onclick = () => {
    const overlay = document.createElement('div');
    overlay.className = 'tag-delete-overlay';
    overlay.innerHTML = `
      <div class="tag-delete-modal" style="max-width:380px">
        <div class="tag-delete-modal-title"><svg viewBox="0 0 24 24" style="width:14px;height:14px;stroke:var(--accent-red);stroke-width:2;fill:none;vertical-align:-2px"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/></svg> Move to Trash</div>
        <p style="font-size:var(--fs-sm);color:var(--t-secondary);margin-bottom:6px">Move this memory to trash?</p>
        <p style="font-size:var(--fs-xs);color:var(--t-muted);margin-bottom:18px">You can restore it from the trash panel.</p>
        <div class="tag-delete-modal-actions">
          <button class="action-btn action-btn--ghost" id="del-cancel">Cancel</button>
          <button class="action-btn action-btn--danger" id="del-confirm">Move to Trash</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    overlay.querySelector('#del-cancel').onclick = () => overlay.remove();
    overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
    overlay.querySelector('#del-confirm').onclick = () => {
      overlay.remove();
      deleteMemoryFromUI(node);
    };
  };

  // Bookmark button state
  if (typeof updateDetailBookmarkBtn === 'function') updateDetailBookmarkBtn(node.id);

  // Export as Markdown
  document.getElementById('detail-export-md-btn').onclick = () => exportMemoryAsMarkdown(node);

  // Focus button — toggle showing only linked memories
  const focusBtn = document.getElementById('detail-focus-btn');
  focusBtn.classList.toggle('active', focusedNodeId === node.id);
  focusBtn.onclick = () => {
    if (focusedNodeId === node.id) {
      focusedNodeId = null;
      focusBtn.classList.remove('active');
    } else {
      focusedNodeId = node.id;
      focusBtn.classList.add('active');
    }
    applyGraphData();
    updateStats();
  };

  // Importance as dots (filled/empty)
  const imp = p.importance || 5;
  const impEl = document.getElementById('detail-importance');
  impEl.innerHTML = '';
  for (let i = 1; i <= 10; i++) {
    const dot = document.createElement('span');
    dot.style.display = 'inline-block';
    dot.style.width = '6px';
    dot.style.height = '6px';
    dot.style.borderRadius = '50%';
    dot.style.marginRight = '4px';
    dot.style.background = i <= imp ? '#FFD700' : 'rgba(255,255,255,0.08)';
    dot.style.boxShadow = i <= imp ? '0 0 4px rgba(255,215,0,0.4)' : 'none';
    impEl.appendChild(dot);
  }

  // Formatted content
  // Exit any active edit mode first
  if (_editingNode) exitEditMode(_editingNode, false);
  const contentEl = document.getElementById('detail-content');
  contentEl.style.display = '';
  contentEl.innerHTML = formatMemoryContent(p.content);

  // Wire up edit button (in header)
  document.getElementById('content-edit-btn').onclick = () => enterEditMode(node);

  // Tags (editable)
  const tagContainer = document.getElementById('detail-tag-chips');
  tagContainer.innerHTML = '';
  const currentTags = (p.tags && Array.isArray(p.tags)) ? [...p.tags] : [];

  function renderEditableTags() {
    tagContainer.innerHTML = '';
    currentTags.forEach(tag => {
      const chip = document.createElement('span');
      chip.className = 'tag-chip';

      const text = document.createElement('span');
      text.className = 'tag-text';
      text.textContent = tag;
      chip.appendChild(text);

      const rm = document.createElement('span');
      rm.className = 'tag-remove';
      rm.textContent = '\u00d7';
      rm.addEventListener('click', (e) => {
        e.stopPropagation();
        showTagDeleteModal(tag, async () => {
          const idx = currentTags.indexOf(tag);
          if (idx !== -1) currentTags.splice(idx, 1);
          try {
            await fetch(`/api/memory/${node.id}`, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ tags: currentTags }),
            });
            node.payload.tags = [...currentTags];
          } catch (e) { console.error('Tag remove failed:', e); }
          renderEditableTags();
        });
      });
      chip.appendChild(rm);

      tagContainer.appendChild(chip);
    });

    // Add tag input
    const input = document.createElement('input');
    input.className = 'tag-add-input';
    input.placeholder = '+ add tag';
    input.maxLength = 40;
    input.addEventListener('keydown', async (e) => {
      if (e.key === 'Enter' && input.value.trim()) {
        const newTag = input.value.trim().toLowerCase();
        if (currentTags.includes(newTag)) { input.value = ''; return; }
        currentTags.push(newTag);
        try {
          await fetch(`/api/memory/${node.id}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ tags: currentTags }),
          });
          node.payload.tags = [...currentTags];
        } catch (e) { console.error('Tag add failed:', e); }
        renderEditableTags();
      }
    });
    tagContainer.appendChild(input);
  }

  if (isOC) {
    // Read-only tags for OpenClaw nodes
    tagContainer.innerHTML = '';
    currentTags.forEach(tag => {
      const chip = document.createElement('span');
      chip.className = 'tag-chip';
      const text = document.createElement('span');
      text.className = 'tag-text';
      text.textContent = tag;
      chip.appendChild(text);
      tagContainer.appendChild(chip);
    });
  } else {
    renderEditableTags();
  }
  document.getElementById('detail-tags').style.display = '';

  // Metadata as clean rows
  const meta = document.getElementById('detail-meta-content');
  meta.innerHTML = '';
  const addMeta = (label, value) => {
    if (!value) return;
    const row = document.createElement('div');
    row.className = 'detail-meta-row';
    row.innerHTML = `<span style="color:rgba(255,255,255,0.3)">${label}</span><span>${value}</span>`;
    meta.appendChild(row);
  };
  addMeta('Project', p.project);
  addMeta('Source', p.source);
  addMeta('Created', p.created_at ? new Date(p.created_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) : null);
  addMeta('Updated', p.updated_at ? new Date(p.updated_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) : null);
  addMeta('Accessed', p.access_count ? `${p.access_count} times` : null);

  // ID row with copy button
  {
    const idRow = document.createElement('div');
    idRow.className = 'detail-meta-row';
    idRow.innerHTML = `<span style="color:rgba(255,255,255,0.3)">ID</span><span>${truncate(node.id, 20)}<button class="meta-copy-btn" data-tooltip="Copy full ID">Copy</button></span>`;
    idRow.querySelector('.meta-copy-btn').addEventListener('click', () => {
      navigator.clipboard.writeText(node.id).then(() => {
        const btn = idRow.querySelector('.meta-copy-btn');
        btn.textContent = 'Copied!';
        btn.classList.add('copied');
        setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 1500);
      });
    });
    meta.appendChild(idRow);
  }

  // Related files
  const filesDiv = document.getElementById('detail-files');
  const filesContent = document.getElementById('detail-files-content');
  if (p.related_files && p.related_files.length) {
    filesContent.innerHTML = p.related_files.map(f =>
      `<div style="font-family:'JetBrains Mono','SF Mono',Consolas,monospace;font-size:12px;color:rgba(255,255,255,0.45);padding:2px 0">${f}</div>`
    ).join('');
    filesDiv.style.display = '';
  } else {
    filesDiv.style.display = 'none';
  }

  // Restore saved position if it was dragged before
  const savedDetail = localStorage.getItem('neural-panel-detail-panel');
  if (savedDetail) {
    try {
      const d = JSON.parse(savedDetail);
      if (d.left && d.left !== 'auto') {
        $detailPanel.style.left = d.left;
        $detailPanel.style.top = d.top || '20px';
        $detailPanel.style.right = 'auto';
      }
    } catch {}
  }
  $detailPanel.classList.add('open');
}

// ═══════════════════════════════════════════
// SEARCH
// ═══════════════════════════════════════════
let searchTimeout = null;

$searchInput.addEventListener('focus', () => $searchWrapper.classList.add('focused'));
$searchInput.addEventListener('blur', () => $searchWrapper.classList.remove('focused'));

$searchInput.addEventListener('input', () => {
  clearTimeout(searchTimeout);
  const query = $searchInput.value.trim();

  if (!query) {
    clearSearch();
    return;
  }

  $searchClear.style.display = 'block';
  $searchBadge.classList.remove('visible');
  $statSearch.textContent = 'Searching...';

  searchTimeout = setTimeout(() => performSearch(query), 400);
});

$searchClear.addEventListener('click', () => {
  $searchInput.value = '';
  clearSearch();
  $searchInput.focus();
});

async function performSearch(query) {
  try {
    const res = await fetch('/api/search', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query, limit: 15 }),
    });
    const data = await res.json();

    if (data.results && data.results.length > 0) {
      searchResults = new Set(data.results.map(r => r.id));
      $searchBadge.textContent = data.results.length;
      $searchBadge.classList.add('visible');
      $searchClear.style.display = 'none'; // badge takes its place
      $statSearch.textContent = `${data.results.length} results`;

      // Camera to centroid of results
      const resultNodes = allNodes.filter(n => searchResults.has(n.id));
      if (resultNodes.length > 0 && graph) {
        // Get positions from graph internals
        const graphNodes = graph.graphData().nodes;
        const matchingGraphNodes = graphNodes.filter(n => searchResults.has(n.id));
        if (matchingGraphNodes.length > 0) {
          const cx = matchingGraphNodes.reduce((s, n) => s + (n.x || 0), 0) / matchingGraphNodes.length;
          const cy = matchingGraphNodes.reduce((s, n) => s + (n.y || 0), 0) / matchingGraphNodes.length;
          const cz = matchingGraphNodes.reduce((s, n) => s + (n.z || 0), 0) / matchingGraphNodes.length;
          graph.cameraPosition(
            { x: cx + 180, y: cy + 80, z: cz + 180 },
            { x: cx, y: cy, z: cz },
            1500
          );
        }
      }
    } else {
      searchResults = new Set(); // empty set = no matches
      $searchBadge.textContent = '0';
      $searchBadge.classList.add('visible');
      $searchClear.style.display = 'none';
      $statSearch.textContent = 'No results';
    }

    updateStats();
  } catch (err) {
    console.error('Search error:', err);
    $statSearch.textContent = 'Search error';
  }
}

function clearSearch() {
  searchResults = null;
  $searchBadge.classList.remove('visible');
  $searchClear.style.display = 'none';
  $statSearch.textContent = '';
  updateStats();
}

// ═══════════════════════════════════════════
// CATEGORY SIDEBAR
// ═══════════════════════════════════════════
function getCategoryOrder() {
  try { return JSON.parse(localStorage.getItem('neural-category-order') || '[]'); }
  catch { return []; }
}

function saveCategoryOrder(order) {
  localStorage.setItem('neural-category-order', JSON.stringify(order));
}

function buildCategorySidebar(presentCats) {
  $categoryList.innerHTML = '';

  // Count per category
  const counts = {};
  allNodes.forEach(n => {
    const cat = n.payload.category;
    counts[cat] = (counts[cat] || 0) + 1;
  });

  // Merge present categories with all known categories (including 0-count ones)
  const allCats = new Set(presentCats);
  allCategoryNames.forEach(c => allCats.add(c));

  // Group categories by parent
  const categoryGroups = {};
  const orphans = [];

  [...allCats].forEach(cat => {
    const meta = categoryMetadata[cat] || {};
    if (meta.parent) {
      if (!categoryGroups[meta.parent]) categoryGroups[meta.parent] = [];
      categoryGroups[meta.parent].push(cat);
    } else {
      orphans.push(cat);
    }
    // Ensure is_parent categories always have an entry in categoryGroups (even if empty)
    if (meta.is_parent && !categoryGroups[cat]) {
      categoryGroups[cat] = [];
    }
  });

  // Apply saved order, then append any new categories at the end sorted by count
  const savedOrder = getCategoryOrder();
  const ordered = savedOrder.filter(c => allCats.has(c));
  const remaining = [...allCats].filter(c => !savedOrder.includes(c))
    .sort((a, b) => (counts[b] || 0) - (counts[a] || 0));
  const sorted = [...ordered, ...remaining];

  // Regroup sorted: parent clusters contiguous (header + all children), orphans at end.
  // Prevents orphan categories from interleaving with cluster children (false 3rd nesting level).
  const regrouped = [];
  const _grouped = new Set();
  const _pNames = new Set();
  sorted.forEach(c => { const m = categoryMetadata[c] || {}; if (m.is_parent || categoryGroups[c]) _pNames.add(c); if (m.parent) _pNames.add(m.parent); });
  const _pOrd = [], _pSeen = new Set();
  sorted.forEach(c => { const m = categoryMetadata[c] || {}; const p = m.parent || (_pNames.has(c) ? c : null); if (p && !_pSeen.has(p)) { _pSeen.add(p); _pOrd.push(p); } });
  _pOrd.forEach(p => {
    regrouped.push(p); _grouped.add(p);
    sorted.forEach(c => { if ((categoryMetadata[c] || {}).parent === p) { regrouped.push(c); _grouped.add(c); } });
  });
  sorted.forEach(c => { if (!_grouped.has(c)) regrouped.push(c); });

  // Track which parent clusters we've rendered
  const renderedClusters = new Set();

  regrouped.forEach(cat => {
    const meta = categoryMetadata[cat] || {};

    // If this category has a parent and we haven't rendered that cluster header yet
    if (meta.parent && !renderedClusters.has(meta.parent)) {
      const clusterHeader = document.createElement('div');
      clusterHeader.className = 'category-cluster-header';
      clusterHeader.style.borderLeft = `3px solid ${catColor(meta.parent)}`;
      clusterHeader.dataset.parent = meta.parent;

      // Check if parent is inactive
      if (!activeCategories.has(meta.parent)) {
        clusterHeader.classList.add('inactive');
      }

      const parentMeta = categoryMetadata[meta.parent] || {};
      const isEphemeral = !!parentMeta._ephemeral;
      clusterHeader.innerHTML = `
        <span class="cluster-dot" style="background:${catColor(meta.parent)}" data-tooltip="Color"></span>
        <span class="cluster-name">${meta.parent}</span>
        ${isEphemeral
          ? '<span style="margin-left:auto;font-size:10px;opacity:0.5;color:var(--t-muted)">bridge</span>'
          : `<span class="cluster-actions">
              <button class="cluster-edit-btn" data-tooltip="Edit">&#9998;</button>
              <button class="cluster-delete-btn" data-tooltip="Delete">&times;</button>
            </span>`}
      `;

      // Click on cluster header to toggle parent and all children
      clusterHeader.addEventListener('click', (e) => {
        if (categoryDragDidMove) { categoryDragDidMove = false; return; }
        // Don't toggle if clicking on action buttons or color dot
        if (e.target.closest('.cluster-actions') || e.target.closest('.cluster-dot')) return;

        const parentCat = meta.parent;
        const childCategories = categoryGroups[parentCat] || [];

        if (activeCategories.has(parentCat)) {
          // Disable parent and all children
          activeCategories.delete(parentCat);
          childCategories.forEach(child => activeCategories.delete(child));
          clusterHeader.classList.add('inactive');
          childCategories.forEach(child => {
            const childChip = $categoryList.querySelector(`.category-chip[data-cat="${child}"]`);
            if (childChip) childChip.classList.add('inactive');
          });
          scheduleGraphRemoval();
        } else {
          // Enable parent and all children
          activeCategories.add(parentCat);
          childCategories.forEach(child => activeCategories.add(child));
          clusterHeader.classList.remove('inactive');
          childCategories.forEach(child => {
            const childChip = $categoryList.querySelector(`.category-chip[data-cat="${child}"]`);
            if (childChip) childChip.classList.remove('inactive');
          });
          cancelScheduledRemoval();
          applyGraphData();
          updateStats();
        }
      });

      // Color dot click
      clusterHeader.querySelector('.cluster-dot').addEventListener('click', (e) => {
        e.stopPropagation();
        openColorPicker(meta.parent, clusterHeader);
      });

      // Edit/Delete buttons (not present for ephemeral/bridge categories)
      const clusterEditBtn = clusterHeader.querySelector('.cluster-edit-btn');
      if (clusterEditBtn) {
        clusterEditBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          editCategoryUI(meta.parent);
        });
      }
      const clusterDeleteBtn = clusterHeader.querySelector('.cluster-delete-btn');
      if (clusterDeleteBtn) {
        clusterDeleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const parentCount = counts[meta.parent] || 0;
          deleteCategoryUI(meta.parent, parentCount, clusterHeader);
        });
      }

      $categoryList.appendChild(clusterHeader);
      renderedClusters.add(meta.parent);
    }

    // If this category is a parent (is_parent flag or has children), render its own cluster header
    if ((meta.is_parent || (categoryGroups[cat] && categoryGroups[cat].length > 0)) && !renderedClusters.has(cat)) {
      const clusterHeader = document.createElement('div');
      clusterHeader.className = 'category-cluster-header';
      clusterHeader.style.borderLeft = `3px solid ${catColor(cat)}`;
      clusterHeader.dataset.parent = cat;

      if (!activeCategories.has(cat)) {
        clusterHeader.classList.add('inactive');
      }

      const childCount = (categoryGroups[cat] || []).length;
      const isEphemeralCat = !!(categoryMetadata[cat] || {})._ephemeral;
      clusterHeader.innerHTML = `
        <span class="cluster-dot" style="background:${catColor(cat)}" data-tooltip="Color"></span>
        <span class="cluster-name">${cat}</span>
        ${isEphemeralCat
          ? '<span style="margin-left:auto;font-size:10px;opacity:0.5;color:var(--t-muted)">bridge</span>'
          : `<span class="cluster-actions">
              <button class="cluster-edit-btn" data-tooltip="Edit">&#9998;</button>
              <button class="cluster-delete-btn" data-tooltip="Delete">&times;</button>
            </span>`}
      `;

      clusterHeader.addEventListener('click', (e) => {
        if (categoryDragDidMove) { categoryDragDidMove = false; return; }
        if (e.target.closest('.cluster-actions') || e.target.closest('.cluster-dot')) return;
        const childCategories = categoryGroups[cat] || [];
        if (activeCategories.has(cat)) {
          activeCategories.delete(cat);
          childCategories.forEach(child => activeCategories.delete(child));
          clusterHeader.classList.add('inactive');
          childCategories.forEach(child => {
            const childChip = $categoryList.querySelector(`.category-chip[data-cat="${child}"]`);
            if (childChip) childChip.classList.add('inactive');
          });
          scheduleGraphRemoval();
        } else {
          activeCategories.add(cat);
          childCategories.forEach(child => activeCategories.add(child));
          clusterHeader.classList.remove('inactive');
          childCategories.forEach(child => {
            const childChip = $categoryList.querySelector(`.category-chip[data-cat="${child}"]`);
            if (childChip) childChip.classList.remove('inactive');
          });
          cancelScheduledRemoval();
          applyGraphData();
          updateStats();
        }
      });

      clusterHeader.querySelector('.cluster-dot').addEventListener('click', (e) => {
        e.stopPropagation();
        openColorPicker(cat, clusterHeader);
      });
      const editBtnStandalone = clusterHeader.querySelector('.cluster-edit-btn');
      if (editBtnStandalone) {
        editBtnStandalone.addEventListener('click', (e) => {
          e.stopPropagation();
          editCategoryUI(cat);
        });
      }
      const deleteBtnStandalone = clusterHeader.querySelector('.cluster-delete-btn');
      if (deleteBtnStandalone) {
        deleteBtnStandalone.addEventListener('click', (e) => {
          e.stopPropagation();
          deleteCategoryUI(cat, counts[cat] || 0, clusterHeader);
        });
      }

      $categoryList.appendChild(clusterHeader);
      renderedClusters.add(cat);

      // Show empty state hint if parent has no children yet
      if (childCount === 0) {
        const emptyHint = document.createElement('div');
        emptyHint.className = 'cluster-empty-hint';
        emptyHint.textContent = 'Drag categories here';
        $categoryList.appendChild(emptyHint);
      }
    }

    // Skip rendering chips for parent categories (they only appear as cluster headers)
    if (categoryGroups[cat] !== undefined) {
      return;
    }

    const chip = document.createElement('div');
    chip.className = 'category-chip' + (meta.parent ? ' category-chip-child' : '');
    chip.dataset.cat = cat;

    // Check if category should be inactive
    if (!activeCategories.has(cat)) {
      chip.classList.add('inactive');
    }

    const isEphemeralChip = !!(meta._ephemeral || (meta.parent && (categoryMetadata[meta.parent] || {})._ephemeral));
    chip.innerHTML = `
      <div class="category-dot" style="color:${catColor(cat)}; background:${catColor(cat)}" data-tooltip="Color"></div>
      <span class="category-label">${cat}${isEphemeralChip ? '' : '<span class="cat-edit-icon" data-tooltip="Edit">&#9998;</span>'}</span>
      <span class="category-count">${counts[cat] || 0}</span>
      ${isEphemeralChip ? '' : '<button class="category-delete" data-tooltip="Delete">&times;</button>'}
    `;

    // Color dot click → open color picker
    chip.querySelector('.category-dot').addEventListener('click', (e) => {
      e.stopPropagation();
      openColorPicker(cat, chip);
    });

    // Edit icon click → open full category editor (not for ephemeral)
    const catEditIcon = chip.querySelector('.cat-edit-icon');
    if (catEditIcon) {
      catEditIcon.addEventListener('click', (e) => {
        e.stopPropagation();
        editCategoryUI(cat);
      });
    }

    chip.addEventListener('click', (e) => {
      if (categoryDragDidMove) { categoryDragDidMove = false; return; }
      if (e.target.closest('.category-delete')) return;
      if (e.target.closest('.category-dot')) return;
      if (e.target.closest('.cat-edit-icon')) return;
      if (activeCategories.has(cat)) {
        activeCategories.delete(cat);
        chip.classList.add('inactive');
        scheduleGraphRemoval();
      } else {
        activeCategories.add(cat);
        chip.classList.remove('inactive');
        cancelScheduledRemoval();
        applyGraphData();
        updateStats();
      }
    });

    const catDeleteBtn = chip.querySelector('.category-delete');
    if (catDeleteBtn) {
      catDeleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        deleteCategoryUI(cat, counts[cat] || 0, chip);
      });
    }

    $categoryList.appendChild(chip);
  });

  // Wire up drag-to-reorder
  initCategoryDrag();
}

let categoryDragDidMove = false;

function initCategoryDrag() {
  let dragEl = null;        // The element being dragged (chip or cluster header)
  let dragType = null;      // 'chip' or 'cluster'
  let startY = 0;
  let startX = 0;
  let cloneEl = null;       // Floating clone that follows cursor
  let initialRect = null;   // Bounding rect captured before drag starts
  let dragElHeight = 0;     // Height of dragged element for gap sizing
  categoryDragDidMove = false;

  const chips = () => [...$categoryList.querySelectorAll('.category-chip')];
  const clusterHeaders = () => [...$categoryList.querySelectorAll('.category-cluster-header')];

  function clearIndicators() {
    chips().forEach(c => c.classList.remove('drag-gap-before', 'drag-gap-after'));
    clusterHeaders().forEach(h => h.classList.remove('drag-over-cluster', 'drag-gap-before', 'drag-gap-after'));
  }

  // Get all DOM elements belonging to a cluster (header + its child chips + empty hints)
  function getClusterElements(headerEl) {
    const els = [headerEl];
    let next = headerEl.nextElementSibling;
    while (next) {
      if (next.classList.contains('category-cluster-header')) break;
      if (next.classList.contains('category-chip') && !next.classList.contains('category-chip-child')) break;
      els.push(next);
      next = next.nextElementSibling;
    }
    return els;
  }

  function getDropTarget(y) {
    const headers = clusterHeaders();

    if (dragType === 'cluster') {
      const dragClusterEls = new Set(getClusterElements(dragEl));

      for (const header of headers) {
        if (dragClusterEls.has(header)) continue;
        const rect = header.getBoundingClientRect();
        const mid = rect.top + rect.height / 2;
        if (y >= rect.top - 8 && y <= rect.bottom + 8) {
          return { type: 'reorder-cluster', header, position: y < mid ? 'before' : 'after' };
        }
      }

      for (const chip of chips()) {
        if (chip.classList.contains('category-chip-child')) continue;
        if (dragClusterEls.has(chip)) continue;
        const rect = chip.getBoundingClientRect();
        const mid = rect.top + rect.height / 2;
        if (y >= rect.top - 4 && y <= rect.bottom + 4) {
          return { type: 'reorder-cluster', header: chip, position: y < mid ? 'before' : 'after' };
        }
      }

      return null;
    }

    // Dragging a chip: check cluster headers to reparent
    for (const header of headers) {
      const rect = header.getBoundingClientRect();
      if (y >= rect.top - 4 && y <= rect.bottom + 20) {
        const clusterName = header.querySelector('.cluster-name').textContent;
        return { type: 'cluster', header, clusterName };
      }
    }

    // Check empty cluster hints
    for (const hint of [...$categoryList.querySelectorAll('.cluster-empty-hint')]) {
      const rect = hint.getBoundingClientRect();
      if (y >= rect.top && y <= rect.bottom) {
        const header = hint.previousElementSibling;
        if (header && header.classList.contains('category-cluster-header')) {
          const clusterName = header.querySelector('.cluster-name').textContent;
          return { type: 'cluster', header, clusterName };
        }
      }
    }

    // Check top empty area (make top-level)
    const firstChip = chips()[0];
    const firstHeader = headers[0];
    const firstElement = firstChip || firstHeader;
    if (firstElement) {
      const firstRect = firstElement.getBoundingClientRect();
      const listRect = $categoryList.getBoundingClientRect();
      if (y < firstRect.top && y >= listRect.top) {
        return { type: 'make-toplevel' };
      }
    }

    // Reorder among sibling chips
    for (const chip of chips()) {
      if (chip === dragEl) continue;
      const rect = chip.getBoundingClientRect();
      const mid = rect.top + rect.height / 2;
      if (y < mid) return { type: 'reorder', chip, position: 'before' };
    }
    const last = chips().filter(c => c !== dragEl).pop();
    return last ? { type: 'reorder', chip: last, position: 'after' } : null;
  }

  // Helper: update local metadata + rebuild sidebar after API response
  function applyApiResponse(data) {
    allCategoryNames = data.categories.map(c => c.name);
    categoryDescriptions = {};
    categoryMetadata = {};
    data.categories.forEach(c => {
      categoryDescriptions[c.name] = c.description;
      categoryMetadata[c.name] = { parent: c.parent, color: c.color, is_parent: c.is_parent, logo: c.logo };
    });
    preloadCategoryLogos(data.categories);
    const presentCats = new Set(allNodes.map(n => n.payload.category));
    buildCategorySidebar(presentCats);
    applyGraphData();
  }

  // Create a floating clone of the dragged element
  function createDragClone(el) {
    const rect = el.getBoundingClientRect();
    const clone = el.cloneNode(true);
    clone.classList.remove('inactive', 'drag-source');
    clone.classList.add('cat-drag-clone');
    clone.style.width = rect.width + 'px';
    clone.style.left = rect.left + 'px';
    clone.style.top = rect.top + 'px';
    clone.style.transform = 'translate(0px, 0px) scale(1.04) rotate(0.8deg)';
    // Strip interactive elements — clone is purely visual
    clone.querySelectorAll('.category-delete, .cat-edit-icon, .cluster-actions').forEach(n => n.remove());
    document.body.appendChild(clone);
    return clone;
  }

  // Cleanup all drag artifacts
  function cleanupDrag() {
    if (dragEl) {
      dragEl.classList.remove('drag-source');
      if (dragType === 'cluster') {
        getClusterElements(dragEl).forEach(el => el.classList.remove('drag-source'));
      }
    }
    clearIndicators();
    if (cloneEl) { cloneEl.remove(); cloneEl = null; }
    $categoryList.classList.remove('cat-dragging');
    $categoryList.style.removeProperty('--drag-gap');
    dragEl = null;
    dragType = null;
    initialRect = null;
  }

  $categoryList.addEventListener('pointerdown', (e) => {
    // Skip interactive sub-elements
    if (e.target.closest('.category-delete')) return;
    if (e.target.closest('.category-dot')) return;
    if (e.target.closest('.cat-edit-icon')) return;
    if (e.target.closest('.cluster-actions')) return;
    if (e.target.closest('.cluster-dot')) return;

    const chip = e.target.closest('.category-chip');
    const header = e.target.closest('.category-cluster-header');
    const el = chip || header;
    if (!el) return;

    e.preventDefault();
    dragEl = el;
    dragType = chip ? 'chip' : 'cluster';
    startY = e.clientY;
    startX = e.clientX;
    categoryDragDidMove = false;
    el.setPointerCapture(e.pointerId);

    function onMove(ev) {
      if (!dragEl) return;
      if (!categoryDragDidMove && Math.abs(ev.clientY - startY) < 5) return;

      if (!categoryDragDidMove) {
        categoryDragDidMove = true;

        // Capture geometry before any visual changes
        initialRect = dragEl.getBoundingClientRect();
        dragElHeight = initialRect.height + 4;

        // Create floating clone
        cloneEl = createDragClone(dragEl);

        // Ghost the source element(s)
        dragEl.classList.add('drag-source');
        if (dragType === 'cluster') {
          getClusterElements(dragEl).forEach(el => el.classList.add('drag-source'));
        }

        // Enable gap transitions and set dynamic gap size
        $categoryList.classList.add('cat-dragging');
        $categoryList.style.setProperty('--drag-gap', dragElHeight + 'px');
      }

      // Move clone with cursor (GPU-accelerated transform)
      const dx = ev.clientX - startX;
      const dy = ev.clientY - startY;
      cloneEl.style.transform = `translate(${dx}px, ${dy}px) scale(1.04) rotate(0.8deg)`;

      // Show animated gap at drop target
      clearIndicators();
      const target = getDropTarget(ev.clientY);
      if (target) {
        if (target.type === 'cluster') {
          target.header.classList.add('drag-over-cluster');
        } else if (target.type === 'reorder' || target.type === 'reorder-cluster') {
          const targetEl = target.chip || target.header;
          targetEl.classList.add(target.position === 'before' ? 'drag-gap-before' : 'drag-gap-after');
        } else if (target.type === 'make-toplevel') {
          const first = chips()[0] || clusterHeaders()[0];
          if (first && first !== dragEl) first.classList.add('drag-gap-before');
        }
      }
    }

    async function onUp(ev) {
      el.removeEventListener('pointermove', onMove);
      el.removeEventListener('pointerup', onUp);
      el.removeEventListener('pointercancel', onUp);

      if (!dragEl) return;

      const droppedEl = dragEl;
      const droppedType = dragType;
      const didMove = categoryDragDidMove;

      if (didMove) {
        const target = getDropTarget(ev.clientY);

        // ── Spring-snap drop animation ──
        if (cloneEl && target && initialRect) {
          let gapEl = null, gapPosition = null;
          if (target.type === 'reorder' || target.type === 'reorder-cluster') {
            gapEl = target.chip || target.header;
            gapPosition = target.position;
          } else if (target.type === 'make-toplevel') {
            gapEl = chips()[0] || clusterHeaders()[0];
            gapPosition = 'before';
          } else if (target.type === 'cluster') {
            gapEl = target.header;
            gapPosition = 'after';
          }

          if (gapEl) {
            const gapRect = gapEl.getBoundingClientRect();
            const targetTop = gapPosition === 'before'
              ? gapRect.top - dragElHeight
              : gapRect.bottom;
            const targetDy = targetTop - initialRect.top;
            const targetDx = gapRect.left - initialRect.left;

            // Animate clone to landing position with spring overshoot
            cloneEl.style.transition = 'transform 0.22s cubic-bezier(0.22, 1.15, 0.36, 1), opacity 0.14s ease 0.06s';
            cloneEl.style.transform = `translate(${targetDx}px, ${targetDy}px) scale(1) rotate(0deg)`;
            cloneEl.style.opacity = '0';
            await new Promise(r => setTimeout(r, 220));
          }
        } else if (cloneEl && initialRect) {
          // No valid target — animate clone back to origin
          cloneEl.style.transition = 'transform 0.2s cubic-bezier(0.2, 0, 0, 1), opacity 0.12s ease';
          cloneEl.style.transform = 'translate(0px, 0px) scale(1) rotate(0deg)';
          cloneEl.style.opacity = '0';
          await new Promise(r => setTimeout(r, 200));
        }

        // ── Execute drop action ──
        if (target) {
          if (droppedType === 'cluster' && target.type === 'reorder-cluster') {
            const clusterEls = getClusterElements(droppedEl);
            const refEl = target.header;
            if (target.position === 'before') {
              for (const cel of clusterEls) {
                $categoryList.insertBefore(cel, refEl);
              }
            } else {
              let insertAfter = refEl;
              if (refEl.classList.contains('category-cluster-header')) {
                const targetClusterEls = getClusterElements(refEl);
                insertAfter = targetClusterEls[targetClusterEls.length - 1];
              }
              for (let i = clusterEls.length - 1; i >= 0; i--) {
                insertAfter.after(clusterEls[i]);
              }
            }
            const newOrder = chips().map(c => c.dataset.cat);
            saveCategoryOrder(newOrder);

          } else if (droppedType === 'chip' && target.type === 'cluster') {
            const draggedCat = droppedEl.dataset.cat;
            const newParent = target.clusterName;
            const currentMeta = categoryMetadata[draggedCat] || {};

            if (currentMeta.parent !== newParent) {
              try {
                const res = await fetch('/api/categories/' + encodeURIComponent(draggedCat), {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ parent: newParent }),
                });
                const data = await res.json();
                if (res.ok) {
                  applyApiResponse(data);
                } else {
                  alert('Error reparenting category: ' + data.error);
                }
              } catch (err) {
                console.error('Error reparenting category:', err);
                alert('Error reparenting category: ' + err.message);
              }
            }

          } else if (droppedType === 'chip' && target.type === 'make-toplevel') {
            const draggedCat = droppedEl.dataset.cat;
            const currentMeta = categoryMetadata[draggedCat] || {};

            if (currentMeta.parent) {
              try {
                const res = await fetch('/api/categories/' + encodeURIComponent(draggedCat), {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ parent: '' }),
                });
                const data = await res.json();
                if (res.ok) {
                  applyApiResponse(data);
                } else {
                  alert('Error making category top-level: ' + data.error);
                }
              } catch (err) {
                console.error('Error making category top-level:', err);
                alert('Error making category top-level: ' + err.message);
              }
            }

          } else if (droppedType === 'chip' && target.type === 'reorder' && target.chip !== droppedEl) {
            if (target.position === 'before') {
              $categoryList.insertBefore(droppedEl, target.chip);
            } else {
              target.chip.after(droppedEl);
            }
            const newOrder = chips().map(c => c.dataset.cat);
            saveCategoryOrder(newOrder);
          }
        }
      }

      // ── Cleanup ──
      cleanupDrag();

      // ── Settle animation: element pops into place ──
      if (didMove && droppedEl && droppedEl.parentNode) {
        droppedEl.classList.add('just-dropped');
        droppedEl.addEventListener('animationend', () => droppedEl.classList.remove('just-dropped'), { once: true });
      }
    }

    el.addEventListener('pointermove', onMove);
    el.addEventListener('pointerup', onUp);
    el.addEventListener('pointercancel', onUp);
  });
}

// ═══════════════════════════════════════════
// GRAPH DATA MANAGEMENT
// ═══════════════════════════════════════════
// ═══════════════════════════════════════════
// COMPUTED LAYOUT — deterministic, no simulation
// ═══════════════════════════════════════════
function computeLayout(nodes) {
  const anchors = nodes.filter(n => n.payload._isAnchor);
  const tags = nodes.filter(n => n.payload._isTag);
  const memories = nodes.filter(n => !n.payload._isAnchor && !n.payload._isTag);
  const placed = new Set();

  const GOLDEN = (1 + Math.sqrt(5)) / 2;

  // ── Geodesic sphere layout ──
  // Each anchor sits at the center of a geodesic sphere formed by its memories.
  // Tags are placed on an inner ring around the anchor.
  // Memories fill a full sphere (Fibonacci distribution) around the anchor.

  // Helper: generate N points on a sphere using Fibonacci spiral (near-uniform distribution)
  function fibSphere(n, radius, center) {
    const points = [];
    for (let i = 0; i < n; i++) {
      const y = 1 - (2 * i + 1) / n; // -1 to 1
      const r = Math.sqrt(1 - y * y);
      const theta = 2 * Math.PI * i / GOLDEN;
      points.push({
        x: center.x + Math.cos(theta) * r * radius,
        y: center.y + y * radius,
        z: center.z + Math.sin(theta) * r * radius,
      });
    }
    return points;
  }

  // ── 1. Anchors in a wide ring ──
  const anchorRadius = anchors.length > 1 ? 200 + anchors.length * 60 : 0;
  const ANCHOR_Y = 200;
  const TAG_Y = ANCHOR_Y - 120;     // child categories well below parent
  const SPHERE_GAP = 40;             // gap between tag label and sphere top

  anchors.forEach((anchor, i) => {
    const angle = (i / anchors.length) * Math.PI * 2 - Math.PI / 2;
    anchor.x = Math.cos(angle) * anchorRadius;
    anchor.y = ANCHOR_Y;
    anchor.z = Math.sin(angle) * anchorRadius;
    anchor.fx = anchor.x; anchor.fy = anchor.y; anchor.fz = anchor.z;
    placed.add(anchor.id);
  });

  // ── 2. For each anchor: spread child tags in a wide ring, each with its own memory sphere ──
  anchors.forEach(anchor => {
    const cat = anchor.payload._anchorCategory;
    const childTags = tags.filter(t => t.payload._parentAnchor === cat);

    // Direct-parent memories (belong to parent category, no child tag)
    const directMems = memories.filter(m => m.payload.category === cat && !placed.has(m.id));

    // If there are child tags, spread them in a ring around the anchor
    if (childTags.length) {
      // Ring radius sized so tags don't overlap — wider spacing per tag
      const tagRingRadius = Math.max(120, childTags.length * 65);

      childTags.forEach((tag, i) => {
        const angle = (i / childTags.length) * Math.PI * 2;
        tag.x = anchor.x + Math.cos(angle) * tagRingRadius;
        tag.y = TAG_Y;
        tag.z = anchor.z + Math.sin(angle) * tagRingRadius;
        tag.fx = tag.x; tag.fy = tag.y; tag.fz = tag.z;
        placed.add(tag.id);

        // Each tag gets its own geodesic sphere of memories below it
        const tagCat = tag.payload._tagCategory;
        const tagMems = memories.filter(m => m.payload.category === tagCat && !placed.has(m.id));
        if (tagMems.length) {
          const r = 25 + Math.sqrt(tagMems.length) * 8;
          const sphereCenter = { x: tag.x, y: tag.y - r - SPHERE_GAP, z: tag.z };
          const positions = fibSphere(tagMems.length, r, sphereCenter);
          tagMems.forEach((mem, j) => {
            mem.x = positions[j].x;
            mem.y = positions[j].y;
            mem.z = positions[j].z;
            mem.fx = mem.x; mem.fy = mem.y; mem.fz = mem.z;
            placed.add(mem.id);
          });
        }
      });
    }

    // Direct-parent memories form a small sphere directly below the anchor
    if (directMems.length) {
      const r = 25 + Math.sqrt(directMems.length) * 8;
      const sphereCenter = { x: anchor.x, y: TAG_Y - r - SPHERE_GAP, z: anchor.z };
      const positions = fibSphere(directMems.length, r, sphereCenter);
      directMems.forEach((mem, i) => {
        mem.x = positions[i].x;
        mem.y = positions[i].y;
        mem.z = positions[i].z;
        mem.fx = mem.x; mem.fy = mem.y; mem.fz = mem.z;
        placed.add(mem.id);
      });
    }
  });

  // ── 3. Orphan memories (no matching anchor) → outer spheres ──
  const orphans = memories.filter(m => !placed.has(m.id));
  if (orphans.length) {
    const catGroups = {};
    orphans.forEach(m => {
      const c = m.payload.category || '_uncategorized';
      if (!catGroups[c]) catGroups[c] = [];
      catGroups[c].push(m);
    });
    const groupNames = Object.keys(catGroups);
    const orphanBase = anchorRadius + 150;

    groupNames.forEach((c, gi) => {
      const angle = (gi / Math.max(groupNames.length, 1)) * Math.PI * 2;
      const cx = Math.cos(angle) * orphanBase;
      const cz = Math.sin(angle) * orphanBase;
      const mems = catGroups[c];
      const r = 25 + Math.sqrt(mems.length) * 8;
      const positions = fibSphere(mems.length, r, { x: cx, y: 0, z: cz });

      mems.forEach((mem, i) => {
        mem.x = positions[i].x;
        mem.y = positions[i].y;
        mem.z = positions[i].z;
        mem.fx = mem.x; mem.fy = mem.y; mem.fz = mem.z;
        placed.add(mem.id);
      });
    });
  }

  // ── Floor clamp: no node below the grid floor ──
  const NODE_FLOOR = -200 + 10; // FLOOR_Y + margin
  for (const n of nodes) {
    if (n.y < NODE_FLOOR) {
      n.y = NODE_FLOOR;
      if (n.fy !== undefined) n.fy = NODE_FLOOR;
    }
  }
}

function applyGraphData() {
  if (!graph) return;

  let visibleNodes = allNodes.filter(n => activeCategories.has(n.payload.category));
  let visibleIds = new Set(visibleNodes.map(n => n.id));
  // Build a quick node-id → category lookup
  const nodeCatMap = {};
  for (const n of visibleNodes) nodeCatMap[n.id] = n.payload.category;

  // Separate same-category links (force + visual) from cross-category (visual-only)
  const sameCatLinks = [];
  _crossCategoryLinks = [];  // Stored globally for inter-link toggle
  for (const l of allLinks) {
    const srcId = l.source.id || l.source;
    const tgtId = l.target.id || l.target;
    if (!visibleIds.has(srcId) || !visibleIds.has(tgtId)) continue;
    if (nodeCatMap[srcId] === nodeCatMap[tgtId]) {
      sameCatLinks.push(l);
    } else {
      _crossCategoryLinks.push({ ...l, _crossCategory: true });
    }
  }
  // Visual links stored separately — NOT in graph data (avoids 6000+ Object3D overhead)
  // Only structural hierarchy links go into graph.graphData()
  _visualLinks = _linkMode === 'all'
    ? [...sameCatLinks, ..._crossCategoryLinks]
    : [...sameCatLinks];
  let visibleLinks = []; // only structural links will be added below

  // Anchor / Tag hierarchy: Anchor (parent) → Tags (child categories) → Memories
  const injectedNodes = [];
  const injectedLinks = [];
  const parentCats = Object.entries(categoryMetadata).filter(([, meta]) => meta.is_parent);

  // Pre-index visible nodes by category — O(n) instead of O(n * categories)
  const nodesByCat = new Map();
  for (const n of visibleNodes) {
    const cat = n.payload.category;
    let arr = nodesByCat.get(cat);
    if (!arr) { arr = []; nodesByCat.set(cat, arr); }
    arr.push(n);
  }

  for (const [parentName] of parentCats) {
    const childCats = Object.entries(categoryMetadata)
      .filter(([, m]) => m.parent === parentName)
      .map(([name]) => name);

    // Only create anchor if at least one memory in this tree is visible
    const parentMems = nodesByCat.get(parentName) || [];
    let hasTreeMemories = parentMems.length > 0;
    if (!hasTreeMemories) {
      for (const c of childCats) { if (nodesByCat.has(c)) { hasTreeMemories = true; break; } }
    }
    if (!hasTreeMemories) continue;

    // --- Anchor node (parent category) ---
    const anchorId = `_anchor_${parentName}`;
    injectedNodes.push({
      id: anchorId,
      payload: { category: parentName, _isAnchor: true, _anchorCategory: parentName, importance: 10, content: parentName }
    });

    // --- Tag nodes (child categories) ---
    for (const childName of childCats) {
      const childMemories = nodesByCat.get(childName) || [];
      if (childMemories.length === 0) continue;

      const tagId = `_tag_${childName}`;
      injectedNodes.push({
        id: tagId,
        payload: { category: childName, _isTag: true, _tagCategory: childName, _parentAnchor: parentName, importance: 8, content: childName }
      });

      // Tag → Anchor structural link
      injectedLinks.push({ source: anchorId, target: tagId, strength: 0.3, _isStructural: true });

      // Memory → Tag structural links (memories cluster around their tag)
      for (const mem of childMemories) {
        injectedLinks.push({ source: tagId, target: mem.id, strength: 0.5, _isStructural: true });
      }
    }

    // Memories directly on the parent category (if any) link to anchor
    for (const mem of parentMems) {
      injectedLinks.push({ source: anchorId, target: mem.id, strength: 0.4, _isStructural: true });
    }
  }

  visibleNodes = [...injectedNodes, ...visibleNodes];
  visibleIds = new Set(visibleNodes.map(n => n.id));
  visibleLinks = injectedLinks; // only structural links in graph data

  // Build node lookup for batch link renderer (resolve source/target IDs → positions)
  _nodeById = new Map();
  for (const n of visibleNodes) _nodeById.set(n.id, n);

  // Focus mode: only show selected node + direct neighbors
  if (focusedNodeId && visibleIds.has(focusedNodeId)) {
    const neighborIds = new Set([focusedNodeId]);
    // Check both structural and visual links for neighbor discovery
    const allLinksForFocus = [...visibleLinks, ..._visualLinks];
    allLinksForFocus.forEach(l => {
      const srcId = l.source.id || l.source;
      const tgtId = l.target.id || l.target;
      if (srcId === focusedNodeId) neighborIds.add(tgtId);
      if (tgtId === focusedNodeId) neighborIds.add(srcId);
    });
    visibleNodes = visibleNodes.filter(n => neighborIds.has(n.id));
    visibleIds = neighborIds;
    visibleLinks = visibleLinks.filter(l => {
      const srcId = l.source.id || l.source;
      const tgtId = l.target.id || l.target;
      return neighborIds.has(srcId) && neighborIds.has(tgtId);
    });
    _visualLinks = _visualLinks.filter(l => {
      const srcId = l.source.id || l.source;
      const tgtId = l.target.id || l.target;
      return neighborIds.has(srcId) && neighborIds.has(tgtId);
    });
    // Rebuild node lookup for filtered set
    _nodeById = new Map();
    for (const n of visibleNodes) _nodeById.set(n.id, n);
  }

  // Try to restore saved positions; if none found, compute layout
  const savedPositions = JSON.parse(localStorage.getItem(_posStorageKey) || '{}');
  const hasSaved = Object.keys(savedPositions).length > 0;

  if (hasSaved) {
    restoreNodePositions(visibleNodes);
  } else {
    computeLayout(visibleNodes);
  }

  graph.graphData({ nodes: visibleNodes, links: visibleLinks });
  _linkBatchDirty = true; // rebuild batch link list + colors

  // Pin any nodes that didn't get positioned (belt and suspenders)
  for (const n of visibleNodes) {
    if (n.fx == null && n.x != null) { n.fx = n.x; n.fy = n.y; n.fz = n.z; }
  }

  // Schedule auto-save
  schedulePositionSave();
}

function updateStats() {
  // Re-derive from what the graph is actually showing (exclude virtual nodes)
  const gd = graph ? graph.graphData() : { nodes: [], links: [] };
  const memoryNodes = gd.nodes.filter(n => n.payload && !n.payload._isAnchor && !n.payload._isTag);
  $statVisible.textContent = memoryNodes.length;
  $statLinks.textContent = _visualLinks.length;
}

// ═══════════════════════════════════════════
// CATEGORY MANAGEMENT
// ═══════════════════════════════════════════
// Store category metadata including parent and color
let categoryMetadata = {};

async function fetchCategories() {
  try {
    const res = await fetch('/api/categories');
    if (!res.ok) return;
    const data = await res.json();
    allCategoryNames = data.categories.map(c => c.name);
    categoryDescriptions = {};
    categoryMetadata = {};
    data.categories.forEach(c => {
      categoryDescriptions[c.name] = c.description;
      categoryMetadata[c.name] = {
        parent: c.parent,
        color: c.color,
        description: c.description,
        is_parent: c.is_parent,
        _ephemeral: c._ephemeral,
        logo: c.logo,
      };
    });
    preloadCategoryLogos(data.categories);
  } catch (e) {
    console.error('fetchCategories error:', e);
  }
}

function closeColorPicker() {
  const existing = document.querySelector('.color-edit-picker');
  if (existing) existing.remove();
}

function openColorPicker(cat, chipEl) {
  // Close any existing picker
  closeColorPicker();

  const picker = document.createElement('div');
  picker.className = 'color-edit-picker';

  const row = document.createElement('div');
  row.className = 'color-swatch-row';

  const currentColor = catColor(cat);

  COLOR_PALETTE.forEach(color => {
    const swatch = document.createElement('button');
    swatch.className = 'color-swatch' + (color === currentColor ? ' selected' : '');
    swatch.style.background = color;
    swatch.addEventListener('click', (e) => {
      e.stopPropagation();
      applyCategoryColor(cat, color);
      closeColorPicker();
    });
    row.appendChild(swatch);
  });

  picker.appendChild(row);

  // Reset to default button
  const overrides = JSON.parse(localStorage.getItem('neural-category-colors') || '{}');
  if (overrides[cat]) {
    const resetBtn = document.createElement('button');
    resetBtn.className = 'color-edit-reset';
    resetBtn.textContent = 'Reset to default';
    resetBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      applyCategoryColor(cat, null);
      closeColorPicker();
    });
    picker.appendChild(resetBtn);
  }

  // Insert after the chip
  chipEl.after(picker);

  // Close on outside click (deferred so current click doesn't trigger it)
  setTimeout(() => {
    function onOutsideClick(e) {
      if (!picker.contains(e.target)) {
        closeColorPicker();
        document.removeEventListener('click', onOutsideClick);
      }
    }
    document.addEventListener('click', onOutsideClick);
  }, 0);
}

function applyCategoryColor(cat, color) {
  const overrides = JSON.parse(localStorage.getItem('neural-category-colors') || '{}');
  if (color === null) {
    delete overrides[cat];
  } else {
    overrides[cat] = color;
  }
  localStorage.setItem('neural-category-colors', JSON.stringify(overrides));

  // Rebuild sidebar to reflect new color on the dot
  const presentCats = new Set(allNodes.map(n => n.payload.category));
  buildCategorySidebar(presentCats);

  // Force graph to recreate node objects with new colors
  if (graph) {
    graph.nodeThreeObject(createNodeObject);
  }
}

function closeDescEditor() {
  const existing = document.querySelector('.category-desc-editor');
  if (existing) existing.remove();
}

function openDescEditor(cat, chipEl) {
  closeDescEditor();
  closeColorPicker();

  const editor = document.createElement('div');
  editor.className = 'category-desc-editor';
  const currentDesc = categoryDescriptions[cat] || '';
  editor.innerHTML = `
    <label>Description for "${cat}"</label>
    <textarea class="desc-textarea">${currentDesc}</textarea>
    <div class="category-desc-actions">
      <button class="desc-cancel-btn">Cancel</button>
      <button class="desc-save-btn">Save</button>
    </div>
  `;

  const textarea = editor.querySelector('.desc-textarea');
  const saveBtn = editor.querySelector('.desc-save-btn');
  const cancelBtn = editor.querySelector('.desc-cancel-btn');

  cancelBtn.addEventListener('click', () => closeDescEditor());
  saveBtn.addEventListener('click', () => saveDescription(cat, textarea.value.trim()));

  textarea.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      saveDescription(cat, textarea.value.trim());
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      closeDescEditor();
    }
    e.stopPropagation();
  });
  textarea.addEventListener('keyup', (e) => e.stopPropagation());

  chipEl.after(editor);
  textarea.focus();
  textarea.setSelectionRange(textarea.value.length, textarea.value.length);
}

async function saveDescription(cat, description) {
  if (!description) return;
  const saveBtn = document.querySelector('.category-desc-editor .desc-save-btn');
  if (saveBtn) { saveBtn.textContent = 'Saving...'; saveBtn.disabled = true; }

  try {
    const res = await fetch('/api/categories/' + encodeURIComponent(cat), {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ description }),
    });
    const data = await res.json();
    if (!res.ok) {
      console.error('saveDescription error:', data.error);
      if (saveBtn) { saveBtn.textContent = 'Error'; saveBtn.disabled = false; }
      return;
    }
    allCategoryNames = data.categories.map(c => c.name);
    categoryDescriptions = {};
    data.categories.forEach(c => categoryDescriptions[c.name] = c.description);
    closeDescEditor();
  } catch (e) {
    console.error('saveDescription fetch error:', e);
    if (saveBtn) { saveBtn.textContent = 'Error'; saveBtn.disabled = false; }
  }
}

function openCategoryChangeModal(node) {
  const current = node.payload.category;

  const overlay = document.createElement('div');
  overlay.className = 'tag-delete-overlay';

  let listHtml = '';
  allCategoryNames.forEach(cat => {
    const desc = categoryDescriptions[cat] || '';
    const isActive = cat === current;
    listHtml += `
      <div class="cat-modal-option${isActive ? ' active' : ''}" data-cat="${cat}">
        <div class="cat-opt-dot" style="color:${catColor(cat)}; background:${catColor(cat)}"></div>
        <span class="cat-opt-name">${cat}</span>
        ${desc ? `<span class="cat-opt-desc">${desc}</span>` : ''}
      </div>`;
  });

  overlay.innerHTML = `
    <div class="tag-delete-modal cat-change-modal">
      <div class="cat-change-modal-title">Move to category</div>
      <div class="cat-change-modal-current">
        <div class="cat-dot" style="color:${catColor(current)}; background:${catColor(current)}"></div>
        ${current}
      </div>
      <div class="cat-change-modal-list">${listHtml}</div>
    </div>
  `;

  document.body.appendChild(overlay);

  // Click a category to change
  overlay.querySelectorAll('.cat-modal-option').forEach(opt => {
    opt.addEventListener('click', () => {
      const cat = opt.dataset.cat;
      overlay.remove();
      if (cat !== current) {
        changeMemoryCategory(node, cat);
      }
    });
  });

  // Close on overlay backdrop click
  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) overlay.remove();
  });
}

async function changeMemoryCategory(node, newCategory) {
  const oldCategory = node.payload.category;

  // Optimistic update
  node.payload.category = newCategory;

  // Update detail panel label + color
  const color = catColor(newCategory);
  const headerDot = document.getElementById('detail-header-dot');
  if (headerDot) { headerDot.style.color = color; headerDot.style.background = color; }
  const label = document.getElementById('detail-category-label');
  if (label) { label.textContent = newCategory + (node.payload.subcategory ? ' / ' + node.payload.subcategory : ''); label.style.color = color; }

  // Rebuild sidebar + graph
  const presentCats = new Set(allNodes.map(n => n.payload.category));
  buildCategorySidebar(presentCats);
  if (graph) graph.nodeThreeObject(createNodeObject);

  // Persist to server
  try {
    const res = await fetch('/api/memory/' + encodeURIComponent(node.id), {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ category: newCategory }),
    });
    if (!res.ok) {
      const err = await res.json();
      console.error('changeMemoryCategory error:', err.error);
      // Rollback
      node.payload.category = oldCategory;
      const rColor = catColor(oldCategory);
      if (headerDot) { headerDot.style.color = rColor; headerDot.style.background = rColor; }
      if (label) { label.textContent = oldCategory + (node.payload.subcategory ? ' / ' + node.payload.subcategory : ''); label.style.color = rColor; }
      const rCats = new Set(allNodes.map(n => n.payload.category));
      buildCategorySidebar(rCats);
      if (graph) graph.nodeThreeObject(createNodeObject);
    }
  } catch (e) {
    console.error('changeMemoryCategory fetch error:', e);
    node.payload.category = oldCategory;
  }
}

async function createCategory(name, description, color, parent, isParent) {
  const payload = { name, description };
  if (parent) payload.parent = parent;
  if (color) payload.color = color;
  if (isParent) payload.is_parent = true;

  const res = await fetch('/api/categories', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });
  const data = await res.json();
  if (!res.ok) throw new Error(data.error);
  allCategoryNames = data.categories.map(c => c.name);
  categoryDescriptions = {};
  categoryMetadata = {};
  data.categories.forEach(c => {
    categoryDescriptions[c.name] = c.description;
    categoryMetadata[c.name] = {
      parent: c.parent,
      color: c.color,
      description: c.description,
      is_parent: c.is_parent,
      logo: c.logo,
    };
  });
  preloadCategoryLogos(data.categories);
  // Save chosen color
  if (color) {
    const overrides = JSON.parse(localStorage.getItem('neural-category-colors') || '{}');
    overrides[name] = color;
    localStorage.setItem('neural-category-colors', JSON.stringify(overrides));
  }
  // Add to active set & rebuild
  activeCategories.add(name);
  const presentCats = new Set(allNodes.map(n => n.payload.category));
  buildCategorySidebar(presentCats);
}

async function editCategoryUI(name) {
  const overlay = document.createElement('div');
  overlay.className = 'tag-delete-overlay';

  const meta = categoryMetadata[name] || {};
  const currentDesc = categoryDescriptions[name] || '';
  const currentParent = meta.parent || '';
  const currentColor = meta.color || catColor(name);

  // Get available parent categories (excluding this one and its descendants)
  const getDescendants = (catName) => {
    const directChildren = allCategoryNames.filter(c => {
      const m = categoryMetadata[c] || {};
      return m.parent === catName;
    });
    const allDescendants = [...directChildren];
    directChildren.forEach(child => {
      allDescendants.push(...getDescendants(child));
    });
    return allDescendants;
  };

  const descendants = getDescendants(name);
  const descendantSet = new Set(descendants);
  const availableParents = allCategoryNames.filter(c => c !== name && !descendantSet.has(c));

  overlay.innerHTML = `
    <div class="tag-delete-modal" style="min-width:400px">
      <div class="tag-delete-modal-title">Edit Category</div>
      <div class="tag-delete-modal-tag">${name}</div>

      <div style="margin-top:16px">
        <label style="display:block;font-size:var(--fs-sm);margin-bottom:4px;color:var(--t-primary)">Name</label>
        <input type="text" class="edit-cat-name modal-select" value="${name}">
      </div>

      <div style="margin-top:12px">
        <label style="display:block;font-size:var(--fs-sm);margin-bottom:4px;color:var(--t-primary)">Description</label>
        <textarea class="edit-cat-desc modal-select" rows="3" style="resize:vertical;font-family:inherit">${currentDesc}</textarea>
      </div>

      <div style="margin-top:12px">
        <label style="display:block;font-size:var(--fs-sm);margin-bottom:4px;color:var(--t-primary)">Parent Category</label>
        <select class="edit-cat-parent modal-select">
          <option value="">-- No parent (top-level) --</option>
          ${availableParents.map(c => `<option value="${c}" ${c === currentParent ? 'selected' : ''}>${c}</option>`).join('')}
        </select>
      </div>

      <div style="margin-top:12px;display:flex;align-items:center;gap:8px" class="edit-cat-isparent-row" ${currentParent ? 'hidden' : ''}>
        <input type="checkbox" class="edit-cat-isparent" id="edit-cat-isparent-cb" ${meta.is_parent ? 'checked' : ''}>
        <label for="edit-cat-isparent-cb" style="font-size:var(--fs-sm);color:var(--t-primary);cursor:pointer">Make this a parent category (cluster container)</label>
      </div>

      <div style="margin-top:12px">
        <label style="display:block;font-size:var(--fs-sm);margin-bottom:4px;color:var(--t-primary)">Color</label>
        <input type="color" class="edit-cat-color modal-select" value="${currentColor}"
          style="height:40px;cursor:pointer;padding:4px">
      </div>

      <div style="margin-top:12px" class="edit-cat-logo-row" ${!(meta.is_parent && !currentParent) ? 'hidden' : ''}>
        <label style="display:block;font-size:var(--fs-sm);margin-bottom:6px;color:var(--t-primary)">Category Logo <span style="font-weight:400;opacity:0.5;font-size:11px">(displayed on parent anchor node)</span></label>
        <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
          ${meta.logo
            ? `<img class="edit-cat-logo-preview" src="${meta.logo}?t=${Date.now()}" style="height:36px;max-width:140px;object-fit:contain;border-radius:4px;border:1px solid rgba(255,255,255,0.1)">`
            : `<span class="edit-cat-logo-preview" style="font-size:var(--fs-sm);opacity:0.5">No logo set</span>`
          }
          <label class="action-btn action-btn--ghost" style="cursor:pointer;font-size:var(--fs-sm);padding:6px 12px">
            ${meta.logo ? 'Replace' : 'Upload'}
            <input type="file" class="edit-cat-logo-file" accept="image/*" style="display:none">
          </label>
          ${meta.logo ? `<button class="action-btn action-btn--ghost edit-cat-logo-remove" style="font-size:var(--fs-sm);padding:6px 12px;color:var(--accent-red)">Remove</button>` : ''}
        </div>
      </div>

      <div class="tag-delete-modal-actions">
        <button class="action-btn action-btn--ghost cat-modal-cancel">Cancel</button>
        <button class="action-btn action-btn--primary cat-modal-confirm">Save Changes</button>
      </div>
    </div>
  `;

  document.body.appendChild(overlay);

  const $nameInput = overlay.querySelector('.edit-cat-name');
  const $descInput = overlay.querySelector('.edit-cat-desc');
  const $parentSelect = overlay.querySelector('.edit-cat-parent');
  const $colorInput = overlay.querySelector('.edit-cat-color');
  const $isParentCheck = overlay.querySelector('.edit-cat-isparent');
  const $isParentRow = overlay.querySelector('.edit-cat-isparent-row');

  upgradeSelect($parentSelect);

  const $logoRow = overlay.querySelector('.edit-cat-logo-row');
  const $logoFile = overlay.querySelector('.edit-cat-logo-file');
  const $logoRemoveBtn = overlay.querySelector('.edit-cat-logo-remove');

  // Show/hide is_parent checkbox and logo row based on parent selection
  $parentSelect.addEventListener('change', () => {
    if ($parentSelect.value) {
      $isParentRow.hidden = true;
      $isParentCheck.checked = false;
      if ($logoRow) $logoRow.hidden = true;
    } else {
      $isParentRow.hidden = false;
      if ($logoRow) $logoRow.hidden = !$isParentCheck.checked;
    }
  });

  // Show/hide logo row based on is_parent checkbox
  $isParentCheck.addEventListener('change', () => {
    if ($logoRow) $logoRow.hidden = !$isParentCheck.checked;
  });

  // Logo upload — fires immediately on file select
  if ($logoFile) {
    $logoFile.addEventListener('change', async () => {
      const file = $logoFile.files[0];
      if (!file) return;
      const uploadLabel = $logoFile.closest('label');
      const origText = uploadLabel.textContent.trim();
      uploadLabel.childNodes[0].textContent = 'Uploading… ';
      try {
        const buf = await file.arrayBuffer();
        const res = await fetch('/api/categories/' + encodeURIComponent(name) + '/logo', {
          method: 'POST',
          headers: { 'Content-Type': file.type || 'image/png' },
          body: buf,
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error);

        // Update preview
        const preview = overlay.querySelector('.edit-cat-logo-preview');
        if (preview.tagName === 'IMG') {
          preview.src = data.logo + '?t=' + Date.now();
        } else {
          const img = document.createElement('img');
          img.className = 'edit-cat-logo-preview';
          img.style.cssText = 'height:36px;max-width:140px;object-fit:contain;border-radius:4px;border:1px solid rgba(255,255,255,0.1)';
          img.src = data.logo + '?t=' + Date.now();
          preview.replaceWith(img);
        }
        // Add remove button if not present
        if (!overlay.querySelector('.edit-cat-logo-remove')) {
          const rmBtn = document.createElement('button');
          rmBtn.className = 'action-btn action-btn--ghost edit-cat-logo-remove';
          rmBtn.style.cssText = 'font-size:var(--fs-sm);padding:6px 12px;color:var(--accent-red)';
          rmBtn.textContent = 'Remove';
          uploadLabel.after(rmBtn);
          attachLogoRemoveHandler(rmBtn);
        }

        if (categoryMetadata[name]) categoryMetadata[name].logo = data.logo;
        preloadCategoryLogos(data.categories);
        uploadLabel.childNodes[0].textContent = 'Replace ';
        // Rebuild graph to show new logo on anchor
        if (graph) { graph.nodeThreeObject(createNodeObject); applyGraphData(); }
      } catch (err) {
        alert('Logo upload failed: ' + err.message);
        uploadLabel.childNodes[0].textContent = origText + ' ';
      }
    });
  }

  function attachLogoRemoveHandler(btn) {
    btn.addEventListener('click', async () => {
      btn.textContent = 'Removing…';
      btn.disabled = true;
      try {
        const res = await fetch('/api/categories/' + encodeURIComponent(name) + '/logo', { method: 'DELETE' });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error);
        const preview = overlay.querySelector('.edit-cat-logo-preview');
        const span = document.createElement('span');
        span.className = 'edit-cat-logo-preview';
        span.style.cssText = 'font-size:var(--fs-sm);opacity:0.5';
        span.textContent = 'No logo set';
        preview.replaceWith(span);
        btn.remove();
        if (categoryMetadata[name]) delete categoryMetadata[name].logo;
        _categoryLogos.delete(name);
        const uploadLabel = overlay.querySelector('.edit-cat-logo-file')?.closest('label');
        if (uploadLabel) uploadLabel.childNodes[0].textContent = 'Upload ';
        if (graph) { graph.nodeThreeObject(createNodeObject); applyGraphData(); }
      } catch (err) {
        alert('Failed to remove logo: ' + err.message);
        btn.textContent = 'Remove';
        btn.disabled = false;
      }
    });
  }

  if ($logoRemoveBtn) attachLogoRemoveHandler($logoRemoveBtn);

  overlay.querySelector('.cat-modal-cancel').addEventListener('click', () => overlay.remove());
  overlay.querySelector('.cat-modal-confirm').addEventListener('click', async () => {
    const newName = $nameInput.value.trim();
    const newDesc = $descInput.value.trim();
    const newParent = $parentSelect.value;
    const newColor = $colorInput.value;
    const newIsParent = $isParentCheck.checked;

    if (!newName || !newDesc) {
      alert('Name and description are required');
      return;
    }

    const btn = overlay.querySelector('.cat-modal-confirm');
    btn.textContent = 'Saving...';
    btn.disabled = true;

    const updates = {};
    if (newName !== name) updates.new_name = newName;
    if (newDesc !== currentDesc) updates.description = newDesc;
    if (newParent !== currentParent) updates.parent = newParent;
    if (newColor !== currentColor) updates.color = newColor;
    if (newIsParent !== !!meta.is_parent) updates.is_parent = newIsParent;

    const res = await fetch('/api/categories/' + encodeURIComponent(name), {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(updates),
    });

    const data = await res.json();
    if (!res.ok) {
      alert('Error updating category: ' + data.error);
      btn.textContent = 'Save Changes';
      btn.disabled = false;
      return;
    }

    // Update local state
    allCategoryNames = data.categories.map(c => c.name);
    categoryDescriptions = {};
    categoryMetadata = {};
    data.categories.forEach(c => {
      categoryDescriptions[c.name] = c.description;
      categoryMetadata[c.name] = { parent: c.parent, color: c.color, is_parent: c.is_parent, logo: c.logo };
    });
    preloadCategoryLogos(data.categories);

    // Update localStorage colors
    try {
      const overrides = JSON.parse(localStorage.getItem('neural-category-colors') || '{}');
      if (newColor !== currentColor) {
        overrides[newName || name] = newColor;
      }
      if (newName !== name && overrides[name]) {
        overrides[newName] = overrides[name];
        delete overrides[name];
      }
      localStorage.setItem('neural-category-colors', JSON.stringify(overrides));
    } catch {}

    // If renamed, update activeCategories
    if (newName !== name) {
      if (activeCategories.has(name)) {
        activeCategories.delete(name);
        activeCategories.add(newName);
      }
    }

    const presentCats = new Set(allNodes.map(n => n.payload.category));
    buildCategorySidebar(presentCats);
    applyGraphData();
    updateStats();

    overlay.remove();
  });

  overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
}

function deleteCategoryUI(name, count, chipEl) {
  const overlay = document.createElement('div');
  overlay.className = 'tag-delete-overlay';
  const allCats = allCategoryNames.filter(c => c !== name);

  // Check if this category has children
  const children = allCategoryNames.filter(c => {
    const meta = categoryMetadata[c] || {};
    return meta.parent === name;
  });

  const hasChildren = children.length > 0;
  const hasMemories = count > 0;

  // Helper: build children reassignment HTML
  const buildChildrenSelect = () => {
    if (!hasChildren) return '';
    const getDescendants = (catName) => {
      const direct = allCategoryNames.filter(c => (categoryMetadata[c] || {}).parent === catName);
      const all = [...direct];
      direct.forEach(child => all.push(...getDescendants(child)));
      return all;
    };
    const descendantSet = new Set(getDescendants(name));
    const available = allCategoryNames.filter(c => c !== name && !descendantSet.has(c));
    return `
      <div style="font-size:var(--fs-sm);color:var(--t-secondary);margin:12px 0 6px;text-align:left">
        ${children.length} child categor${children.length === 1 ? 'y' : 'ies'}: <strong>${children.join(', ')}</strong><br>Reassign children to:
      </div>
      <select class="cat-modal-select-children modal-select">
        <option value="">-- Make top-level --</option>
        ${available.map(c => `<option value="${c}">${c}</option>`).join('')}
      </select>
    `;
  };

  if (!hasMemories && !hasChildren) {
    // Simple delete — no memories, no children
    overlay.innerHTML = `
      <div class="tag-delete-modal">
        <div class="tag-delete-modal-title">Delete category</div>
        <div class="tag-delete-modal-tag">${name}</div>
        <div class="tag-delete-modal-actions">
          <button class="action-btn action-btn--ghost cat-modal-cancel">Cancel</button>
          <button class="action-btn action-btn--danger cat-modal-confirm">Delete</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    overlay.querySelector('.cat-modal-cancel').addEventListener('click', () => overlay.remove());
    overlay.querySelector('.cat-modal-confirm').addEventListener('click', () => {
      overlay.remove();
      deleteCategory(name);
    });
    overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });

  } else if (!hasMemories && hasChildren) {
    // Only children to handle, no memories
    overlay.innerHTML = `
      <div class="tag-delete-modal" style="min-width:340px">
        <div class="tag-delete-modal-title">Delete category</div>
        <div class="tag-delete-modal-tag">${name}</div>
        ${buildChildrenSelect()}
        <div class="tag-delete-modal-actions" style="margin-top:14px">
          <button class="action-btn action-btn--ghost cat-modal-cancel">Cancel</button>
          <button class="action-btn action-btn--danger cat-modal-confirm">Delete</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    const childSel = overlay.querySelector('.cat-modal-select-children');
    if (childSel) upgradeSelect(childSel);
    overlay.querySelector('.cat-modal-cancel').addEventListener('click', () => overlay.remove());
    overlay.querySelector('.cat-modal-confirm').addEventListener('click', async () => {
      const targetChildren = overlay.querySelector('.cat-modal-select-children')?.value;
      const btn = overlay.querySelector('.cat-modal-confirm');
      btn.textContent = 'Deleting...';
      btn.disabled = true;
      await deleteCategory(name, null, targetChildren);
      overlay.remove();
    });
    overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });

  } else {
    // Has memories — show 3-option flow
    const svgTrash = `<svg viewBox="0 0 24 24"><path d="M3 6h18"/><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><path d="M19 6l-.7 12.1a2 2 0 0 1-2 1.9H7.7a2 2 0 0 1-2-1.9L5 6"/><path d="M10 11v5"/><path d="M14 11v5"/></svg>`;
    const svgExport = `<svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>`;
    const svgMigrate = `<svg viewBox="0 0 24 24"><path d="M5 9l4-4 4 4"/><path d="M9 5v10a4 4 0 0 0 4 4h6"/><polyline points="15 15 19 19 15 23"/></svg>`;

    overlay.innerHTML = `
      <div class="tag-delete-modal" style="min-width:380px">
        <div class="tag-delete-modal-title">Delete category</div>
        <div class="tag-delete-modal-tag">${name}</div>
        <div style="font-size:var(--fs-sm);color:var(--t-secondary);margin-bottom:4px">
          ${count} memor${count === 1 ? 'y' : 'ies'} in this category. What would you like to do?
        </div>
        <div class="cat-delete-options">
          <div class="cat-delete-option cat-delete-option--delete" data-action="delete">
            <div class="cat-delete-option-icon">${svgTrash}</div>
            <div class="cat-delete-option-text">
              <div class="cat-delete-option-label">Trash all memories</div>
              <div class="cat-delete-option-desc">Move all ${count} memor${count === 1 ? 'y' : 'ies'} to trash</div>
            </div>
          </div>
          <div class="cat-delete-option cat-delete-option--export" data-action="export">
            <div class="cat-delete-option-icon">${svgExport}</div>
            <div class="cat-delete-option-text">
              <div class="cat-delete-option-label">Export as Markdown</div>
              <div class="cat-delete-option-desc">Download all memories as .md then trash</div>
            </div>
          </div>
          <div class="cat-delete-option cat-delete-option--migrate" data-action="migrate">
            <div class="cat-delete-option-icon">${svgMigrate}</div>
            <div class="cat-delete-option-text">
              <div class="cat-delete-option-label">Migrate to another category</div>
              <div class="cat-delete-option-desc">Move memories before deleting this category</div>
            </div>
          </div>
        </div>
        ${buildChildrenSelect()}
        <div class="cat-delete-step" id="cat-delete-step-area"></div>
        <div class="tag-delete-modal-actions">
          <button class="action-btn action-btn--ghost cat-modal-cancel">Cancel</button>
          <button class="action-btn action-btn--danger cat-modal-confirm" disabled style="opacity:0.4">Continue</button>
        </div>
      </div>
    `;

    document.body.appendChild(overlay);
    const modal = overlay.querySelector('.tag-delete-modal');
    const stepArea = modal.querySelector('#cat-delete-step-area');
    const confirmBtn = modal.querySelector('.cat-modal-confirm');
    let selectedAction = null;

    // Upgrade children select if present
    const childSel3 = modal.querySelector('.cat-modal-select-children');
    if (childSel3) upgradeSelect(childSel3);

    // Option selection
    modal.querySelectorAll('.cat-delete-option').forEach(opt => {
      opt.addEventListener('click', () => {
        modal.querySelectorAll('.cat-delete-option').forEach(o => o.classList.remove('selected'));
        opt.classList.add('selected');
        selectedAction = opt.dataset.action;
        confirmBtn.disabled = false;
        confirmBtn.style.opacity = '1';
        stepArea.innerHTML = '';

        if (selectedAction === 'delete') {
          confirmBtn.textContent = 'Trash all';
          confirmBtn.className = 'action-btn action-btn--danger cat-modal-confirm';
        } else if (selectedAction === 'export') {
          confirmBtn.textContent = 'Export & Trash';
          confirmBtn.className = 'action-btn action-btn--danger cat-modal-confirm';
        } else if (selectedAction === 'migrate') {
          confirmBtn.textContent = 'Migrate & Delete';
          confirmBtn.className = 'action-btn action-btn--danger cat-modal-confirm';
          stepArea.innerHTML = `
            <div style="font-size:var(--fs-sm);color:var(--t-secondary);margin:4px 0 4px;text-align:left">Move memories to:</div>
            <select class="cat-modal-select-memories modal-select">
              ${allCats.map(c => `<option value="${c}">${c}</option>`).join('')}
            </select>
          `;
          const memSel = stepArea.querySelector('.cat-modal-select-memories');
          if (memSel) upgradeSelect(memSel);
        }
      });
    });

    // Cancel
    overlay.querySelector('.cat-modal-cancel').addEventListener('click', () => overlay.remove());
    overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });

    // Confirm
    confirmBtn.addEventListener('click', async () => {
      if (!selectedAction) return;
      const targetChildren = hasChildren ? modal.querySelector('.cat-modal-select-children')?.value : undefined;

      if (selectedAction === 'delete') {
        confirmBtn.textContent = 'Trashing...';
        confirmBtn.disabled = true;
        await deleteCategory(name, null, targetChildren, { deleteMemories: true });
        overlay.remove();

      } else if (selectedAction === 'export') {
        confirmBtn.textContent = 'Exporting...';
        confirmBtn.disabled = true;
        try {
          const res = await fetch('/api/categories/' + encodeURIComponent(name) + '/export');
          if (!res.ok) throw new Error((await res.json()).error || 'Export failed');
          const blob = await res.blob();
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${name}-memories.md`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
          // Now trash
          confirmBtn.textContent = 'Trashing...';
          await deleteCategory(name, null, targetChildren, { deleteMemories: true });
          overlay.remove();
        } catch (err) {
          console.error('Export failed:', err);
          alert('Export failed: ' + err.message);
          confirmBtn.textContent = 'Export & Trash';
          confirmBtn.disabled = false;
        }

      } else if (selectedAction === 'migrate') {
        const targetMemories = modal.querySelector('.cat-modal-select-memories')?.value;
        if (!targetMemories) return;
        confirmBtn.textContent = 'Migrating...';
        confirmBtn.disabled = true;
        await deleteCategory(name, targetMemories, targetChildren);
        overlay.remove();
      }
    });
  }
}

async function deleteCategory(name, reassignTo, reassignChildrenTo, options = {}) {
  const body = {};
  if (reassignTo) body.reassign_to = reassignTo;
  if (reassignChildrenTo !== undefined) body.reassign_children_to = reassignChildrenTo;
  if (options.deleteMemories) body.delete_memories = true;

  const res = await fetch('/api/categories/' + encodeURIComponent(name), {
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  });
  const data = await res.json();
  if (!res.ok) {
    console.error('deleteCategory error:', data.error);
    alert('Error deleting category: ' + data.error);
    return;
  }
  allCategoryNames = data.categories.map(c => c.name);
  categoryDescriptions = {};
  data.categories.forEach(c => categoryDescriptions[c.name] = c.description);
  // Update categoryMetadata
  categoryMetadata = {};
  data.categories.forEach(c => {
    categoryMetadata[c.name] = { parent: c.parent, color: c.color, is_parent: c.is_parent, logo: c.logo };
  });
  preloadCategoryLogos(data.categories);
  // Remove color override
  try {
    const overrides = JSON.parse(localStorage.getItem('neural-category-colors') || '{}');
    delete overrides[name];
    localStorage.setItem('neural-category-colors', JSON.stringify(overrides));
  } catch {}
  activeCategories.delete(name);

  // Re-fetch memories if anything changed (reassigned or deleted)
  if (reassignTo || options.deleteMemories || (data.reassigned && data.reassigned > 0) || (data.deleted && data.deleted > 0)) {
    const memRes = await fetch('/api/memories');
    if (memRes.ok) {
      const memData = await memRes.json();
      allNodes = memData.nodes;
      allLinks = memData.links;
    }
  }

  const presentCats = new Set(allNodes.map(n => n.payload.category));
  buildCategorySidebar(presentCats);
  applyGraphData();
  updateStats();

  // Update trash badge if memories were trashed
  if (options.deleteMemories) {
    try { fetchTrashItems(); } catch {}
  }
}

// Category create form wiring
{
  const $addBtn = document.getElementById('category-add-btn');
  const $addParentBtn = document.getElementById('category-add-parent-btn');
  const $form = document.getElementById('category-create-form');
  const $formTitle = document.getElementById('cat-form-title');
  const $nameInput = document.getElementById('cat-name-input');
  const $descInput = document.getElementById('cat-desc-input');
  const $parentSelect = document.getElementById('cat-parent-select');
  const $swatchRow = document.getElementById('color-swatch-row');
  const $error = document.getElementById('cat-form-error');
  const $createBtn = document.getElementById('cat-form-create');
  const $cancelBtn = document.getElementById('cat-form-cancel');
  let selectedColor = COLOR_PALETTE[0];
  let formMode = 'child'; // 'child' or 'parent'

  // Build swatches
  COLOR_PALETTE.forEach((color, i) => {
    const btn = document.createElement('button');
    btn.className = 'color-swatch' + (i === 0 ? ' selected' : '');
    btn.style.background = color;
    btn.addEventListener('click', () => {
      $swatchRow.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
      btn.classList.add('selected');
      selectedColor = color;
    });
    $swatchRow.appendChild(btn);
  });

  // Populate parent dropdown
  function populateParentDropdown() {
    // Clear and re-populate with all categories
    $parentSelect.innerHTML = '<option value="">(None - standalone category)</option>';
    allCategoryNames.forEach(catName => {
      const opt = document.createElement('option');
      opt.value = catName;
      opt.textContent = catName;
      $parentSelect.appendChild(opt);
    });
  }

  function openForm(mode) {
    formMode = mode;
    $form.dataset.mode = mode;
    $form.classList.add('open');

    if (mode === 'parent') {
      $formTitle.textContent = 'CREATE PARENT CATEGORY';
      $nameInput.placeholder = 'parent-category-name';
      $descInput.placeholder = 'What does this group contain?';
    } else {
      $formTitle.textContent = 'CREATE CATEGORY';
      $nameInput.placeholder = 'category-name';
      $descInput.placeholder = 'Short description...';
      populateParentDropdown();
      upgradeSelect($parentSelect);
    }

    $nameInput.focus();
  }

  function closeForm() {
    $form.classList.remove('open');
    $nameInput.value = '';
    $descInput.value = '';
    $parentSelect.value = '';
    $error.textContent = '';
    $createBtn.disabled = true;
    $nameInput.classList.remove('invalid');
  }

  function validateForm() {
    const name = $nameInput.value;
    const desc = $descInput.value.trim();
    if (!name) { $error.textContent = ''; $createBtn.disabled = true; return; }
    if (name.length < 2) { $error.textContent = 'Min 2 characters'; $createBtn.disabled = true; return; }
    if (!/^[a-z][a-z0-9-]*$/.test(name)) { $error.textContent = 'Lowercase, starts with letter, letters/digits/hyphens only'; $createBtn.disabled = true; $nameInput.classList.add('invalid'); return; }
    $nameInput.classList.remove('invalid');
    if (!desc) { $error.textContent = 'Description required'; $createBtn.disabled = true; return; }
    $error.textContent = '';
    $createBtn.disabled = false;
  }

  $nameInput.addEventListener('input', () => {
    // Auto-lowercase and strip invalid chars as user types
    $nameInput.value = $nameInput.value.toLowerCase().replace(/[^a-z0-9-]/g, '');
    validateForm();
  });
  $descInput.addEventListener('input', validateForm);

  $addBtn.addEventListener('click', () => {
    if ($form.classList.contains('open')) {
      closeForm();
    } else {
      openForm('child');
    }
  });

  $addParentBtn.addEventListener('click', () => {
    if ($form.classList.contains('open')) {
      closeForm();
    } else {
      openForm('parent');
    }
  });

  $cancelBtn.addEventListener('click', () => {
    closeForm();
  });

  $createBtn.addEventListener('click', async () => {
    const name = $nameInput.value;
    const desc = $descInput.value.trim();
    // Only pass parent if we're in child mode
    const parent = formMode === 'child' ? ($parentSelect.value || null) : null;
    const isParent = formMode === 'parent';
    $createBtn.disabled = true;
    $createBtn.textContent = 'Creating...';
    try {
      await createCategory(name, desc, selectedColor, parent, isParent);
      closeForm();
    } catch (e) {
      $error.textContent = e.message;
    }
    $createBtn.textContent = 'Create';
    validateForm();
  });
}

// ═══════════════════════════════════════════
// CAMERA MOVEMENT SYSTEM (WASD + Q/E + Shift)
// ═══════════════════════════════════════════
const _camKeys = { w: false, a: false, s: false, d: false, q: false, e: false, shift: false, space: false };
const _camVelocity = new THREE.Vector3(); // current movement velocity (smoothed)
const _camMoveDir = new THREE.Vector3();  // desired movement direction
const _camForward = new THREE.Vector3();  // camera forward (XZ plane)
const _camRight = new THREE.Vector3();    // camera right (XZ plane)
const CAM_BASE_SPEED = 3.5;     // base movement speed per frame
const CAM_BOOST_MULT = 3.0;     // shift multiplier
const CAM_ACCEL = 0.12;         // acceleration smoothing (0-1, higher = snappier)
const CAM_DECEL = 0.08;         // deceleration smoothing (lower = more glide)
const CAM_HEIGHT_SPEED = 2.5;   // vertical movement speed
let _camMoving = false;
let _camHudVisible = false;
let _camHudTimeout = null;
let _hudDrag = null;

// HUD elements
const _$camHud = document.getElementById('camera-hud');
const _$compassFov = document.getElementById('compass-fov');
const _$compassNeedle = document.getElementById('compass-needle');
const _$altFill = document.getElementById('alt-fill');
const _$altValue = document.getElementById('alt-value');
const _$camSpeed = document.getElementById('cam-speed-label');
const _$keyQ = document.getElementById('key-q');
const _$keyW = document.getElementById('key-w');
const _$keyE = document.getElementById('key-e');
const _$keyA = document.getElementById('key-a');
const _$keyS = document.getElementById('key-s');
const _$keyD = document.getElementById('key-d');

// Generate compass tick marks
{
  const ticksG = document.getElementById('compass-ticks');
  for (let deg = 0; deg < 360; deg += 15) {
    const isMajor = deg % 90 === 0;
    const r1 = isMajor ? 26 : 28;
    const r2 = 32;
    const rad = (deg - 90) * Math.PI / 180;
    const x1 = 36 + r1 * Math.cos(rad);
    const y1 = 36 + r1 * Math.sin(rad);
    const x2 = 36 + r2 * Math.cos(rad);
    const y2 = 36 + r2 * Math.sin(rad);
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', x1); line.setAttribute('y1', y1);
    line.setAttribute('x2', x2); line.setAttribute('y2', y2);
    line.setAttribute('class', isMajor ? 'compass-tick-major' : 'compass-tick');
    ticksG.appendChild(line);
  }
}

let _camHudPinned = localStorage.getItem('neural-cam-hud-pinned') === 'true';

// Restore pin state on load
{
  const pinBtn = document.getElementById('cam-pin-btn');
  if (_camHudPinned) {
    _$camHud.classList.add('pinned');
    _camHudVisible = true;
  }
  // Restore saved position
  const savedPos = localStorage.getItem('neural-cam-hud-pos');
  if (savedPos) {
    try {
      const { right, bottom } = JSON.parse(savedPos);
      _$camHud.style.right = right + 'px';
      _$camHud.style.bottom = bottom + 'px';
    } catch {}
  }
  // Pin toggle
  pinBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    _camHudPinned = !_camHudPinned;
    _$camHud.classList.toggle('pinned', _camHudPinned);
    localStorage.setItem('neural-cam-hud-pinned', _camHudPinned);
    if (_camHudPinned) {
      _camHudVisible = true;
      _$camHud.classList.add('visible');
      clearTimeout(_camHudTimeout);
    }
  });
  // Drag via grip
  const grip = document.getElementById('cam-drag-grip');
  grip.addEventListener('mousedown', (e) => {
    e.preventDefault();
    e.stopPropagation();
    const rect = _$camHud.getBoundingClientRect();
    _hudDrag = {
      startX: e.clientX, startY: e.clientY,
      startRight: window.innerWidth - rect.right,
      startBottom: window.innerHeight - rect.bottom,
    };
    _$camHud.classList.add('dragging');
    document.body.style.cursor = 'grabbing';
    document.body.style.userSelect = 'none';
  });
  document.addEventListener('mousemove', (e) => {
    if (!_hudDrag) return;
    const dx = e.clientX - _hudDrag.startX;
    const dy = e.clientY - _hudDrag.startY;
    const newRight = Math.max(0, _hudDrag.startRight - dx);
    const newBottom = Math.max(0, _hudDrag.startBottom - dy);
    _$camHud.style.right = newRight + 'px';
    _$camHud.style.bottom = newBottom + 'px';
  });
  document.addEventListener('mouseup', () => {
    if (!_hudDrag) return;
    _hudDrag = null;
    _$camHud.classList.remove('dragging');
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
    // Persist position
    localStorage.setItem('neural-cam-hud-pos', JSON.stringify({
      right: parseFloat(_$camHud.style.right) || 24,
      bottom: parseFloat(_$camHud.style.bottom) || 70,
    }));
  });
}

function showCamHud() {
  if (_camHudPinned) { _camHudVisible = true; return; }
  if (!_camHudVisible) {
    _camHudVisible = true;
    _$camHud.classList.add('visible');
  }
  clearTimeout(_camHudTimeout);
  _camHudTimeout = setTimeout(() => {
    if (!_camMoving && !_camHudPinned && !_hudDrag) {
      _camHudVisible = false;
      _$camHud.classList.remove('visible');
    }
  }, 2500);
}

function updateCamHud() {
  if (!graph || (!_camHudVisible && !_camHudPinned)) return;
  const cam = graph.camera();
  const controls = graph.controls();
  if (!cam || !controls) return;

  // --- Compass: rotate based on camera yaw ---
  const dir = new THREE.Vector3();
  cam.getWorldDirection(dir);
  // Yaw angle from -Z (north in 3D) projected onto XZ plane
  const yaw = Math.atan2(dir.x, dir.z); // radians, 0 = looking along +Z
  const yawDeg = yaw * 180 / Math.PI;

  // Rotate the entire compass ticks/labels group
  // The needle stays fixed at top; the ring rotates
  const ticksG = document.getElementById('compass-ticks');
  ticksG.setAttribute('transform', `rotate(${-yawDeg}, 36, 36)`);

  // Rotate cardinal labels
  const labels = { 'N': 0, 'E': 90, 'S': 180, 'W': 270 };
  const labelEls = document.querySelectorAll('.compass-label');
  labelEls.forEach(el => {
    const card = el.textContent;
    if (labels[card] !== undefined) {
      const angleDeg = labels[card] - yawDeg;
      const angleRad = (angleDeg - 90) * Math.PI / 180;
      const r = 33;
      const x = 36 + r * Math.cos(angleRad);
      const y = 36 + r * Math.sin(angleRad);
      el.setAttribute('x', x);
      el.setAttribute('y', y);
    }
  });

  // FOV wedge
  const fov = cam.fov || 60;
  const halfFov = fov / 2;
  const wedgeR = 20;
  const a1 = (-90 - halfFov) * Math.PI / 180;
  const a2 = (-90 + halfFov) * Math.PI / 180;
  const x1 = 36 + wedgeR * Math.cos(a1);
  const y1 = 36 + wedgeR * Math.sin(a1);
  const x2 = 36 + wedgeR * Math.cos(a2);
  const y2 = 36 + wedgeR * Math.sin(a2);
  _$compassFov.setAttribute('d', `M36,36 L${x1},${y1} A${wedgeR},${wedgeR} 0 0,1 ${x2},${y2} Z`);

  // --- Altitude bar (vertical) ---
  const minY = FLOOR_Y_CONST + 15;
  const maxY = 2500;
  const altPct = Math.max(0, Math.min(100, ((cam.position.y - minY) / (maxY - minY)) * 100));
  _$altFill.style.height = altPct + '%';
  _$altValue.textContent = Math.round(cam.position.y);

  // --- Key states ---
  _$keyQ.classList.toggle('active', _camKeys.q);
  _$keyW.classList.toggle('active', _camKeys.w);
  _$keyE.classList.toggle('active', _camKeys.e || _camKeys.space);
  _$keyA.classList.toggle('active', _camKeys.a);
  _$keyS.classList.toggle('active', _camKeys.s);
  _$keyD.classList.toggle('active', _camKeys.d);

  // --- Speed label ---
  const speed = _camVelocity.length();
  if (speed > 0.1) {
    if (_camKeys.shift) {
      _$camSpeed.innerHTML = `<span class="boost">BOOST</span> ${speed.toFixed(1)}`;
    } else {
      _$camSpeed.textContent = `MOVE ${speed.toFixed(1)}`;
    }
  } else {
    _$camSpeed.textContent = 'MOVE';
  }
}

function updateCameraMovement() {
  if (!graph) return;
  const cam = graph.camera();
  const controls = graph.controls();
  if (!cam || !controls) return;

  // Build desired movement direction from key states
  _camMoveDir.set(0, 0, 0);
  const anyKey = _camKeys.w || _camKeys.a || _camKeys.s || _camKeys.d || _camKeys.q || _camKeys.e || _camKeys.space;

  if (anyKey) {
    // Get camera forward/right projected onto XZ plane
    cam.getWorldDirection(_camForward);
    _camForward.y = 0;
    _camForward.normalize();
    _camRight.crossVectors(_camForward, cam.up).normalize();

    if (_camKeys.w) _camMoveDir.add(_camForward);
    if (_camKeys.s) _camMoveDir.sub(_camForward);
    if (_camKeys.d) _camMoveDir.add(_camRight);
    if (_camKeys.a) _camMoveDir.sub(_camRight);

    // Height: Q = down, E = up, Space = up
    if (_camKeys.e) _camMoveDir.y += 1;
    if (_camKeys.q) _camMoveDir.y -= 1;
    if (_camKeys.space) _camMoveDir.y += 1;

    if (_camMoveDir.lengthSq() > 0) _camMoveDir.normalize();

    const speed = CAM_BASE_SPEED * (_camKeys.shift ? CAM_BOOST_MULT : 1);

    // Scale speed by distance from target — move faster when zoomed out
    const distToTarget = cam.position.distanceTo(controls.target);
    const distScale = Math.max(0.5, Math.min(4.0, distToTarget / 300));

    _camMoveDir.multiplyScalar(speed * distScale);

    // Vertical speed is independent
    if (_camKeys.e || _camKeys.q || _camKeys.space) {
      const hSpeed = CAM_HEIGHT_SPEED * (_camKeys.shift ? CAM_BOOST_MULT : 1) * distScale;
      const hDir = (_camKeys.e || _camKeys.space ? 1 : 0) + (_camKeys.q ? -1 : 0);
      _camMoveDir.y = hDir * hSpeed;
    }

    _camMoving = true;
    showCamHud();
  } else {
    _camMoving = false;
  }

  // Smooth acceleration/deceleration
  const smoothing = anyKey ? CAM_ACCEL : CAM_DECEL;
  _camVelocity.lerp(_camMoveDir, smoothing);

  // Apply movement to both camera and orbit target
  if (_camVelocity.lengthSq() > 0.001) {
    cam.position.add(_camVelocity);
    controls.target.add(_camVelocity);

    // Enforce floor/ceiling constraints
    if (cam.position.y < FLOOR_Y_CONST + 15) {
      const diff = (FLOOR_Y_CONST + 15) - cam.position.y;
      cam.position.y = FLOOR_Y_CONST + 15;
      controls.target.y += diff;
    }
    if (cam.position.y > 2500) {
      const diff = 2500 - cam.position.y;
      cam.position.y = 2500;
      controls.target.y += diff;
    }

    showCamHud();
  } else {
    _camVelocity.set(0, 0, 0);
  }

  updateCamHud();
}

// ═══════════════════════════════════════════
// KEYBOARD SHORTCUTS
// ═══════════════════════════════════════════
document.addEventListener('keydown', (e) => {
  const inInput = document.activeElement?.tagName === 'INPUT' || document.activeElement?.tagName === 'TEXTAREA';

  // WASD + QE camera movement (only when not typing in inputs)
  if (!inInput) {
    const k = e.key.toLowerCase();
    if (k === 'w' || k === 'a' || k === 's' || k === 'd' || k === 'q' || k === 'e') {
      e.preventDefault();
      _camKeys[k] = true;
    }
    if (e.key === 'Shift') _camKeys.shift = true;
    if (k === ' ') { e.preventDefault(); _camKeys.space = true; }
  }

  if (e.key === 'Escape') {
    const catModal = document.querySelector('.cat-change-modal');
    const colorPicker = document.querySelector('.color-edit-picker');
    const descEditor = document.querySelector('.category-desc-editor');
    if (catModal) {
      catModal.closest('.tag-delete-overlay')?.remove();
    } else if (descEditor) {
      closeDescEditor();
    } else if (colorPicker) {
      closeColorPicker();
    } else if (document.getElementById('category-create-form')?.classList.contains('open')) {
      document.getElementById('category-create-form').classList.remove('open');
    } else if ($helpOverlay.classList.contains('open')) {
      closeHelp();
    } else if (layoutsPanelOpen) {
      closeLayoutsPanel();
    } else if ($searchInput.value) {
      $searchInput.value = '';
      clearSearch();
    } else if (_multiSelected.size > 0) {
      clearMultiSelect();
    } else if (selectedNodeId) {
      closeDetailPanel();
    }
  }

  // Toggle help with ?
  if (e.key === '?' && !inInput) {
    e.preventDefault();
    $helpOverlay.classList.contains('open') ? closeHelp() : openHelp();
  }

  // Focus search with /
  if (e.key === '/' && !inInput) {
    e.preventDefault();
    $searchInput.focus();
  }

  // Toggle 3D controls panel with C
  if ((e.key === 'c' || e.key === 'C') && !inInput && !e.ctrlKey && !e.metaKey) {
    document.getElementById('controls-toggle-btn').click();
  }
});

document.addEventListener('keyup', (e) => {
  const k = e.key.toLowerCase();
  if (k === 'w' || k === 'a' || k === 's' || k === 'd' || k === 'q' || k === 'e') {
    _camKeys[k] = false;
  }
  if (e.key === 'Shift') _camKeys.shift = false;
  if (k === ' ') _camKeys.space = false;
});

// Clear keys when window loses focus
window.addEventListener('blur', () => {
  _camKeys.w = _camKeys.a = _camKeys.s = _camKeys.d = _camKeys.q = _camKeys.e = _camKeys.shift = _camKeys.space = false;
});

// Detail panel close
document.getElementById('detail-close').addEventListener('click', () => {
  closeDetailPanel();
});

// Category sidebar toggle
{
  const catSidebar = document.getElementById('category-sidebar');
  const catToggleBtn = document.getElementById('toggle-categories-btn');
  const catCloseBtn = document.getElementById('sidebar-close');

  function setCategoriesVisible(show) {
    catSidebar.style.display = show ? '' : 'none';
    catToggleBtn.classList.toggle('active', show);
  }

  catToggleBtn.addEventListener('click', () => {
    const isVisible = catSidebar.style.display !== 'none';
    setCategoriesVisible(!isVisible);
  });

  catCloseBtn.addEventListener('click', () => {
    setCategoriesVisible(false);
  });
}

// 3D Controls panel toggle
{
  const $controlsPanel = document.getElementById('controls-panel');
  const $controlsBtn = document.getElementById('controls-toggle-btn');
  $controlsBtn.addEventListener('click', () => {
    const showing = $controlsPanel.classList.toggle('visible');
    $controlsBtn.classList.toggle('active', showing);
  });
}

// Multi-select action bar handlers
document.getElementById('multi-select-clear').addEventListener('click', () => {
  clearMultiSelect();
});

document.getElementById('multi-select-trash').addEventListener('click', async () => {
  for (const id of _multiSelected) {
    try {
      await fetch('/api/memory/' + encodeURIComponent(id), { method: 'DELETE' });
      allNodes = allNodes.filter(n => n.id !== id);
    } catch {}
  }
  clearMultiSelect();
  closeDetailPanel();
  const presentCats = new Set(allNodes.map(n => n.payload.category));
  buildCategorySidebar(presentCats);
  applyGraphData();
  updateStats();
  fetchTrashItems();
});

document.getElementById('multi-select-export').addEventListener('click', () => {
  for (const id of _multiSelected) {
    const node = allNodes.find(n => n.id === id);
    if (node) exportMemoryAsMarkdown(node);
  }
});

// Link mode: 'intra' (same-category only), 'all' (+ cross-category), 'off' (hidden)
let _linkMode = 'all';
let _crossCategoryLinks = [];  // Populated by applyGraphData
let linksVisible = true;
let noLinksScaleBoost = 1.0;
document.getElementById('toggle-links-btn').addEventListener('click', () => {
  if (!graph) return;
  const modes = ['off', 'intra', 'all'];
  const labels = { intra: 'Intra Links', all: 'All Links', off: 'Links Off' };
  const idx = modes.indexOf(_linkMode);
  _linkMode = modes[(idx + 1) % modes.length];

  if (_linkMode === 'off') {
    linksVisible = false;
    noLinksScaleBoost = 1.4;
  } else {
    linksVisible = true;
    noLinksScaleBoost = 1.0;
    applyGraphData();
  }
  applyLinkVisibility();
  document.getElementById('toggle-links-btn').textContent = labels[_linkMode];
});

// ── Link type filter ──
const LINK_TYPES = [
  { key: 'all',        label: 'Show: All Types' },
  { key: 'similarity', label: 'Show: Similar Content' },
  { key: 'files',      label: 'Show: Shared Files' },
  { key: 'tags',       label: 'Show: Shared Tags' },
  { key: 'family',     label: 'Show: Same Family' },
  { key: 'manual',     label: 'Show: Manually Linked' },
];
let _linkTypeFilter = 'all';

function applyLinkVisibility() {
  // Batch renderer handles all link visibility — just flag dirty
  _linkBatchDirty = true;
}

document.getElementById('link-type-btn').addEventListener('click', () => {
  if (!graph) return;
  const idx = LINK_TYPES.findIndex(t => t.key === _linkTypeFilter);
  _linkTypeFilter = LINK_TYPES[(idx + 1) % LINK_TYPES.length].key;
  const label = LINK_TYPES.find(t => t.key === _linkTypeFilter).label;
  document.getElementById('link-type-btn').textContent = label;
  applyLinkVisibility();
});

document.getElementById('reset-positions-btn').addEventListener('click', () => {
  if (!graph) return;

  // Check if there's any layout state worth saving (pinned nodes or active preset)
  const nodes = graph.graphData().nodes;
  const pinnedCount = nodes.filter(n => n.fx !== undefined && n.fx !== null).length;
  const hasSavedPositions = !!localStorage.getItem(_posStorageKey);
  const hasState = pinnedCount > 0 || hasSavedPositions || activePresetId;

  if (!hasState) {
    // Nothing to lose — reset immediately
    try { localStorage.removeItem(_posStorageKey); } catch (_) {}
    applyGraphData();
    activePresetId = null;
    renderPresetList();
    return;
  }

  // Show confirmation dialog
  const overlay = document.createElement('div');
  overlay.className = 'tag-delete-overlay';
  overlay.innerHTML = `
    <div class="tag-delete-modal" style="min-width:340px;max-width:420px;text-align:left">
      <div class="tag-delete-modal-title" style="text-align:center">Reset Layout</div>
      <div style="color:var(--t-muted);font-size:var(--fs-sm);margin:8px 0 16px;text-align:center;line-height:1.5">
        This will unpin all nodes and recompute positions from scratch.<br>
        Any unsaved layout changes will be lost.
      </div>
      <div class="reset-modal-save-row" style="display:flex;gap:8px;margin-bottom:16px">
        <input type="text" class="reset-modal-name" placeholder="Layout name…"
          style="flex:1;background:#111114;border:1px solid var(--b-light);border-radius:var(--r-button);padding:7px 12px;color:var(--t-bright);font-size:var(--fs-sm);font-family:inherit;outline:none">
        <button class="action-btn action-btn--primary reset-modal-save" style="white-space:nowrap;padding:7px 16px">Save &amp; Reset</button>
      </div>
      <div class="tag-delete-modal-actions" style="justify-content:center">
        <button class="action-btn action-btn--ghost reset-modal-cancel">Cancel</button>
        <button class="action-btn action-btn--danger reset-modal-reset">Reset Without Saving</button>
      </div>
    </div>
  `;
  document.body.appendChild(overlay);

  const nameInput = overlay.querySelector('.reset-modal-name');
  const doReset = () => {
    overlay.remove();
    try { localStorage.removeItem(_posStorageKey); } catch (_) {}
    applyGraphData();
    activePresetId = null;
    renderPresetList();
  };

  // Cancel
  overlay.querySelector('.reset-modal-cancel').addEventListener('click', () => overlay.remove());
  overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });

  // Reset without saving
  overlay.querySelector('.reset-modal-reset').addEventListener('click', doReset);

  // Save & Reset
  overlay.querySelector('.reset-modal-save').addEventListener('click', () => {
    const name = nameInput.value.trim() || ('Layout ' + new Date().toLocaleString('en-US', { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' }));
    saveCurrentLayout(name);
    doReset();
  });

  // Enter in name input triggers Save & Reset
  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      overlay.querySelector('.reset-modal-save').click();
    }
    if (e.key === 'Escape') {
      overlay.remove();
    }
  });

  // Auto-focus the name input
  requestAnimationFrame(() => nameInput.focus());
});

// ═══════════════════════════════════════════
// WINDOW RESIZE
// ═══════════════════════════════════════════
function clampPanelsToViewport() {
  // Clamp all positioned panels within viewport bounds
  document.querySelectorAll('.resizable').forEach(el => {
    const minVisible = 60; // Minimum pixels that must remain visible horizontally
    const minHeight = 100; // Minimum height
    const minWidth = 140; // Minimum width

    // Get current dimensions
    let rect = el.getBoundingClientRect();

    // Clamp left position - keep panel fully visible horizontally
    if (el.style.left) {
      const currentLeft = parseInt(el.style.left);
      const maxLeft = Math.max(0, window.innerWidth - rect.width - 10);
      if (currentLeft > maxLeft) {
        el.style.left = maxLeft + 'px';
      }
    }

    // Clamp top position - keep panel fully visible vertically
    if (el.style.top) {
      const currentTop = parseInt(el.style.top);
      const maxTop = Math.max(0, window.innerHeight - rect.height - 10);
      if (currentTop > maxTop) {
        el.style.top = maxTop + 'px';
      }
    }

    // Get updated rect after position clamping
    rect = el.getBoundingClientRect();

    // Clamp width if panel extends beyond viewport
    if (rect.right > window.innerWidth && el.style.width) {
      const maxWidth = window.innerWidth - rect.left - 10;
      if (maxWidth > minWidth) {
        el.style.width = maxWidth + 'px';
      }
    }

    // Clamp height if panel extends beyond viewport
    rect = el.getBoundingClientRect(); // Get rect again after width adjustment
    if (rect.bottom > window.innerHeight) {
      const maxHeight = window.innerHeight - rect.top - 10; // 10px margin from bottom
      if (maxHeight > minHeight) {
        // Always enforce max-height constraint
        el.style.maxHeight = maxHeight + 'px';
        // If panel has explicit height that exceeds max, clamp it
        if (el.style.height && el.style.height !== 'auto') {
          const currentHeight = parseInt(el.style.height);
          if (currentHeight > maxHeight) {
            el.style.height = maxHeight + 'px';
          }
        }
      }
    }
  });
}

window.addEventListener('resize', () => {
  if (graph) {
    graph.width(window.innerWidth);
    graph.height(window.innerHeight);
  }
  // Clamp panels to stay within viewport
  clampPanelsToViewport();
});

// ═══════════════════════════════════════════
// PANEL DRAG + RESIZE
// ═══════════════════════════════════════════
{
  const sidebar = document.getElementById('category-sidebar');
  const detail = document.getElementById('detail-panel');
  let resizing = null;
  let dragging = null;
  const MIN_W = 140;
  const MIN_H = 100;

  // RAF state for smooth 60fps updates
  let rafPending = false;
  let latestMouseX = 0;
  let latestMouseY = 0;

  // Helper: get the UI scale factor for an element
  function getElScale(el) {
    return parseFloat(getComputedStyle(el).getPropertyValue('--ui-scale')) || parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--ui-scale')) || 1;
  }

  // Helper: ensure panel uses left/top positioning (not right)
  // Uses getComputedStyle for CSS coordinates — immune to transform: scale()
  function ensureLeftTop(el) {
    const cs = getComputedStyle(el);
    el.style.left = cs.left;
    el.style.top = cs.top;
    el.style.right = 'auto';
  }

  // --- Resize (all 8 directions, any panel — event delegation for dynamic panels) ---
  document.addEventListener('mousedown', (e) => {
    const handle = e.target.closest('.resize-handle');
    if (!handle) return;
    e.preventDefault();
    const dir = handle.dataset.resize;
    const el = handle.closest('.resizable');
    if (!el) return;

    handle.classList.add('active');
    el.classList.add('dragging');   // Suppress transitions before any position changes

    const s = getElScale(el);
    ensureLeftTop(el);
    const cs = getComputedStyle(el);

    // Respect per-element CSS min-width/min-height
    const elMinW = Math.max(MIN_W, parseInt(cs.minWidth) || 0);
    const elMinH = Math.max(MIN_H, parseInt(cs.minHeight) || 0);

    resizing = {
      el, dir, scale: s,
      startX: e.clientX, startY: e.clientY,
      startW: parseFloat(cs.width), startH: parseFloat(cs.height),  // CSS dimensions
      startL: parseFloat(cs.left), startT: parseFloat(cs.top),      // CSS positions
      minW: elMinW, minH: elMinH,
    };
    document.body.style.cursor = getComputedStyle(handle).cursor;
    document.body.style.userSelect = 'none';
  });

  // --- Drag (event delegation for dynamic panels) ---
  document.addEventListener('mousedown', (e) => {
    const handle = e.target.closest('.drag-handle');
    if (!handle) return;
    // Skip if clicking a resize handle (they're siblings, not children, but be safe)
    if (e.target.closest('.resize-handle')) return;
    // Skip drag if clicking on a button, input, or interactive element
    const tag = e.target.closest('button, input, select, textarea, a, [contenteditable]');
    if (tag) return;
    e.preventDefault();
    const el = document.getElementById(handle.dataset.drag);
    if (!el) return;
    // Skip drag if panel is locked/pinned
    if (el.classList.contains('locked')) return;

    el.classList.add('dragging');   // Suppress transitions before any position changes
    ensureLeftTop(el);
    const s = getElScale(el);
    const cs = getComputedStyle(el);
    const rect = el.getBoundingClientRect();

    dragging = {
      el, startX: e.clientX, startY: e.clientY,
      startLeft: parseFloat(cs.left), startTop: parseFloat(cs.top),   // CSS positions
      startVisualLeft: rect.left, startVisualTop: rect.top,           // Visual positions for clamping
      startW: rect.width, startH: rect.height,                       // Visual size for clamping
    };
    document.body.style.cursor = 'grabbing';
    document.body.style.userSelect = 'none';
  });

  // RAF tick — all geometry math + DOM writes happen here (once per frame)
  function applyInteraction() {
    rafPending = false;
    const mx = latestMouseX;
    const my = latestMouseY;

    // Resize
    if (resizing) {
      const { el, dir, scale: rScale, startX, startY, startW, startH, startL, startT, minW: rMinW, minH: rMinH } = resizing;
      const dx = (mx - startX) / rScale;
      const dy = (my - startY) / rScale;

      let newW = startW, newH = startH, newL = startL, newT = startT;

      if (dir === 'r' || dir === 'br' || dir === 'tr') newW = Math.max(rMinW, startW + dx);
      if (dir === 'l' || dir === 'bl' || dir === 'tl') { newW = Math.max(rMinW, startW - dx); newL = startL + startW - newW; }
      if (dir === 'b' || dir === 'br' || dir === 'bl') newH = Math.max(rMinH, startH + dy);
      if (dir === 't' || dir === 'tr' || dir === 'tl') { newH = Math.max(rMinH, startH - dy); newT = startT + startH - newH; }

      newL = Math.max(0, newL);
      newT = Math.max(0, newT);
      const maxWidth = window.innerWidth / rScale - newL - 10;
      const maxHeight = window.innerHeight / rScale - newT - 10;
      newW = Math.min(newW, maxWidth);
      newH = Math.min(newH, maxHeight);

      el.style.width = newW + 'px';
      el.style.height = newH + 'px';
      el.style.left = newL + 'px';
      el.style.top = newT + 'px';
      el.style.maxHeight = maxHeight + 'px';
    }

    // Drag — CSS position delta = visual position delta (no scale division needed)
    if (dragging) {
      const { el, startX, startY, startLeft, startTop, startVisualLeft, startVisualTop, startW, startH } = dragging;
      const dx = mx - startX;
      const dy = my - startY;

      // Clamp so visual bounding box stays within viewport
      const clampedDx = Math.max(-startVisualLeft, Math.min(window.innerWidth - startW - 10 - startVisualLeft, dx));
      const clampedDy = Math.max(-startVisualTop, Math.min(window.innerHeight - startH - 10 - startVisualTop, dy));

      el.style.left = (startLeft + clampedDx) + 'px';
      el.style.top = (startTop + clampedDy) + 'px';
    }
  }

  document.addEventListener('mousemove', (e) => {
    if (!resizing && !dragging) return;
    latestMouseX = e.clientX;
    latestMouseY = e.clientY;
    if (!rafPending) {
      rafPending = true;
      requestAnimationFrame(applyInteraction);
    }
  });

  // Save panel layout to localStorage
  function savePanelLayout(el) {
    const id = el.id;
    const rect = el.getBoundingClientRect();
    const data = {
      left: el.style.left || null,
      top: el.style.top || null,
      right: el.style.right || null,
      width: el.style.width || null,
      height: el.style.height || null,
      maxHeight: el.style.maxHeight || null,
    };
    localStorage.setItem('neural-panel-' + id, JSON.stringify(data));
  }

  document.addEventListener('mouseup', () => {
    rafPending = false; // Discard any pending RAF
    if (resizing) {
      document.querySelectorAll('.resize-handle.active').forEach(h => h.classList.remove('active'));
      resizing.el.classList.remove('dragging');
      savePanelLayout(resizing.el);
      resizing = null;
    }
    if (dragging) {
      dragging.el.classList.remove('dragging');
      savePanelLayout(dragging.el);
      dragging = null;
    }
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  });

  // Restore saved layouts on load
  function restorePanelLayout(el, sizeOnly) {
    const saved = localStorage.getItem('neural-panel-' + el.id);
    if (!saved) return;
    try {
      const data = JSON.parse(saved);
      // Position — only restore if not sizeOnly
      if (!sizeOnly) {
        if (data.left && data.left !== 'auto') el.style.left = data.left;
        if (data.top) el.style.top = data.top;
        if (data.right) el.style.right = data.right;
      }
      // Size — always restore
      if (data.width) el.style.width = data.width;
      if (data.height) el.style.height = data.height;
      // Don't set maxHeight='none' - let viewport clamping handle it
    } catch {}
  }

  restorePanelLayout(sidebar, false);
  // Detail panel: only restore size now, restore position when it opens
  restorePanelLayout(detail, true);

  // Clamp restored panels to current viewport
  clampPanelsToViewport();
}

// ═══════════════════════════════════════════
// PER-PANEL PIN TOGGLE
// ═══════════════════════════════════════════
document.querySelectorAll('.pin-btn').forEach(btn => {
  const panelId = btn.dataset.pin;
  const panel = document.getElementById(panelId);
  const key = 'neural-pinned-' + panelId;

  // Restore saved state
  if (localStorage.getItem(key) === 'true') {
    panel.classList.add('locked');
    btn.classList.add('pinned');
  }

  btn.addEventListener('click', (e) => {
    e.stopPropagation();
    const pinned = panel.classList.toggle('locked');
    btn.classList.toggle('pinned', pinned);
    localStorage.setItem(key, pinned);
  });
});

// ═══════════════════════════════════════════
// BOOKMARKS
// ═══════════════════════════════════════════
const $bookmarksBtn = document.getElementById('bookmarks-btn');
const $bookmarksPanel = document.getElementById('bookmarks-panel');
const $bookmarksList = document.getElementById('bookmarks-list');
const $bookmarkCount = document.getElementById('bookmark-count');
let bookmarksPanelOpen = false;

function getBookmarks() {
  try { return JSON.parse(localStorage.getItem('neural-bookmarks') || '[]'); }
  catch { return []; }
}

function saveBookmarks(arr) {
  localStorage.setItem('neural-bookmarks', JSON.stringify(arr));
  updateBookmarkCount();
}

function isBookmarked(nodeId) {
  return getBookmarks().some(b => b.id === nodeId);
}

function toggleBookmark(node) {
  const bookmarks = getBookmarks();
  const idx = bookmarks.findIndex(b => b.id === node.id);
  if (idx !== -1) {
    bookmarks.splice(idx, 1);
  } else {
    const p = node.payload || {};
    const preview = (p.content || '').replace(/\n/g, ' ').slice(0, 80);
    bookmarks.unshift({
      id: node.id,
      title: preview || node.id,
      category: p.category || 'unknown',
      added: Date.now(),
    });
  }
  saveBookmarks(bookmarks);
  return isBookmarked(node.id);
}

function updateBookmarkCount() {
  const count = getBookmarks().length;
  $bookmarkCount.textContent = count > 0 ? count : '';
}

function updateDetailBookmarkBtn(nodeId) {
  const btn = document.getElementById('detail-bookmark-btn');
  const svg = btn.querySelector('svg');
  if (isBookmarked(nodeId)) {
    btn.classList.add('active');
    svg.classList.add('filled');
  } else {
    btn.classList.remove('active');
    svg.classList.remove('filled');
  }
}

function renderBookmarksList() {
  const bookmarks = getBookmarks();
  $bookmarksList.innerHTML = '';
  if (bookmarks.length === 0) {
    $bookmarksList.innerHTML = '<div class="dropdown-empty">No bookmarks yet.<br>Click the bookmark icon on any memory to save it here.</div>';
    return;
  }
  bookmarks.forEach(b => {
    const item = document.createElement('div');
    item.className = 'dropdown-item';
    const color = catColor(b.category);
    item.innerHTML = `
      <div class="dropdown-item-dot" style="background:${color}"></div>
      <div class="dropdown-item-text">
        <div class="dropdown-item-title">${b.title}</div>
        <div class="dropdown-item-sub">${b.category}</div>
      </div>
      <button class="icon-btn icon-btn--danger" style="width:22px;height:22px;font-size:13px;border:none" data-tooltip="Remove">&times;</button>
    `;
    // Click item → navigate to node
    const navToBookmark = () => {
      const node = allNodes.find(n => n.id === b.id);
      if (node) {
        closeBookmarksPanel();
        navigateToNode(node, { zoom: 'gentle' });
      }
    };
    item.querySelector('.dropdown-item-text').addEventListener('click', navToBookmark);
    item.querySelector('.dropdown-item-dot').addEventListener('click', navToBookmark);
    // Remove button
    item.querySelector('.icon-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      const bks = getBookmarks().filter(x => x.id !== b.id);
      saveBookmarks(bks);
      renderBookmarksList();
      if (selectedNodeId === b.id) updateDetailBookmarkBtn(b.id);
    });
    $bookmarksList.appendChild(item);
  });
}

function openBookmarksPanel() {
  bookmarksPanelOpen = true;
  $bookmarksPanel.classList.add('open');
  $bookmarksBtn.classList.add('active');
  renderBookmarksList();
}

function closeBookmarksPanel() {
  bookmarksPanelOpen = false;
  $bookmarksPanel.classList.remove('open');
  $bookmarksBtn.classList.remove('active');
}

$bookmarksBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  if (typeof closeLayoutsPanel === 'function' && layoutsPanelOpen) closeLayoutsPanel();
  if (typeof closeTrashPanel === 'function' && trashPanelOpen) closeTrashPanel();
  if (bookmarksPanelOpen) closeBookmarksPanel();
  else openBookmarksPanel();
});

$bookmarksPanel.addEventListener('click', (e) => e.stopPropagation());

document.addEventListener('click', () => {
  if (bookmarksPanelOpen) closeBookmarksPanel();
});

// Detail panel bookmark toggle
document.getElementById('detail-bookmark-btn').addEventListener('click', () => {
  const node = allNodes.find(n => n.id === selectedNodeId);
  if (!node) return;
  toggleBookmark(node);
  updateDetailBookmarkBtn(node.id);
});

updateBookmarkCount();

// ═══════════════════════════════════════════
// LAYOUT PRESETS
// ═══════════════════════════════════════════
const $layoutsBtn = document.getElementById('layouts-btn');
const $layoutsPanel = document.getElementById('layouts-panel');
const $presetNameInput = document.getElementById('preset-name-input');
const $presetSaveBtn = document.getElementById('preset-save-btn');
const $presetList = document.getElementById('preset-list');
const $presetWarning = document.getElementById('preset-warning');
let layoutsPanelOpen = false;
let activePresetId = null;

function getPresets() {
  try {
    return JSON.parse(localStorage.getItem('neural-layout-presets') || '[]');
  } catch { return []; }
}

function savePresets(arr) {
  localStorage.setItem('neural-layout-presets', JSON.stringify(arr));
}

// ── Built-in presets (cannot be deleted) ──

function generateCategoryCluster() {
  if (!graph) return null;
  const nodes = graph.graphData().nodes;
  if (nodes.length === 0) return null;

  const groups = {};
  nodes.forEach(n => {
    const cat = n.payload.category || 'unknown';
    if (!groups[cat]) groups[cat] = [];
    groups[cat].push(n);
  });

  const catNames = Object.keys(groups);
  const catCount = catNames.length;

  // Large separation radius so clusters are visually distinct
  const maxMembers = Math.max(...catNames.map(c => groups[c].length));
  const clusterSpread = Math.max(40, Math.sqrt(maxMembers) * 22);
  const RADIUS = Math.max(300, catCount * 55, clusterSpread * 3.5);

  const positions = {};
  const goldenAngle = Math.PI * (3 - Math.sqrt(5));

  catNames.forEach((cat, i) => {
    // Fibonacci sphere distribution for category centers
    const phi = Math.acos(1 - 2 * (i + 0.5) / catCount);
    const theta = goldenAngle * i;
    const cx = RADIUS * Math.sin(phi) * Math.cos(theta);
    const cy = RADIUS * Math.cos(phi);
    const cz = RADIUS * Math.sin(phi) * Math.sin(theta);

    const members = groups[cat];
    const spread = Math.max(30, Math.sqrt(members.length) * 22);

    members.forEach((node, j) => {
      // Fibonacci sphere for each node within the cluster
      const subPhi = Math.acos(1 - 2 * (j + 0.5) / members.length);
      const subTheta = goldenAngle * j;
      // Layer radius: nodes towards center are closer, outer ones further
      const layer = Math.cbrt((j + 1) / members.length);
      const r = spread * layer;

      positions[node.id] = {
        x: cx + r * Math.sin(subPhi) * Math.cos(subTheta),
        y: cy + r * Math.cos(subPhi),
        z: cz + r * Math.sin(subPhi) * Math.sin(subTheta),
      };
    });
  });

  return positions;
}

function generateCategoryHelix() {
  if (!graph) return null;
  const nodes = graph.graphData().nodes;
  if (nodes.length === 0) return null;

  const groups = {};
  nodes.forEach(n => {
    const cat = n.payload.category || 'unknown';
    if (!groups[cat]) groups[cat] = [];
    groups[cat].push(n);
  });

  const catNames = Object.keys(groups);
  const catCount = catNames.length;
  const HELIX_RADIUS = Math.max(150, catCount * 25);
  const HELIX_HEIGHT = Math.max(300, catCount * 60);
  const positions = {};
  const goldenAngle = Math.PI * (3 - Math.sqrt(5));

  catNames.forEach((cat, i) => {
    // Each category sits at a point along a double helix
    const t = i / Math.max(catCount - 1, 1); // 0..1
    const angle = i * goldenAngle * 3;
    const cx = HELIX_RADIUS * Math.cos(angle);
    const cy = (t - 0.5) * HELIX_HEIGHT;
    const cz = HELIX_RADIUS * Math.sin(angle);

    const members = groups[cat];
    const spread = Math.max(20, Math.sqrt(members.length) * 14);

    // Scatter members in a 3D sphere around the helix point
    members.forEach((node, j) => {
      const phi = Math.acos(1 - 2 * (j + 0.5) / members.length);
      const theta = goldenAngle * j;
      const r = spread * (0.4 + 0.6 * Math.cbrt((j + 1) / members.length));
      positions[node.id] = {
        x: cx + r * Math.sin(phi) * Math.cos(theta),
        y: cy + r * Math.cos(phi),
        z: cz + r * Math.sin(phi) * Math.sin(theta),
      };
    });
  });

  return positions;
}

function generateCategoryOrbits() {
  if (!graph) return null;
  const nodes = graph.graphData().nodes;
  if (nodes.length === 0) return null;

  const groups = {};
  nodes.forEach(n => {
    const cat = n.payload.category || 'unknown';
    if (!groups[cat]) groups[cat] = [];
    groups[cat].push(n);
  });

  const catNames = Object.keys(groups);
  const catCount = catNames.length;
  const positions = {};

  // Each category gets its own tilted orbital ring at a different radius
  catNames.forEach((cat, i) => {
    const members = groups[cat];
    const orbitRadius = 100 + i * 45;
    // Tilt each orbital plane differently in 3D
    const tiltX = (i * 0.618) * Math.PI * 0.6; // golden ratio tilt
    const tiltZ = (i * 0.382) * Math.PI * 0.4;

    members.forEach((node, j) => {
      const angle = (j / members.length) * Math.PI * 2;
      // Position on a flat ring first
      let px = orbitRadius * Math.cos(angle);
      let py = 0;
      let pz = orbitRadius * Math.sin(angle);

      // Add slight radial scatter
      const scatter = 15 + Math.sqrt(members.length) * 3;
      px += (Math.sin(j * 7.3) * scatter * 0.5);
      py += (Math.cos(j * 4.1) * scatter * 0.5);
      pz += (Math.sin(j * 5.7) * scatter * 0.5);

      // Rotate around X axis (tilt)
      const y1 = py * Math.cos(tiltX) - pz * Math.sin(tiltX);
      const z1 = py * Math.sin(tiltX) + pz * Math.cos(tiltX);
      // Rotate around Z axis (second tilt)
      const x2 = px * Math.cos(tiltZ) - y1 * Math.sin(tiltZ);
      const y2 = px * Math.sin(tiltZ) + y1 * Math.cos(tiltZ);

      positions[node.id] = { x: x2, y: y2, z: z1 };
    });
  });

  return positions;
}

function generateCategoryTower() {
  if (!graph) return null;
  const nodes = graph.graphData().nodes;
  if (nodes.length === 0) return null;

  const groups = {};
  nodes.forEach(n => {
    const cat = n.payload.category || 'unknown';
    if (!groups[cat]) groups[cat] = [];
    groups[cat].push(n);
  });

  const catNames = Object.keys(groups);
  const catCount = catNames.length;
  const FLOOR_HEIGHT = 80;
  const positions = {};

  // Stack categories as floors, each floor a different shape
  catNames.forEach((cat, i) => {
    const members = groups[cat];
    const cy = (i - (catCount - 1) / 2) * FLOOR_HEIGHT;
    const floorRadius = Math.max(40, Math.sqrt(members.length) * 20);
    // Alternate rotation per floor for visual interest
    const rotOffset = i * Math.PI * 0.3;

    members.forEach((node, j) => {
      // Arrange in a 3D disc: concentric rings with slight vertical scatter
      const ring = Math.floor(Math.sqrt(j));
      const ringIdx = j - ring * ring;
      const ringSize = 2 * ring + 1;
      const angle = rotOffset + (ringIdx / ringSize) * Math.PI * 2;
      const r = (ring + 1) * (floorRadius / (Math.sqrt(members.length) + 1));
      const yJitter = (Math.sin(j * 3.7) * FLOOR_HEIGHT * 0.15);

      positions[node.id] = {
        x: r * Math.cos(angle),
        y: cy + yJitter,
        z: r * Math.sin(angle),
      };
    });
  });

  return positions;
}

function generateCategoryDNA() {
  if (!graph) return null;
  const nodes = graph.graphData().nodes;
  if (nodes.length === 0) return null;

  const groups = {};
  nodes.forEach(n => {
    const cat = n.payload.category || 'unknown';
    if (!groups[cat]) groups[cat] = [];
    groups[cat].push(n);
  });

  const catNames = Object.keys(groups);
  const catCount = catNames.length;
  const STRAND_RADIUS = Math.max(100, catCount * 18);
  const TOTAL_HEIGHT = Math.max(400, catCount * 70);
  const positions = {};

  // Two interleaved helical strands, categories alternate between them
  catNames.forEach((cat, i) => {
    const members = groups[cat];
    const strand = i % 2; // which helix strand
    const step = Math.floor(i / 2);
    const t = step / Math.max(Math.ceil(catCount / 2) - 1, 1);
    const angle = t * Math.PI * 4 + strand * Math.PI; // 2 full turns, offset by PI

    const cx = STRAND_RADIUS * Math.cos(angle);
    const cy = (t - 0.5) * TOTAL_HEIGHT;
    const cz = STRAND_RADIUS * Math.sin(angle);

    const spread = Math.max(18, Math.sqrt(members.length) * 12);
    const goldenAngle = Math.PI * (3 - Math.sqrt(5));

    members.forEach((node, j) => {
      const phi = Math.acos(1 - 2 * (j + 0.5) / members.length);
      const theta = goldenAngle * j;
      const r = spread * Math.cbrt((j + 1) / members.length);
      positions[node.id] = {
        x: cx + r * Math.sin(phi) * Math.cos(theta),
        y: cy + r * Math.cos(phi),
        z: cz + r * Math.sin(phi) * Math.sin(theta),
      };
    });
  });

  return positions;
}

const BUILTIN_PRESETS = [
  { id: '__clusters', name: 'Category Clusters', desc: '3D sphere with category clusters', generate: generateCategoryCluster },
  { id: '__helix', name: 'Category Helix', desc: '3D helix spiral by category', generate: generateCategoryHelix },
  { id: '__orbits', name: 'Category Orbits', desc: 'Tilted orbital rings per category', generate: generateCategoryOrbits },
  { id: '__tower', name: 'Category Tower', desc: 'Stacked floors by category', generate: generateCategoryTower },
  { id: '__dna', name: 'Category DNA', desc: 'Double helix with interleaved categories', generate: generateCategoryDNA },
];

function loadBuiltinPreset(builtin) {
  if (!graph) return;
  const positions = builtin.generate();
  if (!positions) return;

  const nodes = graph.graphData().nodes;
  nodes.forEach(node => {
    const saved = positions[node.id];
    if (saved) {
      node.x = saved.x; node.y = saved.y; node.z = saved.z;
      node.fx = saved.x; node.fy = saved.y; node.fz = saved.z;
    }
    // Keep existing pin for nodes not in this preset
  });

  // Zoom camera out based on actual extent of positions
  let maxDist = 0;
  for (const p of Object.values(positions)) {
    const d = Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z);
    if (d > maxDist) maxDist = d;
  }
  const camDist = Math.max(400, maxDist * 2.2);
  graph.cameraPosition({ x: camDist * 0.7, y: camDist * 0.5, z: camDist * 0.7 }, { x: 0, y: 0, z: 0 }, 2000);

  activePresetId = builtin.id;
  renderPresetList();
}

// ── User presets ──

function saveCurrentLayout(name) {
  if (!graph) return;
  const nodes = graph.graphData().nodes;
  const positions = {};
  let pinnedCount = 0;

  nodes.forEach(node => {
    if (node.fx !== undefined && node.fx !== null) {
      positions[node.id] = { x: node.fx, y: node.fy, z: node.fz };
      pinnedCount++;
    }
  });

  if (pinnedCount === 0) {
    $presetWarning.classList.add('visible');
    setTimeout(() => $presetWarning.classList.remove('visible'), 2500);
    return;
  }

  const cam = graph.camera();
  const controls = graph.controls();
  const camera = {
    position: { x: cam.position.x, y: cam.position.y, z: cam.position.z },
    lookAt: controls.target ? { x: controls.target.x, y: controls.target.y, z: controls.target.z } : { x: 0, y: 0, z: 0 }
  };

  const preset = {
    id: String(Date.now()),
    name: name.trim(),
    created: new Date().toISOString(),
    positions,
    camera
  };

  const presets = getPresets();
  presets.unshift(preset);
  savePresets(presets);
  activePresetId = preset.id;

  $presetNameInput.value = '';
  $presetWarning.classList.remove('visible');
  renderPresetList();
}

function loadPreset(preset) {
  if (!graph) return;
  const nodes = graph.graphData().nodes;

  nodes.forEach(node => {
    const saved = preset.positions[node.id];
    if (saved) {
      node.x = saved.x; node.y = saved.y; node.z = saved.z;
      node.fx = saved.x; node.fy = saved.y; node.fz = saved.z;
    }
    // Keep existing pin for nodes not in this preset
  });

  if (preset.camera) {
    graph.cameraPosition(
      preset.camera.position,
      preset.camera.lookAt,
      2000
    );
  }

  activePresetId = preset.id;
  renderPresetList();
}

function deletePreset(id) {
  const presets = getPresets().filter(p => p.id !== id);
  savePresets(presets);
  if (activePresetId === id) activePresetId = null;
  renderPresetList();
}

function renderPresetList() {
  const presets = getPresets();
  $presetList.innerHTML = '';

  // Built-in presets first
  BUILTIN_PRESETS.forEach(bp => {
    const row = document.createElement('div');
    row.className = 'preset-row builtin' + (bp.id === activePresetId ? ' active' : '');
    row.innerHTML = `
      <span class="preset-name">${bp.name}</span>
      <span class="preset-badge">auto</span>
    `;
    row.title = bp.desc;
    row.addEventListener('click', () => loadBuiltinPreset(bp));
    $presetList.appendChild(row);
  });

  // Divider if user presets exist
  if (presets.length > 0) {
    const div = document.createElement('div');
    div.className = 'preset-divider';
    $presetList.appendChild(div);
  }

  // User presets
  presets.forEach(preset => {
    const nodeCount = Object.keys(preset.positions).length;
    const date = new Date(preset.created);
    const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

    const row = document.createElement('div');
    row.className = 'preset-row' + (preset.id === activePresetId ? ' active' : '');

    row.innerHTML = `
      <span class="preset-name">${preset.name}</span>
      <span class="preset-badge">${nodeCount}</span>
      <span class="preset-date">${dateStr}</span>
      <button class="preset-delete" data-tooltip="Delete">&times;</button>
    `;

    row.addEventListener('click', (e) => {
      if (e.target.classList.contains('preset-delete')) return;
      loadPreset(preset);
    });

    row.querySelector('.preset-delete').addEventListener('click', (e) => {
      e.stopPropagation();
      deletePreset(preset.id);
    });

    $presetList.appendChild(row);
  });

  if (presets.length === 0 && BUILTIN_PRESETS.length === 0) {
    $presetList.innerHTML = '<div class="preset-empty">No saved layouts</div>';
  }
}

function openLayoutsPanel() {
  layoutsPanelOpen = true;
  $layoutsPanel.classList.add('open');
  $layoutsBtn.classList.add('active');
  renderPresetList();
}

function closeLayoutsPanel() {
  layoutsPanelOpen = false;
  $layoutsPanel.classList.remove('open');
  $layoutsBtn.classList.remove('active');
  $presetWarning.classList.remove('visible');
}

// Toggle panel
$layoutsBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  if (bookmarksPanelOpen) closeBookmarksPanel();
  if (trashPanelOpen) closeTrashPanel();
  if (layoutsPanelOpen) closeLayoutsPanel();
  else openLayoutsPanel();
});

// Prevent panel clicks from closing it
$layoutsPanel.addEventListener('click', (e) => e.stopPropagation());

// Close on background click
document.addEventListener('click', () => {
  if (layoutsPanelOpen) closeLayoutsPanel();
});

// Save on Enter or button click
$presetNameInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    const name = $presetNameInput.value.trim();
    if (name) saveCurrentLayout(name);
  }
});

$presetSaveBtn.addEventListener('click', () => {
  const name = $presetNameInput.value.trim();
  if (name) saveCurrentLayout(name);
});

// ═══════════════════════════════════════════
// HELP MODAL
// ═══════════════════════════════════════════
const $helpOverlay = document.getElementById('help-overlay');
const $helpBtn = document.getElementById('help-btn');

function openHelp() { $helpOverlay.classList.add('open'); }
function closeHelp() { $helpOverlay.classList.remove('open'); }

$helpBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  $helpOverlay.classList.contains('open') ? closeHelp() : openHelp();
});

document.getElementById('help-close').addEventListener('click', closeHelp);

$helpOverlay.addEventListener('click', (e) => {
  if (e.target === $helpOverlay) closeHelp();
});

// ═══════════════════════════════════════════
// TRASH PANEL
// ═══════════════════════════════════════════
const $trashBtn = document.getElementById('titlebar-trash-btn');
const $trashCount = document.getElementById('titlebar-trash-count');
let trashPanelOpen = false;
let trashItems = [];
let trashSelectedId = null;

async function fetchTrashItems() {
  try {
    const res = await fetch('/api/trash');
    if (!res.ok) return;
    const data = await res.json();
    trashItems = data.items;
    updateTrashBadge();
    if (trashPanelOpen) renderTrashWindow();
  } catch (err) {
    console.error('fetchTrash error:', err);
  }
}

function updateTrashBadge() {
  $trashCount.textContent = trashItems.length > 0 ? trashItems.length : '';
}

function formatTrashAge(isoDate) {
  const diffMs = Date.now() - new Date(isoDate).getTime();
  const mins = Math.floor(diffMs / 60000);
  if (mins < 1) return 'just now';
  if (mins < 60) return `${mins}m ago`;
  const hours = Math.floor(mins / 60);
  if (hours < 24) return `${hours}h ago`;
  const days = Math.floor(hours / 24);
  if (days === 1) return '1 day ago';
  if (days < 30) return `${days} days ago`;
  const months = Math.floor(days / 30);
  return months === 1 ? '1 month ago' : `${months} months ago`;
}

// ── Trash window (floating panel) ──

function openTrashPanel() {
  const existing = document.getElementById('trash-window');
  if (existing) { existing.style.zIndex = '301'; return; }

  trashPanelOpen = true;
  trashSelectedId = null;

  const win = document.createElement('div');
  win.className = 'trash-window glass resizable';
  win.id = 'trash-window';

  const saved = JSON.parse(localStorage.getItem('neural-panel-trash-window') || 'null');
  if (saved) {
    if (saved.left && saved.left !== 'auto') win.style.left = saved.left;
    if (saved.top) win.style.top = saved.top;
    if (saved.width) win.style.width = saved.width;
    if (saved.height) win.style.height = saved.height;
  } else {
    win.style.left = Math.max(20, (window.innerWidth - 560) / 2) + 'px';
    win.style.top = Math.max(20, (window.innerHeight - 420) / 2) + 'px';
  }

  win.innerHTML = `
    <div class="resize-handle resize-handle-t" data-resize="t"></div>
    <div class="resize-handle resize-handle-b" data-resize="b"></div>
    <div class="resize-handle resize-handle-l" data-resize="l"></div>
    <div class="resize-handle resize-handle-r" data-resize="r"></div>
    <div class="resize-handle resize-handle-tl" data-resize="tl"></div>
    <div class="resize-handle resize-handle-tr" data-resize="tr"></div>
    <div class="resize-handle resize-handle-bl" data-resize="bl"></div>
    <div class="resize-handle resize-handle-br" data-resize="br"></div>
    <div class="trash-window-header drag-handle" data-drag="trash-window">
      <h3>Trash <span class="tw-h-count" id="tw-h-count"></span></h3>
      <button class="pin-btn" id="tw-pin" data-pin="trash-window" data-tooltip="Pin"><svg viewBox="0 0 24 24"><path d="M9 4v4.5L7.5 10H6v2h4v7l2 1 2-1v-7h4v-2h-1.5L15 8.5V4H9z" stroke-linejoin="round" stroke-linecap="round"/></svg></button>
      <button class="trash-window-close" id="tw-close" data-tooltip="Close">&times;</button>
    </div>
    <div class="trash-window-body">
      <div class="trash-list-pane">
        <div class="trash-list-header"><span id="tw-count">0 items</span><button class="trash-purge-btn" id="tw-purge">Purge All</button></div>
        <div class="trash-list-scroll" id="tw-list"></div>
      </div>
      <div class="trash-detail-pane" id="tw-detail">
        <div class="trash-detail-empty">Select a memory to preview</div>
      </div>
    </div>
  `;

  document.body.appendChild(win);

  // Wire close
  win.querySelector('#tw-close').addEventListener('click', closeTrashPanel);

  // Wire pin
  const pinBtn = win.querySelector('#tw-pin');
  const pinKey = 'neural-pinned-trash-window';
  if (localStorage.getItem(pinKey) === 'true') {
    win.classList.add('locked');
    pinBtn.classList.add('pinned');
  }
  pinBtn.addEventListener('click', () => {
    const isPinned = win.classList.toggle('locked');
    pinBtn.classList.toggle('pinned', isPinned);
    localStorage.setItem(pinKey, isPinned);
  });

  // Wire purge
  const purgeBtn = win.querySelector('#tw-purge');
  purgeBtn.addEventListener('click', async () => {
    if (!trashItems.length) return;
    if (!confirm(`Permanently delete all ${trashItems.length} trashed memor${trashItems.length === 1 ? 'y' : 'ies'}? This cannot be undone.`)) return;
    purgeBtn.textContent = 'Purging...';
    purgeBtn.disabled = true;
    try {
      const res = await fetch('/api/trash/purge', { method: 'DELETE', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({}) });
      if (res.ok) {
        trashItems = [];
        trashSelectedId = null;
        updateTrashBadge();
        renderTrashWindow();
      }
    } catch (err) { console.error('Purge error:', err); }
    purgeBtn.textContent = 'Purge All';
    purgeBtn.disabled = false;
  });

  // Fetch and render
  fetchTrashItems().then(() => renderTrashWindow());
}

function closeTrashPanel() {
  const win = document.getElementById('trash-window');
  if (win) win.remove();
  trashPanelOpen = false;
  trashSelectedId = null;
}

function renderTrashWindow() {
  const win = document.getElementById('trash-window');
  if (!win) return;

  const listEl = win.querySelector('#tw-list');
  const detailEl = win.querySelector('#tw-detail');
  const countEl = win.querySelector('#tw-count');
  const purgeBtn = win.querySelector('#tw-purge');

  countEl.textContent = trashItems.length === 0 ? 'Empty' : `${trashItems.length} item${trashItems.length !== 1 ? 's' : ''}`;
  purgeBtn.style.display = trashItems.length ? '' : 'none';

  // Update header count
  const hCount = win.querySelector('#tw-h-count');
  if (hCount) hCount.textContent = trashItems.length ? `(${trashItems.length})` : '';

  if (trashItems.length === 0) {
    listEl.innerHTML = '<div style="padding:20px;text-align:center;color:var(--t-muted);font-size:var(--fs-xs)">Trash is empty</div>';
    detailEl.innerHTML = '<div class="trash-detail-empty">Nothing here</div>';
    return;
  }

  // Render list
  listEl.innerHTML = trashItems.map(item => {
    const p = item.payload;
    const preview = (p.content || '').replace(/\n/g, ' ').slice(0, 60);
    const age = p.trashed_at ? formatTrashAge(p.trashed_at) : '';
    const active = item.id === trashSelectedId ? ' active' : '';
    return `<div class="trash-item${active}" data-id="${item.id}">
      <div class="trash-item-content">
        <div class="trash-item-preview">${preview || '(empty)'}</div>
        <div class="trash-item-meta">${p.category || 'uncategorized'}${age ? ' \u00b7 ' + age : ''}</div>
      </div>
    </div>`;
  }).join('');

  // Bind list item clicks
  listEl.querySelectorAll('.trash-item').forEach(el => {
    el.addEventListener('click', () => {
      trashSelectedId = el.dataset.id;
      listEl.querySelectorAll('.trash-item').forEach(i => i.classList.remove('active'));
      el.classList.add('active');
      renderTrashDetail();
    });
  });

  // Render detail if something selected
  if (trashSelectedId && trashItems.find(i => i.id === trashSelectedId)) {
    renderTrashDetail();
  } else {
    detailEl.innerHTML = '<div class="trash-detail-empty">Select a memory to preview</div>';
  }
}

function renderTrashDetail() {
  const win = document.getElementById('trash-window');
  if (!win) return;
  const detailEl = win.querySelector('#tw-detail');
  const item = trashItems.find(i => i.id === trashSelectedId);
  if (!item) {
    detailEl.innerHTML = '<div class="trash-detail-empty">Select a memory to preview</div>';
    return;
  }

  const p = item.payload;
  const age = p.trashed_at ? formatTrashAge(p.trashed_at) : '';

  detailEl.innerHTML = `
    <div class="trash-detail-header">
      <span class="trash-detail-cat">${p.category || 'uncategorized'}${age ? ' \u00b7 trashed ' + age : ''}</span>
      <div class="trash-detail-actions">
        <button class="trash-restore-btn" id="tw-restore">Restore</button>
        <button class="trash-delete-btn" id="tw-delete">Delete</button>
      </div>
    </div>
    <div class="trash-detail-body">${formatMemoryContent(p.content || '')}</div>
  `;

  // Wire restore
  detailEl.querySelector('#tw-restore').addEventListener('click', async () => {
    const btn = detailEl.querySelector('#tw-restore');
    btn.textContent = 'Restoring...';
    btn.disabled = true;
    try {
      const res = await fetch(`/api/trash/${encodeURIComponent(item.id)}/restore`, { method: 'POST' });
      if (res.ok) {
        trashItems = trashItems.filter(i => i.id !== item.id);
        trashSelectedId = null;
        updateTrashBadge();
        renderTrashWindow();
        // Reload graph
        const memRes = await fetch('/api/memories');
        if (memRes.ok) {
          const memData = await memRes.json();
          allNodes = memData.nodes;
          allLinks = memData.links;
          $statTotal.textContent = allNodes.length;
          const presentCats = new Set(allNodes.map(n => n.payload.category));
          buildCategorySidebar(presentCats);
          applyGraphData();
          updateStats();
        }
      }
    } catch (err) { console.error('Restore error:', err); }
  });

  // Wire permanent delete
  detailEl.querySelector('#tw-delete').addEventListener('click', async () => {
    if (!confirm('Permanently delete this memory? This cannot be undone.')) return;
    const btn = detailEl.querySelector('#tw-delete');
    btn.textContent = 'Deleting...';
    btn.disabled = true;
    try {
      const res = await fetch(`/api/memory/${encodeURIComponent(item.id)}?permanent=true`, { method: 'DELETE' });
      if (res.ok) {
        trashItems = trashItems.filter(i => i.id !== item.id);
        trashSelectedId = null;
        updateTrashBadge();
        renderTrashWindow();
      }
    } catch (err) { console.error('Permanent delete error:', err); }
  });
}

$trashBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  if (trashPanelOpen) closeTrashPanel();
  else openTrashPanel();
});

// ═══════════════════════════════════════════
// SETTINGS MODAL
// ═══════════════════════════════════════════
async function openSettingsModal() {
  // If already open, just bring it to front
  const existing = document.getElementById('settings-panel');
  if (existing) { existing.style.zIndex = '301'; return; }

  let settings = {};
  let qdrantOk = false;
  let connections = [];
  let ccIntegrations = { global: { installed: false }, projects: [] };
  let ccSkills = [];
  let tunnelStatus = { available: false, running: false, url: null };
  let mcpKeyInfo = { hasKey: false };
  let _bridgeResult = null;

  try {
    const [settingsRes, statsRes, connRes, ccRes, skillsRes, tunnelRes, keyRes, bridgeRes] = await Promise.allSettled([
      fetch('/api/settings').then(r => r.json()),
      fetch('/api/stats').then(r => r.json()),
      fetch('/api/connections').then(r => r.json()),
      fetch('/api/claude-code/integrations').then(r => r.json()),
      fetch('/api/claude-code/skills').then(r => r.json()),
      fetch('/api/tunnel/status').then(r => r.json()),
      fetch('/api/mcp-key').then(r => r.json()),
      fetch('/api/bridges/openclaw').then(r => r.json()),
    ]);
    if (settingsRes.status === 'fulfilled') settings = settingsRes.value;
    if (statsRes.status === 'fulfilled' && statsRes.value.status) qdrantOk = true;
    if (connRes.status === 'fulfilled' && connRes.value.connections) connections = connRes.value.connections;
    if (ccRes.status === 'fulfilled' && ccRes.value.ok) ccIntegrations = ccRes.value;
    if (skillsRes.status === 'fulfilled' && skillsRes.value.ok) ccSkills = skillsRes.value.skills || [];
    if (tunnelRes.status === 'fulfilled' && tunnelRes.value.ok) tunnelStatus = tunnelRes.value;
    if (keyRes.status === 'fulfilled' && keyRes.value.ok) mcpKeyInfo = keyRes.value;
    if (bridgeRes.status === 'fulfilled' && bridgeRes.value.ok) _bridgeResult = bridgeRes.value;
  } catch {}
  let openclawBridge = _bridgeResult || { enabled: false };

  const eyeOpen = '<svg viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>';
  const eyeClosed = '<svg viewBox="0 0 24 24"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94"/><path d="M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19"/><line x1="1" y1="1" x2="23" y2="23"/></svg>';

  function rangeRow(key, label, min, max, step) {
    const val = gfx[key];
    return `<div class="gfx-row">
      <span class="gfx-label">${label}</span>
      <input type="range" data-key="${key}" min="${min}" max="${max}" step="${step}" value="${val}">
      <span class="gfx-val" data-val="${key}">${Number(val).toFixed(step < 1 ? 2 : 0)}</span>
    </div>`;
  }

  // Backdrop (invisible, closes panel on click when not pinned)
  const backdrop = document.createElement('div');
  backdrop.className = 'settings-panel-backdrop';
  document.body.appendChild(backdrop);

  // Create the floating panel
  const overlay = document.createElement('div');
  overlay.className = 'settings-panel glass resizable';
  overlay.id = 'settings-panel';

  // Restore saved position/size or center
  const savedPanel = JSON.parse(localStorage.getItem('neural-panel-settings-panel') || 'null');
  if (savedPanel) {
    if (savedPanel.left && savedPanel.left !== 'auto') overlay.style.left = savedPanel.left;
    if (savedPanel.top) overlay.style.top = savedPanel.top;
    if (savedPanel.width) overlay.style.width = savedPanel.width;
    if (savedPanel.height) overlay.style.height = savedPanel.height;
  } else {
    overlay.style.left = Math.max(20, (window.innerWidth - 620) / 2) + 'px';
    overlay.style.top = Math.max(20, (window.innerHeight - 600) / 2) + 'px';
  }

  overlay.innerHTML = `
    <div class="resize-handle resize-handle-t" data-resize="t"></div>
    <div class="resize-handle resize-handle-b" data-resize="b"></div>
    <div class="resize-handle resize-handle-l" data-resize="l"></div>
    <div class="resize-handle resize-handle-r" data-resize="r"></div>
    <div class="resize-handle resize-handle-tl" data-resize="tl"></div>
    <div class="resize-handle resize-handle-tr" data-resize="tr"></div>
    <div class="resize-handle resize-handle-bl" data-resize="bl"></div>
    <div class="resize-handle resize-handle-br" data-resize="br"></div>
    <div class="settings-panel-header drag-handle" data-drag="settings-panel">
      <h3>Settings</h3>
      <button class="settings-panel-pin pin-btn" id="stg-pin" data-pin="settings-panel" data-tooltip="Pin"><svg viewBox="0 0 24 24"><path d="M9 4v4.5L7.5 10H6v2h4v7l2 1 2-1v-7h4v-2h-1.5L15 8.5V4H9z" stroke-linejoin="round" stroke-linecap="round"/></svg></button>
      <button class="settings-panel-close" id="stg-close" data-tooltip="Close">&times;</button>
    </div>
    <div class="settings-panel-body">
      <nav class="settings-nav">
        <button class="settings-nav-item active" data-tab="server">
          <svg viewBox="0 0 24 24"><rect x="2" y="2" width="20" height="8" rx="2"/><rect x="2" y="14" width="20" height="8" rx="2"/><circle cx="6" cy="6" r="1"/><circle cx="6" cy="18" r="1"/></svg>
          Server
        </button>
        <button class="settings-nav-item" data-tab="hooks">
          <svg viewBox="0 0 24 24"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>
          Connections
        </button>
        <button class="settings-nav-item" data-tab="collections">
          <svg viewBox="0 0 24 24"><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4.03 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4.03 3 9 3s9-1.34 9-3V5"/></svg>
          Collections
        </button>
        <button class="settings-nav-item" data-tab="projects">
          <svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>
          Projects
        </button>
        <button class="settings-nav-item" data-tab="memory">
          <svg viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 0-7 7c0 2.38 1.19 4.47 3 5.74V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.26c1.81-1.27 3-3.36 3-5.74a7 7 0 0 0-7-7z"/><line x1="9" y1="21" x2="15" y2="21"/><line x1="10" y1="24" x2="14" y2="24"/></svg>
          Memory
        </button>
        <button class="settings-nav-item" data-tab="interface">
          <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="9" y1="3" x2="9" y2="21"/><line x1="9" y1="9" x2="21" y2="9"/></svg>
          Interface
        </button>
        <button class="settings-nav-item" data-tab="graphics">
          <svg viewBox="0 0 24 24"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>
          Graphics
        </button>
      </nav>
      <div class="settings-content">

      <!-- SERVER TAB -->
      <div class="settings-tab-body active" data-tab="server">
        <div class="settings-status">
          <span class="settings-status-dot ${qdrantOk ? 'connected' : 'disconnected'}"></span>
          Qdrant: ${qdrantOk ? 'Connected' : 'Not connected'}
        </div>

        <div class="settings-field">
          <label>OpenAI API Key</label>
          <div class="settings-key-row">
            <input type="password" id="stg-openai" placeholder="${settings.openaiApiKey || 'sk-...'}" autocomplete="off" spellcheck="false">
            <button class="settings-toggle-vis" data-target="stg-openai" data-tooltip="Toggle">${eyeClosed}</button>
          </div>
          <div class="settings-hint">${settings.openaiApiKeySet ? 'Key is set' : 'Not configured'} — leave empty to keep current</div>
        </div>

        <div class="settings-field">
          <label>Qdrant URL</label>
          <div class="settings-key-row">
            <input type="text" id="stg-qdrant-url" placeholder="${settings.qdrantUrl || 'http://localhost:6333'}" autocomplete="off" spellcheck="false">
          </div>
          <div class="settings-hint">Default: http://localhost:6333</div>
        </div>

        <div class="settings-field">
          <label>Qdrant API Key</label>
          <div class="settings-key-row">
            <input type="password" id="stg-qdrant-key" placeholder="${settings.qdrantApiKey || 'your-key'}" autocomplete="off" spellcheck="false">
            <button class="settings-toggle-vis" data-target="stg-qdrant-key" data-tooltip="Toggle">${eyeClosed}</button>
          </div>
          <div class="settings-hint">${settings.qdrantApiKeySet ? 'Key is set' : 'Not configured'} — leave empty to keep current</div>
        </div>

        <div class="settings-restart-notice" id="stg-restart-notice">Settings saved. Restart the server for changes to take effect.</div>

        <div class="settings-actions">
          <button class="settings-btn-cancel" id="stg-cancel">Cancel</button>
          <button class="settings-btn-save" id="stg-save">Save</button>
        </div>
      </div>

      <!-- COLLECTIONS TAB -->
      <div class="settings-tab-body" data-tab="collections">
        <div class="gfx-group-title">Memory Collections</div>
        <div class="conn-list" id="conn-list">
          ${connections.length === 0 ? '<div class="conn-empty">No connections configured</div>' :
            connections.map(c => `
              <div class="conn-item${c.active ? ' active' : ''}${!c.reachable ? ' unreachable' : ''}" data-conn-id="${c.id}">
                <div class="conn-item-dot"></div>
                <div class="conn-item-info">
                  <div class="conn-item-name">${c.label || c.collection}</div>
                  <div class="conn-item-meta">${c.collection}</div>
                </div>
                ${c.reachable ? `<span class="conn-item-count">${c.points} pts</span>` : ''}
                ${!c.reachable && /localhost|127\\.0\\.0\\.1/.test(c.url) ? `
                  <button class="conn-item-start" data-conn-id="${c.id}" data-tooltip="Start Container">
                    <svg viewBox="0 0 24 24"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                  </button>
                ` : ''}
                ${c.reachable ? `
                  <button class="conn-item-action conn-item-backup" data-conn-id="${c.id}" data-tooltip="Backup">
                    <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                  </button>
                  <button class="conn-item-action conn-item-restore" data-conn-id="${c.id}" data-tooltip="Restore">
                    <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                  </button>
                ` : ''}
                <button class="conn-item-delete" data-conn-id="${c.id}" data-conn-label="${c.label || c.collection}" data-tooltip="Remove">
                  <svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                </button>
              </div>
            `).join('')}
        </div>
        <button class="conn-add-btn" id="conn-add-btn">
          <svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
          Add Collection
        </button>
        <button class="conn-add-btn" id="conn-restore-standalone" style="margin-top:6px; border-style:solid">
          <svg viewBox="0 0 24 24" style="width:14px;height:14px;fill:none;stroke:currentColor;stroke-width:2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
          Restore from Backup
        </button>
      </div>

      <!-- HOOKS TAB -->
      <div class="settings-tab-body" data-tab="hooks">
        <div class="cc-hint" style="margin-bottom:10px">Services and agents connected to SynaBun.</div>

        <!-- Claude Code service panel -->
        ${(() => {
          const gh = ccIntegrations.global.hooks || {};
          const projs = ccIntegrations.projects || [];
          // A hook is "on" only if it's on in global AND all projects
          const ssOn = gh.SessionStart && projs.every(p => (p.hooks || {}).SessionStart);
          const psOn = gh.UserPromptSubmit && projs.every(p => (p.hooks || {}).UserPromptSubmit);
          const pcOn = gh.PreCompact && projs.every(p => (p.hooks || {}).PreCompact);
          const stOn = gh.Stop && projs.every(p => (p.hooks || {}).Stop);
          const ptOn = gh.PostToolUse && projs.every(p => (p.hooks || {}).PostToolUse);
          const allOn = ssOn && psOn && pcOn && stOn && ptOn;
          const anyOn = ssOn || psOn || pcOn || stOn || ptOn;
          const statusLabel = allOn ? 'Connected' : anyOn ? 'Partial' : 'Off';
          const statusClass = anyOn ? 'active' : 'inactive';
          return `
        <div class="cc-panel${anyOn ? ' enabled' : ''}" data-cc-target="global">
          <div class="cc-panel-header" data-cc-collapse>
            <svg class="cc-panel-chevron" viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"/></svg>
            <span class="cc-panel-title">Claude Code</span>
            <span class="cc-panel-status ${statusClass}">${statusLabel}</span>
          </div>
          <div class="cc-panel-body">

            <div class="cc-section-label">Hooks</div>
            <div class="cc-hook-toggles">
              <div class="cc-integration-item${ssOn ? ' enabled' : ''}" data-hook="SessionStart">
                <div class="cc-integration-info">
                  <div class="cc-integration-label">SessionStart</div>
                  <div class="cc-integration-path">Runs once when a new session begins</div>
                </div>
                <button class="cc-toggle${ssOn ? ' on' : ''}" data-cc-hook="SessionStart" data-cc-scope="global"></button>
              </div>
              <div class="cc-integration-item${psOn ? ' enabled' : ''}" data-hook="UserPromptSubmit">
                <div class="cc-integration-info">
                  <div class="cc-integration-label">UserPromptSubmit</div>
                  <div class="cc-integration-path">Runs on every user message</div>
                </div>
                <button class="cc-toggle${psOn ? ' on' : ''}" data-cc-hook="UserPromptSubmit" data-cc-scope="global"></button>
              </div>
              <div class="cc-integration-item${pcOn ? ' enabled' : ''}" data-hook="PreCompact">
                <div class="cc-integration-info">
                  <div class="cc-integration-label">PreCompact</div>
                  <div class="cc-integration-path">Caches session data before context compaction</div>
                </div>
                <button class="cc-toggle${pcOn ? ' on' : ''}" data-cc-hook="PreCompact" data-cc-scope="global"></button>
              </div>
              <div class="cc-integration-item${stOn ? ' enabled' : ''}" data-hook="Stop">
                <div class="cc-integration-info">
                  <div class="cc-integration-label">Stop</div>
                  <div class="cc-integration-path">Enforces session indexing after compaction</div>
                </div>
                <button class="cc-toggle${stOn ? ' on' : ''}" data-cc-hook="Stop" data-cc-scope="global"></button>
              </div>
              <div class="cc-integration-item${ptOn ? ' enabled' : ''}" data-hook="PostToolUse">
                <div class="cc-integration-info">
                  <div class="cc-integration-label">PostToolUse</div>
                  <div class="cc-integration-path">Tracks edits and clears enforcement flags on remember</div>
                </div>
                <button class="cc-toggle${ptOn ? ' on' : ''}" data-cc-hook="PostToolUse" data-cc-scope="global"></button>
              </div>
            </div>

            <div class="cc-section-label">Features</div>
            <div class="cc-hook-toggles">
              ${(() => {
                const hf = ccIntegrations.hookFeatures || {};
                const cmOn = hf.conversationMemory !== false;
                return `
              <div class="cc-integration-item${cmOn ? ' enabled' : ''}" data-feature="conversationMemory">
                <div class="cc-integration-info">
                  <div class="cc-integration-label">Conversation Memory</div>
                  <div class="cc-integration-path">Auto-index sessions on compaction for cross-session recall</div>
                </div>
                <button class="cc-toggle${cmOn ? ' on' : ''}" data-cc-feature="conversationMemory"></button>
              </div>`;
              })()}
            </div>

            <div class="cc-section-label">CLAUDE.md Ruleset</div>
            <div class="cc-hint" style="margin-bottom:6px;font-size:11px">Memory instructions to paste into your project's CLAUDE.md.</div>
            <div style="position:relative">
              <div id="cc-ruleset-preview" style="max-height:140px;overflow-y:auto;background:rgba(255,255,255,0.03);border:1px solid var(--b-subtle);border-radius:6px;padding:10px 12px;font-family:'JetBrains Mono',monospace;font-size:10px;line-height:1.5;color:var(--t-secondary);white-space:pre-wrap;word-break:break-word;">Loading...</div>
              <button class="conn-add-btn" id="cc-ruleset-copy" style="margin:6px 0 0;width:100%;font-size:11px;padding:6px 10px;border-style:solid;background:rgba(255,255,255,0.03)">
                <svg viewBox="0 0 24 24" style="width:11px;height:11px;opacity:0.5"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
                Copy SynaBun's CLAUDE.md Ruleset
              </button>
            </div>

            <div class="cc-section-label">MCP Server</div>
            <div class="cc-integration-item${(ccIntegrations.mcp || {}).connected ? ' enabled' : ''}" id="cc-mcp-row">
              <div class="cc-integration-info">
                <div class="cc-integration-label">SynaBun MCP</div>
                <div class="cc-integration-path">${(ccIntegrations.mcp || {}).connected ? 'Registered in ~/.claude.json' : 'Not connected'}</div>
              </div>
              <button class="cc-toggle${(ccIntegrations.mcp || {}).connected ? ' on' : ''}" id="cc-mcp-toggle"></button>
            </div>
            <div style="margin-top:4px">
              <button class="conn-add-btn" id="cc-mcp-copy" style="margin:0;width:100%;font-size:11px;padding:5px 10px;border-style:solid;background:rgba(255,255,255,0.03)">
                <svg viewBox="0 0 24 24" style="width:11px;height:11px;opacity:0.5"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
                Copy CLI Command
              </button>
            </div>

            <div class="cc-section-label">Claude Web</div>
            <div class="cc-integration-item${tunnelStatus.running ? ' enabled' : ''}" id="cc-tunnel-row">
              <div class="cc-integration-info">
                <div class="cc-integration-label" id="cc-tunnel-label">${tunnelStatus.running ? 'Running' : tunnelStatus.available ? 'Ready' : 'Not installed'}</div>
                <div class="cc-integration-path" id="cc-tunnel-url">${tunnelStatus.url || (tunnelStatus.available ? 'Expose MCP via public tunnel' : 'Install cloudflared to enable')}</div>
              </div>
              ${tunnelStatus.available ? '<button class="cc-toggle' + (tunnelStatus.running ? ' on' : '') + '" id="cc-tunnel-toggle"></button>' : ''}
            </div>
            ${tunnelStatus.url ? '<div style="margin-top:4px"><button class="conn-add-btn" id="cc-tunnel-copy-url" style="margin:0;width:100%;font-size:11px;padding:5px 10px;border-style:solid;background:rgba(255,255,255,0.03)"><svg viewBox="0 0 24 24" style="width:11px;height:11px;opacity:0.5"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy MCP URL</button></div>' : ''}

            <div class="cc-section-label">Authentication</div>
            <div class="cc-integration-item${mcpKeyInfo.hasKey ? ' enabled' : ''}" id="cc-apikey-row">
              <div class="cc-integration-info">
                <div class="cc-integration-label">MCP API Key</div>
                <div class="cc-integration-path" id="cc-apikey-status">${mcpKeyInfo.hasKey ? mcpKeyInfo.maskedKey : 'No key set \u2014 tunnel is open'}</div>
              </div>
              <button class="conn-add-btn" id="cc-apikey-generate" style="margin:0;font-size:11px;padding:4px 10px;width:auto;border-style:solid;background:rgba(255,255,255,0.03)">${mcpKeyInfo.hasKey ? 'Regenerate' : 'Generate'}</button>
            </div>
            <div id="cc-apikey-reveal" style="display:none;margin-top:6px">
              <div style="background:rgba(255,255,255,0.04);padding:8px 10px;border-radius:6px;border:1px solid var(--b-subtle);font-family:'JetBrains Mono',monospace;font-size:11px;word-break:break-all;color:var(--t-bright);line-height:1.5" id="cc-apikey-value"></div>
              <div class="cc-hint" style="margin-top:4px;color:var(--accent-orange)">Save this key now \u2014 it won't be shown again.</div>
              <div style="margin-top:6px;display:flex;gap:6px">
                <button class="conn-add-btn" id="cc-apikey-copy" style="margin:0;flex:1;font-size:11px;padding:5px 10px;border-style:solid;background:rgba(255,255,255,0.03)"><svg viewBox="0 0 24 24" style="width:11px;height:11px;opacity:0.5"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy Key</button>
                <button class="conn-add-btn" id="cc-apikey-revoke" style="margin:0;font-size:11px;padding:5px 10px;opacity:0.5;width:auto;border-style:solid;background:rgba(255,255,255,0.03)">Revoke</button>
              </div>
            </div>
            <div class="cc-hint" style="margin-top:6px"><a href="https://claude.ai/settings/connectors" target="_blank" style="color:var(--accent-blue)">Settings &rarr; Connectors</a> in Claude web &rarr; Add MCP &rarr; paste the URL.</div>
            <div class="cc-hint" style="margin-top:2px;color:var(--accent-orange)">Never share the MCP URL or key.</div>

            ${ccSkills.length > 0 ? `
            <div class="cc-section-label">Skills</div>
            ${ccSkills.map(skill => `
              <div class="cc-skill-row${skill.installed ? ' installed' : ''}" data-skill-name="${skill.dirName}">
                <div class="cc-skill-info">
                  <span class="cc-skill-name">/${skill.name}</span>
                  <span class="cc-skill-desc">${skill.description || ''}</span>
                </div>
                <button class="cc-toggle${skill.installed ? ' on' : ''}" data-cc-skill="${skill.dirName}"></button>
              </div>
            `).join('')}
            ` : ''}
          </div>
        </div>`;
        })()}

        <!-- OpenClaw Bridge -->
        <div class="cc-panel${openclawBridge.enabled ? ' enabled' : ''}" id="bridge-openclaw" style="margin-top:10px">
          <div class="cc-panel-header" data-cc-collapse>
            <svg class="cc-panel-chevron" viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"/></svg>
            <span class="cc-panel-title" ${openclawBridge.enabled ? 'style="color:#f97316"' : ''}>OpenClaw</span>
            <span class="cc-panel-status ${openclawBridge.enabled ? 'active' : 'inactive'}" ${openclawBridge.enabled ? 'style="background:rgba(249,115,22,0.15);color:#f97316"' : ''}>${openclawBridge.enabled ? 'Connected' : 'Off'}</span>
          </div>
          <div class="cc-panel-body">
            <div class="cc-integration-item${openclawBridge.enabled ? ' enabled' : ''}">
              <div class="cc-integration-info">
                <div class="cc-integration-label">Memory Bridge</div>
                <div class="cc-integration-path" id="bridge-openclaw-meta">${
                  openclawBridge.enabled
                    ? (openclawBridge.nodeCount || 0) + ' nodes synced' + (openclawBridge.lastSync ? ' · ' + new Date(openclawBridge.lastSync).toLocaleTimeString() : '')
                    : 'Read-only overlay of OpenClaw markdown memories'
                }</div>
              </div>
            </div>
            <div class="cc-panel-actions" id="bridge-openclaw-actions">${
              openclawBridge.enabled
                ? `<button class="cc-enable-btn on" id="bridge-openclaw-sync" style="flex:1">
                    <svg viewBox="0 0 24 24" style="width:12px;height:12px;fill:none;stroke:currentColor;stroke-width:2;vertical-align:-1px;margin-right:4px"><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>Sync
                  </button>
                  <button class="cc-disable-btn" id="bridge-openclaw-disconnect">Disconnect</button>`
                : `<button class="cc-enable-btn" id="bridge-openclaw-connect">Connect</button>`
            }</div>
          </div>
        </div>

      </div>

      <!-- PROJECTS TAB -->
      <div class="settings-tab-body" data-tab="projects">
        <div class="cc-hint" style="margin-bottom:10px">Per-project hook installations. Each project gets its own <code style="font-size:12px;background:var(--s-medium);padding:2px 5px;border-radius:4px">.claude/settings.json</code> entry.</div>

        <div id="cc-project-list">
          ${ccIntegrations.projects.length === 0
            ? '<div class="cc-hint" style="text-align:center;padding:14px">No projects registered yet.</div>'
            : ccIntegrations.projects.map((p, i) => `
              <div class="cc-panel${p.installed ? ' enabled' : ''}" data-cc-idx="${i}" data-cc-path="${p.path.replace(/"/g, '&quot;')}">
                <div class="cc-panel-header" data-cc-collapse>
                  <svg class="cc-panel-chevron" viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"/></svg>
                  <span class="cc-panel-title">${p.label}</span>
                  <span class="cc-panel-status ${p.installed ? 'active' : 'inactive'}">${p.installed ? 'Active' : 'Off'}</span>
                </div>
                <div class="cc-panel-body">
                  <div class="cc-panel-row">
                    <span class="cc-panel-row-label">Path</span>
                    <span class="cc-panel-row-value" title="${p.path.replace(/\\/g, '/').replace(/"/g, '&quot;')}">${p.path.replace(/\\/g, '/')}</span>
                  </div>
                  <div class="cc-panel-actions">
                    <button class="cc-enable-btn${p.installed ? ' on' : ''}" data-cc-project-toggle="${i}">${p.installed ? 'Enabled' : 'Enable'}</button>
                    <button class="cc-remove-panel-btn" data-cc-remove="${i}">Remove</button>
                  </div>
                </div>
              </div>
            `).join('')}
        </div>
        <button class="conn-add-btn" id="cc-add-project" style="margin-top:8px">
          <svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
          Add Project
        </button>
      </div>

      <!-- MEMORY TAB -->
      <div class="settings-tab-body" data-tab="memory">
        <div class="gfx-group-title">Recall detail</div>
        <div class="settings-hint" style="margin-bottom:10px">How much content is shown when memories are recalled.</div>

        <div class="gfx-presets" id="recall-presets">
          <div class="gfx-preset-card" data-recall-preset="150">
            <span class="gfx-preset-name">Brief</span>
            <span class="gfx-preset-desc">Short snippets</span>
          </div>
          <div class="gfx-preset-card" data-recall-preset="500">
            <span class="gfx-preset-name">Summary</span>
            <span class="gfx-preset-desc">Key details</span>
          </div>
          <div class="gfx-preset-card active" data-recall-preset="0">
            <span class="gfx-preset-name">Full</span>
            <span class="gfx-preset-desc">Everything</span>
          </div>
        </div>

        <div class="gfx-row" style="margin-top:14px">
          <span class="gfx-label">Limit</span>
          <input type="range" id="recall-slider" min="100" max="2100" step="50" value="2100">
          <span class="gfx-val" id="recall-slider-val">No limit</span>
        </div>

        <div class="recall-preview-box" id="recall-preview"></div>

        <div class="settings-hint" style="margin-top:10px">Shorter responses use less context. Takes effect on next recall.</div>

        <div class="gfx-group-title" style="margin-top:22px">Memory Sync</div>
        <div class="settings-hint" style="margin-bottom:10px">Detect memories whose related files have changed since last update.</div>

        <button class="sync-check-btn" id="sync-check-btn" style="margin-top:12px" onclick="checkSyncStatus()">
          <span class="btn-label">Check for stale memories</span>
          <span class="spinner"></span>
        </button>
        <div class="sync-results" id="sync-results"></div>
      </div>

      <!-- INTERFACE TAB -->
      <div class="settings-tab-body" data-tab="interface">
        <div class="gfx-group-title">Appearance</div>
        <div class="settings-hint" style="margin-bottom:16px">Customize the look and feel of the Neural Interface.</div>

        <div class="gfx-preset-label">Panel Scale</div>
        <div class="settings-hint" style="margin-bottom:8px">Resize all overlay panels (sidebar, detail, stats).</div>
        <div class="gfx-row">
          <span class="gfx-label">Scale</span>
          <input type="range" id="ui-scale-slider" min="0.5" max="1.5" step="0.01" value="${parseFloat(localStorage.getItem('neural-ui-scale') || '1')}">
          <input type="number" id="ui-scale-val" class="gfx-val gfx-val-input" min="50" max="150" step="1" value="${Math.round(parseFloat(localStorage.getItem('neural-ui-scale') || '1') * 100)}" title="Type exact % or use arrow keys">
          <span class="gfx-val" style="pointer-events:none;margin-left:-2px">%</span>
        </div>

        <div class="gfx-preset-label" style="margin-top:16px">Floor Effect</div>
        <div class="gfx-presets" id="floor-style-cards">
          <div class="gfx-preset-card floor-card${gfx.floorStyle === 'grid' ? ' active' : ''}" data-floor-style="grid">
            <span class="gfx-preset-name">Grid</span>
            <span class="gfx-preset-desc">Soft glowing lines</span>
          </div>
          <div class="gfx-preset-card floor-card${gfx.floorStyle === 'dots' ? ' active' : ''}" data-floor-style="dots">
            <span class="gfx-preset-name">Dot Field</span>
            <span class="gfx-preset-desc">Proximity glow dots</span>
          </div>
          <div class="gfx-preset-card floor-card${gfx.floorStyle === 'hex' ? ' active' : ''}" data-floor-style="hex">
            <span class="gfx-preset-name">Hex Grid</span>
            <span class="gfx-preset-desc">Hexagonal cells</span>
          </div>
          <div class="gfx-preset-card floor-card${gfx.floorStyle === 'ripples' ? ' active' : ''}" data-floor-style="ripples">
            <span class="gfx-preset-name">Ripples</span>
            <span class="gfx-preset-desc">Concentric waves</span>
          </div>
          <div class="gfx-preset-card floor-card${gfx.floorStyle === 'fog' ? ' active' : ''}" data-floor-style="fog">
            <span class="gfx-preset-name">Ground Fog</span>
            <span class="gfx-preset-desc">Drifting mist</span>
          </div>
          <div class="gfx-preset-card floor-card${gfx.floorStyle === 'none' ? ' active' : ''}" data-floor-style="none">
            <span class="gfx-preset-name">None</span>
            <span class="gfx-preset-desc">No floor effect</span>
          </div>
        </div>
      </div>

      <!-- GRAPH TAB -->
      <div class="settings-tab-body" data-tab="graphics">
        <div class="gfx-preset-label">Quality Preset</div>
        <div class="gfx-presets">
          ${Object.entries(GFX_PRESETS).map(([key, p]) => `
            <div class="gfx-preset-card${getActivePreset() === key ? ' active' : ''}" data-preset="${key}">
              <span class="gfx-preset-name">${p.label}</span>
              <span class="gfx-preset-desc">${p.desc}</span>
            </div>
          `).join('')}
        </div>

        <button class="gfx-advanced-toggle" id="gfx-adv-toggle">
          <span class="arrow">&#9654;</span> Advanced Settings
        </button>
        <div class="gfx-advanced-body" id="gfx-adv-body">
          <div class="gfx-group-title">Links</div>
          ${rangeRow('linkOpacity', 'Opacity', 0, 0.5, 0.01)}
          ${rangeRow('linkCurvatureBase', 'Curvature', 0, 0.5, 0.01)}
          ${rangeRow('linkGlowOpacity', 'Glow base', 0, 0.3, 0.01)}
          ${rangeRow('linkGlowStrength', 'Glow strength', 0, 0.4, 0.01)}

          <div class="gfx-group-title">Nodes</div>
          ${rangeRow('coreOpacity', 'Core opacity', 0, 1, 0.05)}
          ${rangeRow('glowOpacity', 'Glow opacity', 0, 1, 0.05)}
          ${rangeRow('colorDarken', 'Color darken', 0.2, 1.0, 0.05)}
          ${rangeRow('glowScale', 'Glow size', 1, 10, 0.5)}

          <div class="gfx-group-title">Camera</div>
          ${rangeRow('clickZoom', 'Click zoom', 40, 300, 10)}
          ${rangeRow('gentleZoom', 'Gentle zoom', 80, 400, 10)}

          <div class="gfx-group-title">Selection</div>
          ${rangeRow('selectedGlow', 'Glow boost', 0.5, 3, 0.1)}
          ${rangeRow('selectedScale', 'Scale boost', 1.0, 2.0, 0.05)}

          <div class="gfx-group-title">Background</div>
          ${rangeRow('bgIntensity', 'Particle intensity', 0, 2, 0.05)}
          ${rangeRow('bgParticleCount', 'Particle count', 500, 5000, 100)}

          <button class="gfx-reset-btn" id="gfx-reset">Reset All to Defaults</button>
        </div>
      </div>
      </div>
    </div>
  `;

  document.body.appendChild(overlay);

  // Drag + resize now handled by the shared event-delegation system (savePanelLayout on mouseup)

  // ── Pin handler ──
  const pinBtn = overlay.querySelector('#stg-pin');
  const pinKey = 'neural-pinned-settings-panel';
  // Restore saved pin state
  if (localStorage.getItem(pinKey) === 'true') {
    overlay.classList.add('locked');
    pinBtn.classList.add('pinned');
    backdrop.style.display = 'none';
  }
  pinBtn.addEventListener('click', () => {
    const isPinned = overlay.classList.toggle('locked');
    pinBtn.classList.toggle('pinned', isPinned);
    localStorage.setItem(pinKey, isPinned);
    if (isPinned) {
      backdrop.style.display = 'none';
    } else {
      backdrop.style.display = '';
    }
  });

  // Nav switching
  overlay.querySelectorAll('.settings-nav-item').forEach(nav => {
    nav.addEventListener('click', () => {
      overlay.querySelectorAll('.settings-nav-item').forEach(n => n.classList.remove('active'));
      overlay.querySelectorAll('.settings-tab-body').forEach(b => b.classList.remove('active'));
      nav.classList.add('active');
      overlay.querySelector(`.settings-tab-body[data-tab="${nav.dataset.tab}"]`).classList.add('active');
    });
  });

  // UI scale slider + number input (bidirectional sync)
  const uiScaleSlider = overlay.querySelector('#ui-scale-slider');
  const uiScaleVal = overlay.querySelector('#ui-scale-val');
  function applyUiScale(v) {
    v = Math.max(0.5, Math.min(1.5, v));
    document.documentElement.style.setProperty('--ui-scale', v);
    localStorage.setItem('neural-ui-scale', v);
  }
  if (uiScaleSlider) {
    uiScaleSlider.addEventListener('input', () => {
      const v = parseFloat(uiScaleSlider.value);
      applyUiScale(v);
      uiScaleVal.value = Math.round(v * 100);
    });
  }
  if (uiScaleVal) {
    uiScaleVal.addEventListener('change', () => {
      const pct = Math.max(50, Math.min(150, parseInt(uiScaleVal.value) || 100));
      uiScaleVal.value = pct;
      const v = pct / 100;
      applyUiScale(v);
      if (uiScaleSlider) uiScaleSlider.value = v;
    });
  }

  // Floor style cards
  overlay.querySelectorAll('.floor-card[data-floor-style]').forEach(card => {
    card.addEventListener('click', () => {
      const style = card.dataset.floorStyle;
      gfx.floorStyle = style;
      saveGfxConfig(gfx);
      overlay.querySelectorAll('.floor-card').forEach(c => c.classList.remove('active'));
      card.classList.add('active');
      applyFloorStyle(style);
    });
  });

  // Graphics preset cards (skip recall preset cards)
  overlay.querySelectorAll('.gfx-preset-card[data-preset]').forEach(card => {
    card.addEventListener('click', () => {
      applyGfxPreset(card.dataset.preset);
    });
  });

  // ── Memory tab: Recall response size ──
  const recallSlider = overlay.querySelector('#recall-slider');
  const recallSliderVal = overlay.querySelector('#recall-slider-val');
  const recallPreview = overlay.querySelector('#recall-preview');
  const recallPresets = overlay.querySelector('#recall-presets');
  const PREVIEW_TEXT = 'SynaBun is a persistent vector memory system for AI assistants built with three core components: MCP Server (TypeScript/Node.js), Neural Interface (Express.js + Three.js), and Qdrant Vector Database (Docker). It stores memory embeddings in a single collection with cosine distance similarity and supports multiple projects.';

  function updateRecallUI(maxChars) {
    // Update slider position
    recallSlider.value = maxChars === 0 ? 2100 : Math.min(maxChars, 2100);
    // Update label
    recallSliderVal.textContent = maxChars === 0 ? 'No limit' : maxChars + ' chars';
    // Update preset highlights
    recallPresets.querySelectorAll('.gfx-preset-card').forEach(c => {
      c.classList.toggle('active', String(maxChars) === c.dataset.recallPreset);
    });
    // Update preview
    if (maxChars > 0 && PREVIEW_TEXT.length > maxChars) {
      recallPreview.textContent = PREVIEW_TEXT.substring(0, maxChars) + '...';
    } else {
      recallPreview.textContent = PREVIEW_TEXT;
    }
  }

  async function saveRecallSetting(maxChars) {
    try {
      await fetch('/api/display-settings', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ recallMaxChars: maxChars }),
      });
    } catch (e) {
      console.error('Failed to save display settings:', e);
    }
  }

  // Load current setting
  fetch('/api/display-settings').then(r => r.json()).then(data => {
    updateRecallUI(data.recallMaxChars ?? 0);
  }).catch(() => updateRecallUI(0));

  // Preset clicks
  recallPresets.querySelectorAll('.gfx-preset-card').forEach(card => {
    card.addEventListener('click', () => {
      const val = parseInt(card.dataset.recallPreset, 10);
      updateRecallUI(val);
      saveRecallSetting(val);
    });
  });

  // Slider changes
  recallSlider.addEventListener('input', () => {
    const raw = parseInt(recallSlider.value, 10);
    const val = raw >= 2100 ? 0 : raw; // max position = no limit
    updateRecallUI(val);
    saveRecallSetting(val);
  });

  // Advanced toggle
  const advToggle = overlay.querySelector('#gfx-adv-toggle');
  const advBody = overlay.querySelector('#gfx-adv-body');
  if (advToggle && advBody) {
    advToggle.addEventListener('click', () => {
      advToggle.classList.toggle('open');
      advBody.classList.toggle('open');
    });
  }

  // Graphics config — live range slider updates
  overlay.querySelectorAll('input[type="range"][data-key]').forEach(input => {
    input.addEventListener('input', () => {
      const key = input.dataset.key;
      const val = parseFloat(input.value);
      gfx[key] = val;
      const step = parseFloat(input.step);
      overlay.querySelector(`[data-val="${key}"]`).textContent = val.toFixed(step < 1 ? 2 : 0);
      saveGfxConfig(gfx);
      // Clear preset selection when manually tweaking
      localStorage.removeItem('neural-gfx-preset');
      overlay.querySelectorAll('.gfx-preset-card').forEach(c => c.classList.remove('active'));
      // Live-apply visual changes (forces disabled — layout is computed)
      if (graph) {
        // linkOpacity is synced live via linkPositionUpdate
        if (key === 'bgParticleCount') applyBgTheme(gfx.bgTheme || 'deep-grid');
      }
    });
  });

  // Reset button
  overlay.querySelector('#gfx-reset').addEventListener('click', () => {
    Object.assign(gfx, GFX_DEFAULTS);
    localStorage.removeItem('neural-gfx-config');
    localStorage.removeItem('neural-gfx-preset');
    overlay.querySelectorAll('input[type="range"][data-key]').forEach(input => {
      const key = input.dataset.key;
      input.value = GFX_DEFAULTS[key];
      const step = parseFloat(input.step);
      overlay.querySelector(`[data-val="${key}"]`).textContent = GFX_DEFAULTS[key].toFixed(step < 1 ? 2 : 0);
    });
    overlay.querySelectorAll('.gfx-preset-card').forEach(c => c.classList.remove('active'));
    // Re-apply visual defaults (forces disabled — layout is computed)
    if (graph) {
      // linkOpacity is synced live via linkPositionUpdate
      applyBgTheme(GFX_DEFAULTS.bgTheme || 'deep-grid');
    }
  });

  // Toggle visibility buttons
  overlay.querySelectorAll('.settings-toggle-vis').forEach(btn => {
    btn.addEventListener('click', () => {
      const input = overlay.querySelector('#' + btn.dataset.target);
      if (!input) return;
      const isPassword = input.type === 'password';
      input.type = isPassword ? 'text' : 'password';
      btn.innerHTML = isPassword ? eyeOpen : eyeClosed;
    });
  });

  // Close handlers
  const close = () => {
    localStorage.setItem('neural-panel-settings-panel', JSON.stringify({
      left: overlay.style.left || null,
      top: overlay.style.top || null,
      width: overlay.style.width || null,
      height: overlay.style.height || null,
    }));
    overlay.remove();
    backdrop.remove();
  };
  overlay.querySelector('#stg-close').addEventListener('click', close);
  overlay.querySelector('#stg-cancel').addEventListener('click', close);

  // Save handler (server tab)
  overlay.querySelector('#stg-save').addEventListener('click', async () => {
    const body = {};
    const openai = overlay.querySelector('#stg-openai').value.trim();
    const qdrantUrl = overlay.querySelector('#stg-qdrant-url').value.trim();
    const qdrantKey = overlay.querySelector('#stg-qdrant-key').value.trim();

    if (openai) body.openaiApiKey = openai;
    if (qdrantUrl) body.qdrantUrl = qdrantUrl;
    if (qdrantKey) body.qdrantApiKey = qdrantKey;

    if (Object.keys(body).length === 0) { close(); return; }

    try {
      const saveBtn = overlay.querySelector('#stg-save');
      saveBtn.textContent = 'Saving...';
      saveBtn.disabled = true;

      const res = await fetch('/api/settings', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      const data = await res.json();

      if (data.ok) {
        const notice = overlay.querySelector('#stg-restart-notice');
        notice.textContent = data.message || 'Settings saved.';
        notice.style.display = 'block';
        saveBtn.textContent = 'Saved';
        setTimeout(() => { close(); location.reload(); }, 2000);
      } else {
        saveBtn.textContent = 'Error';
        saveBtn.disabled = false;
      }
    } catch {
      const saveBtn = overlay.querySelector('#stg-save');
      saveBtn.textContent = 'Error';
      saveBtn.disabled = false;
    }
  });

  // ── Collections tab handlers ──

  // Click a connection item to switch to it
  overlay.querySelectorAll('.conn-item').forEach(item => {
    item.addEventListener('click', async (e) => {
      if (e.target.closest('.conn-item-delete') || e.target.closest('.conn-item-action') || e.target.closest('.conn-item-start')) return;
      const id = item.dataset.connId;
      if (!id || item.classList.contains('active')) return;
      if (item.classList.contains('unreachable')) {
        alert('This connection is offline. Start the container first.');
        return;
      }

      item.style.opacity = '0.5';
      item.style.pointerEvents = 'none';
      try {
        const res = await fetch('/api/connections/active', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id }),
        });
        const data = await res.json();
        if (data.ok) {
          close();
          location.reload();
        } else {
          alert(data.error || 'Failed to switch connection');
          item.style.opacity = '';
          item.style.pointerEvents = '';
        }
      } catch (err) {
        alert('Failed to switch: ' + err.message);
        item.style.opacity = '';
        item.style.pointerEvents = '';
      }
    });
  });

  // Delete a connection
  overlay.querySelectorAll('.conn-item-delete').forEach(btn => {
    btn.addEventListener('click', async (e) => {
      e.stopPropagation();
      const id = btn.dataset.connId;
      const label = btn.dataset.connLabel;
      if (!id) return;

      if (!confirm(`Remove connection "${label}"?\nThis only removes the config, not the Qdrant data.`)) return;

      try {
        const res = await fetch(`/api/connections/${encodeURIComponent(id)}`, { method: 'DELETE' });
        const data = await res.json();
        if (data.ok) {
          const item = btn.closest('.conn-item');
          item.style.transition = 'opacity 0.2s, transform 0.2s';
          item.style.opacity = '0';
          item.style.transform = 'translateX(10px)';
          setTimeout(() => {
            item.remove();
            if (!overlay.querySelector('.conn-item')) {
              overlay.querySelector('#conn-list').innerHTML = '<div class="conn-empty">No connections configured</div>';
            }
          }, 200);
        } else {
          alert(data.error || 'Failed to remove connection');
        }
      } catch (err) {
        alert('Failed to remove: ' + err.message);
      }
    });
  });

  // Start a stopped Docker container for an unreachable connection
  overlay.querySelectorAll('.conn-item-start').forEach(btn => {
    btn.addEventListener('click', async (e) => {
      e.stopPropagation();
      const connId = btn.dataset.connId;
      if (!connId) return;

      btn.disabled = true;
      btn.innerHTML = '<svg viewBox="0 0 24 24" style="width:12px;height:12px;fill:none;stroke:currentColor;stroke-width:2;animation:dep-spin 0.7s linear infinite"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>';

      try {
        const res = await fetch('/api/connections/start-container', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: connId }),
        });
        const data = await res.json();
        if (data.ok) {
          close();
          location.reload();
        } else {
          alert(data.error || 'Failed to start container');
          btn.disabled = false;
          btn.innerHTML = '<svg viewBox="0 0 24 24"><polygon points="5 3 19 12 5 21 5 3"/></svg>';
        }
      } catch (err) {
        alert('Failed: ' + err.message);
        btn.disabled = false;
        btn.innerHTML = '<svg viewBox="0 0 24 24"><polygon points="5 3 19 12 5 21 5 3"/></svg>';
      }
    });
  });

  // Backup a collection (download snapshot)
  overlay.querySelectorAll('.conn-item-backup').forEach(btn => {
    btn.addEventListener('click', async (e) => {
      e.stopPropagation();
      const id = btn.dataset.connId;
      if (!id || btn.classList.contains('backing-up')) return;

      btn.classList.add('backing-up');
      try {
        const res = await fetch(`/api/connections/${encodeURIComponent(id)}/backup`, { method: 'POST' });
        if (!res.ok) {
          const data = await res.json();
          throw new Error(data.error || 'Backup failed');
        }
        const blob = await res.blob();
        const disposition = res.headers.get('content-disposition') || '';
        const filenameMatch = disposition.match(/filename="?([^"]+)"?/);
        const filename = filenameMatch ? filenameMatch[1] : `backup-${id}.snapshot`;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      } catch (err) {
        alert('Backup failed: ' + err.message);
      } finally {
        btn.classList.remove('backing-up');
      }
    });
  });

  // Restore a collection (upload snapshot)
  overlay.querySelectorAll('.conn-item-restore').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const id = btn.dataset.connId;
      if (!id || btn.classList.contains('restoring')) return;

      const item = btn.closest('.conn-item');
      const label = item?.querySelector('.conn-item-name')?.textContent || id;
      const collection = item?.querySelector('.conn-item-meta')?.textContent || '';

      // Create hidden file input
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = '.snapshot';
      fileInput.style.display = 'none';
      document.body.appendChild(fileInput);

      fileInput.addEventListener('change', () => {
        const file = fileInput.files[0];
        fileInput.remove();
        if (!file) return;

        // Show confirmation dialog
        const confirmOverlay = document.createElement('div');
        confirmOverlay.className = 'tag-delete-overlay';
        confirmOverlay.style.zIndex = '10001';
        confirmOverlay.innerHTML = `
          <div class="tag-delete-modal" style="max-width:400px">
            <div class="tag-delete-modal-title" style="margin-bottom:8px">Restore Collection</div>
            <p style="font-size:var(--fs-sm);color:var(--t-secondary);margin-bottom:6px">
              This will replace all data in <strong style="color:var(--t-bright)">${label}</strong> (${collection}) with the snapshot file.
            </p>
            <p style="font-size:var(--fs-xs);color:var(--t-muted);margin-bottom:4px">
              File: ${file.name} (${(file.size / 1024 / 1024).toFixed(1)} MB)
            </p>
            <p style="font-size:var(--fs-xs);color:var(--accent-dim);margin-bottom:18px">
              The snapshot must be from the same Qdrant version.
            </p>
            <div class="tag-delete-modal-actions">
              <button class="action-btn action-btn--ghost" id="restore-cancel">Cancel</button>
              <button class="action-btn action-btn--danger" id="restore-confirm" style="background:var(--accent-blue-bg);border-color:var(--accent-blue-border);color:var(--accent-blue)">Restore</button>
            </div>
          </div>
        `;
        document.body.appendChild(confirmOverlay);

        confirmOverlay.querySelector('#restore-cancel').addEventListener('click', () => confirmOverlay.remove());
        confirmOverlay.addEventListener('click', (ev) => { if (ev.target === confirmOverlay) confirmOverlay.remove(); });

        confirmOverlay.querySelector('#restore-confirm').addEventListener('click', async () => {
          const confirmBtn = confirmOverlay.querySelector('#restore-confirm');
          confirmBtn.textContent = 'Restoring...';
          confirmBtn.disabled = true;
          btn.classList.add('restoring');

          try {
            const buffer = await file.arrayBuffer();
            const res = await fetch(`/api/connections/${encodeURIComponent(id)}/restore`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/octet-stream' },
              body: buffer,
            });
            const data = await res.json();
            if (!res.ok) throw new Error(data.error || 'Restore failed');

            confirmOverlay.remove();
            // Refresh the connection list to update point counts
            try {
              const connRes = await fetch('/api/connections');
              const connData = await connRes.json();
              if (connData.connections) {
                const pts = connData.connections.find(c => c.id === id);
                if (pts) {
                  const countEl = item.querySelector('.conn-item-count');
                  if (countEl) countEl.textContent = pts.points + ' pts';
                }
              }
            } catch {}
          } catch (err) {
            alert('Restore failed: ' + err.message);
            confirmOverlay.remove();
          } finally {
            btn.classList.remove('restoring');
          }
        });
      });

      fileInput.click();
    });
  });

  // Restore from Backup — standalone (for collections not in the list)
  overlay.querySelector('#conn-restore-standalone').addEventListener('click', () => {
    const restoreOverlay = document.createElement('div');
    restoreOverlay.className = 'tag-delete-overlay';
    restoreOverlay.style.zIndex = '10001';
    restoreOverlay.innerHTML = `
      <div class="tag-delete-modal settings-modal" style="max-width:460px;text-align:left">
        <h3 style="margin-bottom:4px">Restore from Backup</h3>
        <p style="font-size:11px;color:var(--t-muted);margin-bottom:18px;line-height:1.5">
          Upload a .snapshot file to restore a collection. The collection will be created if it doesn't exist, and automatically added to your connections.
        </p>
        <div class="settings-field" style="margin-bottom:12px">
          <label>Qdrant URL</label>
          <input type="text" id="rs-url" placeholder="http://localhost:6333" autocomplete="off" spellcheck="false" style="font-family:'JetBrains Mono',monospace;font-size:12px">
        </div>
        <div class="settings-field" style="margin-bottom:12px">
          <label>API Key</label>
          <input type="text" id="rs-key" placeholder="your-api-key" autocomplete="off" spellcheck="false" style="font-family:'JetBrains Mono',monospace;font-size:12px">
        </div>
        <div class="settings-field" style="margin-bottom:12px">
          <label>Collection Name</label>
          <input type="text" id="rs-collection" placeholder="claude_memory" autocomplete="off" spellcheck="false" style="font-family:'JetBrains Mono',monospace;font-size:12px">
          <div style="font-size:10px;color:var(--t-muted);margin-top:3px">Lowercase, digits, underscores. Will be created if it doesn't exist.</div>
        </div>
        <div class="settings-field" style="margin-bottom:12px">
          <label>Label (optional)</label>
          <input type="text" id="rs-label" placeholder="My Restored Memory" autocomplete="off" spellcheck="false" style="font-size:12px">
        </div>
        <div class="settings-field" style="margin-bottom:16px">
          <label>Snapshot File</label>
          <div style="display:flex;align-items:center;gap:8px">
            <button class="settings-btn-cancel" id="rs-pick-file" style="font-size:11px;padding:6px 12px">Choose .snapshot file</button>
            <span id="rs-file-name" style="font-size:11px;color:var(--t-muted)">No file selected</span>
          </div>
          <input type="file" id="rs-file-input" accept=".snapshot" style="display:none">
        </div>
        <div id="rs-status" style="display:none;margin-bottom:12px;font-size:12px;display:flex;align-items:center;gap:8px">
          <div class="wiz-status-dot spin" id="rs-status-dot"></div>
          <span id="rs-status-text"></span>
        </div>
        <div class="settings-actions">
          <button class="settings-btn-cancel" id="rs-cancel">Cancel</button>
          <button class="settings-btn-save" id="rs-restore" disabled>Restore</button>
        </div>
      </div>
    `;
    document.body.appendChild(restoreOverlay);

    let selectedFile = null;
    const fileInput = restoreOverlay.querySelector('#rs-file-input');
    const fileName = restoreOverlay.querySelector('#rs-file-name');
    const restoreBtn = restoreOverlay.querySelector('#rs-restore');
    const statusEl = restoreOverlay.querySelector('#rs-status');
    const statusDot = restoreOverlay.querySelector('#rs-status-dot');
    const statusText = restoreOverlay.querySelector('#rs-status-text');

    const closeRestore = () => restoreOverlay.remove();
    restoreOverlay.querySelector('#rs-cancel').addEventListener('click', closeRestore);

    restoreOverlay.querySelector('#rs-pick-file').addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', () => {
      selectedFile = fileInput.files[0] || null;
      if (selectedFile) {
        fileName.textContent = selectedFile.name + ' (' + (selectedFile.size / 1024 / 1024).toFixed(1) + ' MB)';
        fileName.style.color = 'var(--t-primary)';
      } else {
        fileName.textContent = 'No file selected';
        fileName.style.color = 'var(--t-muted)';
      }
      checkReady();
    });

    function checkReady() {
      const url = restoreOverlay.querySelector('#rs-url').value.trim();
      const key = restoreOverlay.querySelector('#rs-key').value.trim();
      const col = restoreOverlay.querySelector('#rs-collection').value.trim();
      restoreBtn.disabled = !url || !key || !col || !selectedFile;
    }
    restoreOverlay.querySelectorAll('input[type="text"]').forEach(inp => inp.addEventListener('input', checkReady));

    restoreBtn.addEventListener('click', async () => {
      const url = restoreOverlay.querySelector('#rs-url').value.trim();
      const apiKey = restoreOverlay.querySelector('#rs-key').value.trim();
      const collection = restoreOverlay.querySelector('#rs-collection').value.trim();
      const label = restoreOverlay.querySelector('#rs-label').value.trim();

      if (!url || !apiKey || !collection || !selectedFile) return;

      restoreBtn.disabled = true;
      restoreBtn.textContent = 'Restoring...';
      statusEl.style.display = 'flex';
      statusDot.className = 'wiz-status-dot spin';
      statusText.textContent = 'Uploading and restoring snapshot...';

      try {
        const buffer = await selectedFile.arrayBuffer();
        const params = new URLSearchParams({ url, apiKey, collection });
        if (label) params.set('label', label);

        const res = await fetch('/api/connections/restore-standalone?' + params.toString(), {
          method: 'POST',
          headers: { 'Content-Type': 'application/octet-stream' },
          body: buffer,
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || 'Restore failed');

        statusDot.className = 'wiz-status-dot green';
        statusText.textContent = data.message;
        restoreBtn.textContent = 'Done';

        // Reload page after a moment to show the new connection
        setTimeout(() => { closeRestore(); close(); location.reload(); }, 1200);
      } catch (err) {
        statusDot.className = 'wiz-status-dot red';
        statusText.textContent = err.message;
        restoreBtn.textContent = 'Restore';
        restoreBtn.disabled = false;
      }
    });
  });

  // ── OpenClaw Bridge handlers ──

  const ocConnectBtn = overlay.querySelector('#bridge-openclaw-connect');
  if (ocConnectBtn) {
    ocConnectBtn.addEventListener('click', async () => {
      ocConnectBtn.disabled = true;
      ocConnectBtn.textContent = 'Connecting…';
      try {
        const res = await fetch('/api/bridges/openclaw/connect', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({}),
        });
        const data = await res.json();
        if (data.ok) {
          // Refresh graph with new nodes
          try {
            const memRes = await fetch('/api/memories');
            if (memRes.ok) {
              const memData = await memRes.json();
              allNodes = memData.nodes;
              allLinks = memData.links;
              await fetchCategories();
              const presentCats = new Set(allNodes.map(n => n.payload.category));
              activeCategories = new Set([...presentCats, ...Object.keys(categoryMetadata)]);
              buildCategorySidebar(presentCats);
              applyGraphData();
              updateStats();
            }
          } catch {}
          // Update bridge UI in-place
          const bridgeEl = overlay.querySelector('#bridge-openclaw');
          if (bridgeEl) bridgeEl.classList.add('enabled');
          const titleEl = bridgeEl?.querySelector('.cc-panel-title');
          if (titleEl) titleEl.style.color = '#f97316';
          const statusEl = bridgeEl?.querySelector('.cc-panel-status');
          if (statusEl) { statusEl.textContent = 'Connected'; statusEl.className = 'cc-panel-status active'; statusEl.style.background = 'rgba(249,115,22,0.15)'; statusEl.style.color = '#f97316'; }
          const integItem = bridgeEl?.querySelector('.cc-integration-item');
          if (integItem) integItem.classList.add('enabled');
          const metaEl = overlay.querySelector('#bridge-openclaw-meta');
          if (metaEl) metaEl.textContent = (data.nodes || 0) + ' nodes synced' + (data.nodes > 0 ? ' · ' + new Date().toLocaleTimeString() : '');
          const actionsEl = overlay.querySelector('#bridge-openclaw-actions');
          if (actionsEl) {
            actionsEl.innerHTML = `<button class="cc-enable-btn on" id="bridge-openclaw-sync" style="flex:1">
                <svg viewBox="0 0 24 24" style="width:12px;height:12px;fill:none;stroke:currentColor;stroke-width:2;vertical-align:-1px;margin-right:4px"><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>Sync
              </button>
              <button class="cc-disable-btn" id="bridge-openclaw-disconnect">Disconnect</button>`;
            attachBridgeSyncHandler(overlay);
            attachBridgeDisconnectHandler(overlay, close);
          }
        } else {
          alert(data.error || 'Failed to connect');
          ocConnectBtn.disabled = false;
          ocConnectBtn.textContent = 'Connect';
        }
      } catch (err) {
        alert('Failed: ' + err.message);
        ocConnectBtn.disabled = false;
        ocConnectBtn.textContent = 'Connect';
      }
    });
  }

  function attachBridgeSyncHandler(container) {
    const syncBtn = container.querySelector('#bridge-openclaw-sync');
    if (!syncBtn) return;
    syncBtn.addEventListener('click', async () => {
      syncBtn.disabled = true;
      const origHTML = syncBtn.innerHTML;
      syncBtn.textContent = 'Syncing…';
      try {
        const res = await fetch('/api/bridges/openclaw/sync', { method: 'POST' });
        const data = await res.json();
        if (data.ok) {
          const metaEl = container.querySelector('#bridge-openclaw-meta');
          if (metaEl) metaEl.textContent = (data.nodes || 0) + ' nodes synced · ' + new Date().toLocaleTimeString();
          // Refresh graph
          try {
            const memRes = await fetch('/api/memories');
            if (memRes.ok) {
              const memData = await memRes.json();
              allNodes = memData.nodes;
              allLinks = memData.links;
              await fetchCategories();
              const presentCats = new Set(allNodes.map(n => n.payload.category));
              activeCategories = new Set([...presentCats, ...Object.keys(categoryMetadata)]);
              buildCategorySidebar(presentCats);
              applyGraphData();
              updateStats();
            }
          } catch {}
        } else {
          alert(data.error || 'Sync failed');
        }
      } catch (err) {
        alert('Sync failed: ' + err.message);
      } finally {
        syncBtn.disabled = false;
        syncBtn.innerHTML = origHTML;
      }
    });
  }

  function attachBridgeDisconnectHandler(container, closeFn) {
    const disconnectBtn = container.querySelector('#bridge-openclaw-disconnect');
    if (!disconnectBtn) return;
    disconnectBtn.addEventListener('click', async () => {
      if (!confirm('Disconnect OpenClaw bridge? Memories will be removed from the graph.')) return;
      try {
        await fetch('/api/bridges/openclaw', { method: 'DELETE' });
        // Refresh graph
        try {
          const memRes = await fetch('/api/memories');
          if (memRes.ok) {
            const memData = await memRes.json();
            allNodes = memData.nodes;
            allLinks = memData.links;
            await fetchCategories();
            const presentCats = new Set(allNodes.map(n => n.payload.category));
            activeCategories = new Set([...presentCats, ...Object.keys(categoryMetadata)]);
            buildCategorySidebar(presentCats);
            applyGraphData();
            updateStats();
          }
        } catch {}
        // Update bridge UI in-place
        const bridgeEl = container.querySelector('#bridge-openclaw');
        if (bridgeEl) bridgeEl.classList.remove('enabled');
        const titleEl = bridgeEl?.querySelector('.cc-panel-title');
        if (titleEl) titleEl.style.color = '';
        const statusEl = bridgeEl?.querySelector('.cc-panel-status');
        if (statusEl) { statusEl.textContent = 'Off'; statusEl.className = 'cc-panel-status inactive'; statusEl.style.background = ''; statusEl.style.color = ''; }
        const integItem = bridgeEl?.querySelector('.cc-integration-item');
        if (integItem) integItem.classList.remove('enabled');
        const metaEl = container.querySelector('#bridge-openclaw-meta');
        if (metaEl) metaEl.textContent = 'Read-only overlay of OpenClaw markdown memories';
        const actionsEl = container.querySelector('#bridge-openclaw-actions');
        if (actionsEl) {
          actionsEl.innerHTML = `<button class="cc-enable-btn" id="bridge-openclaw-connect">Connect</button>`;
          // Re-attach connect handler
          const newConnBtn = actionsEl.querySelector('#bridge-openclaw-connect');
          if (newConnBtn) {
            newConnBtn.addEventListener('click', () => {
              if (closeFn) closeFn();
              openSettingsModal();
            });
          }
        }
      } catch (err) {
        alert('Disconnect failed: ' + err.message);
      }
    });
  }

  // Attach handlers for already-connected state (initial render)
  attachBridgeSyncHandler(overlay);
  attachBridgeDisconnectHandler(overlay, close);

  // Add a new collection — multi-step wizard
  overlay.querySelector('#conn-add-btn').addEventListener('click', () => {
    // --- Utilities ---
    function generateApiKey() {
      const arr = new Uint8Array(16);
      crypto.getRandomValues(arr);
      return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
    }
    function toDockerName(label) {
      return 'synabun-qdrant-' + label.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    }
    function suggestPort() {
      let max = 6333;
      connections.forEach(c => {
        const m = (c.url || '').match(/:(\d+)\/?$/);
        if (m) max = Math.max(max, parseInt(m[1], 10));
      });
      return max + 10 - (max % 10) + 10; // next round 10 above highest
    }

    const defaultPort = suggestPort();
    const wizState = {
      mode: null, label: '', url: '', apiKey: '', collection: '',
      port: defaultPort, grpcPort: defaultPort + 1,
      containerName: '', volumeName: '',
      dockerReady: false, collectionCreated: false,
    };

    let currentStep = 0;
    const TOTAL_STEPS = 4;

    // --- Build wizard DOM ---
    const wiz = document.createElement('div');
    wiz.className = 'conn-wizard-overlay';
    wiz.innerHTML = `
      <div class="conn-wizard-panel">
        <div class="conn-wizard-viewport" id="wiz-viewport">

          <!-- Step 0: Choose Mode -->
          <div class="conn-wizard-step active" data-wiz-step="0">
            <h3>New Collection</h3>
            <div class="wiz-subtitle">How would you like to set up your new memory collection?</div>
            <div class="wiz-mode-grid">
              <div class="wiz-mode-card" data-mode="docker">
                <svg class="wmc-icon" viewBox="0 0 24 24"><rect x="3" y="3" width="7" height="7" rx="1"/><rect x="14" y="3" width="7" height="7" rx="1"/><rect x="3" y="14" width="7" height="7" rx="1"/><line x1="17.5" y1="14" x2="17.5" y2="21"/><line x1="14" y1="17.5" x2="21" y2="17.5"/></svg>
                <div class="wmc-title">New Docker Instance</div>
                <div class="wmc-desc">Spin up a fresh Qdrant container on its own port</div>
              </div>
              <div class="wiz-mode-card" data-mode="existing">
                <svg class="wmc-icon" viewBox="0 0 24 24"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>
                <div class="wmc-title">Existing Instance</div>
                <div class="wmc-desc">Create a new collection on a running Qdrant</div>
              </div>
            </div>
          </div>

          <!-- Step 1: Configuration (content swapped based on mode) -->
          <div class="conn-wizard-step right" data-wiz-step="1">
            <div id="wiz-config-docker" style="display:none">
              <h3>Configure Container</h3>
              <div class="wiz-subtitle">Set up your new Qdrant Docker instance.</div>
              <div class="wiz-field">
                <label>Label</label>
                <input type="text" id="wiz-d-label" placeholder="My Project" autocomplete="off" spellcheck="false">
                <div class="wiz-hint">Friendly name shown in the UI</div>
                <div class="wiz-error" id="wiz-d-label-err"></div>
              </div>
              <div class="wiz-field">
                <label>Collection Name</label>
                <input type="text" id="wiz-d-collection" placeholder="my_collection" autocomplete="off" spellcheck="false">
                <div class="wiz-hint">Lowercase letters, digits, underscores. 3-50 chars.</div>
                <div class="wiz-error" id="wiz-d-collection-err"></div>
              </div>
              <div class="wiz-row">
                <div class="wiz-field">
                  <label>HTTP Port</label>
                  <input type="number" id="wiz-d-port" value="${defaultPort}" min="1024" max="65535">
                  <div class="wiz-hint">REST API port</div>
                </div>
                <div class="wiz-field">
                  <label>gRPC Port</label>
                  <input type="number" id="wiz-d-grpc" value="${defaultPort + 1}" min="1024" max="65535">
                  <div class="wiz-hint">gRPC port</div>
                </div>
              </div>
              <div class="wiz-field">
                <label>API Key</label>
                <div class="wiz-input-row">
                  <input type="text" id="wiz-d-key" value="${generateApiKey()}" autocomplete="off" spellcheck="false">
                  <button class="wiz-generate-btn" id="wiz-d-gen">Generate</button>
                </div>
                <div class="wiz-hint">Secures the Qdrant instance. Min 8 characters.</div>
                <div class="wiz-error" id="wiz-d-key-err"></div>
              </div>
            </div>

            <div id="wiz-config-existing" style="display:none">
              <h3>Instance Details</h3>
              <div class="wiz-subtitle">Connect to a running Qdrant instance and create a new collection.</div>
              <div class="wiz-field">
                <label>Label</label>
                <input type="text" id="wiz-e-label" placeholder="My Memory Store" autocomplete="off" spellcheck="false">
                <div class="wiz-hint">Friendly name shown in the UI</div>
                <div class="wiz-error" id="wiz-e-label-err"></div>
              </div>
              <div class="wiz-field">
                <label>Qdrant URL</label>
                <input type="text" id="wiz-e-url" placeholder="http://localhost:6333" autocomplete="off" spellcheck="false">
                <div class="wiz-hint">The full URL of your Qdrant instance</div>
                <div class="wiz-error" id="wiz-e-url-err"></div>
              </div>
              <div class="wiz-field">
                <label>API Key</label>
                <input type="text" id="wiz-e-key" placeholder="your-api-key" autocomplete="off" spellcheck="false">
                <div class="wiz-error" id="wiz-e-key-err"></div>
              </div>
              <div class="wiz-field">
                <label>Collection Name</label>
                <input type="text" id="wiz-e-collection" placeholder="my_collection" autocomplete="off" spellcheck="false">
                <div class="wiz-hint">Will be created if it doesn't exist. Lowercase, digits, underscores.</div>
                <div class="wiz-error" id="wiz-e-collection-err"></div>
              </div>
            </div>
          </div>

          <!-- Step 2: Action (docker start or collection create) -->
          <div class="conn-wizard-step right" data-wiz-step="2">
            <div id="wiz-action-docker" style="display:none">
              <h3>Start Container</h3>
              <div class="wiz-subtitle">Spinning up a new Qdrant instance and creating your collection.</div>
              <div class="wiz-status" id="wiz-docker-status" style="display:none">
                <div class="wiz-status-dot spin" id="wiz-docker-dot"></div>
                <span id="wiz-docker-status-text">Starting container...</span>
              </div>
              <div class="wiz-terminal" id="wiz-docker-term">Waiting to start...</div>
              <button class="wiz-action-btn" id="wiz-docker-btn">Start Container</button>
            </div>

            <div id="wiz-action-existing" style="display:none">
              <h3>Create Collection</h3>
              <div class="wiz-subtitle">Testing connectivity and creating the collection on your Qdrant instance.</div>
              <div class="wiz-status" id="wiz-existing-status" style="display:none">
                <div class="wiz-status-dot spin" id="wiz-existing-dot"></div>
                <span id="wiz-existing-status-text">Connecting...</span>
              </div>
              <button class="wiz-action-btn" id="wiz-existing-btn">Test & Create</button>
            </div>
          </div>

          <!-- Step 3: Confirm & Save -->
          <div class="conn-wizard-step right" data-wiz-step="3">
            <h3>Confirm & Save</h3>
            <div class="wiz-subtitle">Review your new collection before adding it.</div>
            <div class="wiz-summary-card" id="wiz-summary"></div>
            <button class="wiz-action-btn" id="wiz-save-btn">Add Collection</button>
          </div>

        </div>
        <div class="conn-wizard-nav">
          <button class="wiz-nav-btn" id="wiz-back" disabled>&larr; Back</button>
          <div class="wiz-dots" id="wiz-dots">
            ${Array.from({length: TOTAL_STEPS}, (_, i) => `<div class="wiz-dot${i === 0 ? ' active' : ''}"></div>`).join('')}
          </div>
          <button class="wiz-nav-btn primary" id="wiz-next">Next &rarr;</button>
        </div>
      </div>
    `;
    document.body.appendChild(wiz);

    const $viewport = wiz.querySelector('#wiz-viewport');
    const $steps = wiz.querySelectorAll('.conn-wizard-step');
    const $dots = wiz.querySelectorAll('.wiz-dot');
    const $back = wiz.querySelector('#wiz-back');
    const $next = wiz.querySelector('#wiz-next');

    // --- Close wizard ---
    const closeWiz = () => wiz.remove();

    // --- Resize viewport to fit active step ---
    function resizeViewport(stepIdx) {
      const step = $steps[stepIdx];
      step.style.position = 'relative';
      requestAnimationFrame(() => {
        $viewport.style.height = step.scrollHeight + 'px';
        setTimeout(() => { step.style.position = ''; }, 400);
      });
    }

    // --- Navigate steps ---
    function goToStep(n) {
      if (n < 0 || n >= TOTAL_STEPS) return;
      $steps.forEach((s, i) => {
        s.classList.remove('active', 'left', 'right');
        if (i === n) s.classList.add('active');
        else if (i < n) s.classList.add('left');
        else s.classList.add('right');
      });
      $dots.forEach((d, i) => {
        d.classList.remove('active', 'done');
        if (i === n) d.classList.add('active');
        else if (i < n) d.classList.add('done');
      });
      currentStep = n;
      $back.disabled = n === 0;
      updateNextBtn();
      resizeViewport(n);
    }

    function updateNextBtn() {
      if (currentStep === 0) {
        $next.disabled = !wizState.mode;
        $next.textContent = 'Next \u2192';
      } else if (currentStep === 1) {
        $next.disabled = false;
        $next.textContent = 'Next \u2192';
      } else if (currentStep === 2) {
        $next.disabled = !wizState.collectionCreated;
        $next.textContent = 'Next \u2192';
      } else if (currentStep === 3) {
        $next.style.display = 'none';
      }
      if (currentStep < 3) $next.style.display = '';
    }

    // --- Validation ---
    const collectionRe = /^[a-z][a-z0-9_]{2,49}$/;

    function clearErrors() {
      wiz.querySelectorAll('.wiz-error').forEach(e => { e.textContent = ''; e.classList.remove('visible'); });
    }
    function showError(id, msg) {
      const el = wiz.querySelector('#' + id);
      if (el) { el.textContent = msg; el.classList.add('visible'); }
    }

    function validateStep1() {
      clearErrors();
      let valid = true;
      if (wizState.mode === 'docker') {
        const label = wiz.querySelector('#wiz-d-label').value.trim();
        const collection = wiz.querySelector('#wiz-d-collection').value.trim();
        const key = wiz.querySelector('#wiz-d-key').value.trim();
        const port = parseInt(wiz.querySelector('#wiz-d-port').value, 10);
        const grpc = parseInt(wiz.querySelector('#wiz-d-grpc').value, 10);
        if (!label) { showError('wiz-d-label-err', 'Label is required'); valid = false; }
        if (!collectionRe.test(collection)) { showError('wiz-d-collection-err', 'Must be 3-50 chars: lowercase, digits, underscores'); valid = false; }
        if (key.length < 8) { showError('wiz-d-key-err', 'Minimum 8 characters'); valid = false; }
        if (port < 1024 || port > 65535) { valid = false; }
        if (grpc < 1024 || grpc > 65535 || grpc === port) { valid = false; }
        if (valid) {
          wizState.label = label;
          wizState.collection = collection;
          wizState.apiKey = key;
          wizState.port = port;
          wizState.grpcPort = grpc;
          wizState.containerName = toDockerName(label);
          wizState.volumeName = toDockerName(label) + '-data';
          wizState.url = 'http://localhost:' + port;
        }
      } else {
        const label = wiz.querySelector('#wiz-e-label').value.trim();
        const url = wiz.querySelector('#wiz-e-url').value.trim();
        const key = wiz.querySelector('#wiz-e-key').value.trim();
        const collection = wiz.querySelector('#wiz-e-collection').value.trim();
        if (!label) { showError('wiz-e-label-err', 'Label is required'); valid = false; }
        if (!url.startsWith('http://') && !url.startsWith('https://')) { showError('wiz-e-url-err', 'Must start with http:// or https://'); valid = false; }
        if (!key) { showError('wiz-e-key-err', 'API Key is required'); valid = false; }
        if (!collectionRe.test(collection)) { showError('wiz-e-collection-err', 'Must be 3-50 chars: lowercase, digits, underscores'); valid = false; }
        if (valid) {
          wizState.label = label;
          wizState.url = url.replace(/\/+$/, '');
          wizState.apiKey = key;
          wizState.collection = collection;
        }
      }
      return valid;
    }

    // --- Step 0: Mode selection ---
    wiz.querySelectorAll('.wiz-mode-card').forEach(card => {
      card.addEventListener('click', () => {
        wiz.querySelectorAll('.wiz-mode-card').forEach(c => c.classList.remove('selected'));
        card.classList.add('selected');
        wizState.mode = card.dataset.mode;
        updateNextBtn();
      });
    });

    // --- Step 1: Show correct config panel based on mode ---
    function showConfigPanel() {
      const isDocker = wizState.mode === 'docker';
      wiz.querySelector('#wiz-config-docker').style.display = isDocker ? '' : 'none';
      wiz.querySelector('#wiz-config-existing').style.display = isDocker ? 'none' : '';
      wiz.querySelector('#wiz-action-docker').style.display = isDocker ? '' : 'none';
      wiz.querySelector('#wiz-action-existing').style.display = isDocker ? 'none' : '';
    }

    // Generate button
    wiz.querySelector('#wiz-d-gen').addEventListener('click', () => {
      wiz.querySelector('#wiz-d-key').value = generateApiKey();
    });

    // Auto-sync gRPC port
    wiz.querySelector('#wiz-d-port').addEventListener('input', (e) => {
      const p = parseInt(e.target.value, 10);
      if (!isNaN(p)) wiz.querySelector('#wiz-d-grpc').value = p + 1;
    });

    // --- Step 2: Docker action ---
    wiz.querySelector('#wiz-docker-btn').addEventListener('click', async () => {
      const btn = wiz.querySelector('#wiz-docker-btn');
      const term = wiz.querySelector('#wiz-docker-term');
      const statusEl = wiz.querySelector('#wiz-docker-status');
      const dot = wiz.querySelector('#wiz-docker-dot');
      const statusText = wiz.querySelector('#wiz-docker-status-text');

      btn.disabled = true;
      btn.textContent = 'Starting...';
      statusEl.style.display = 'flex';
      dot.className = 'wiz-status-dot spin';
      statusText.textContent = 'Starting container...';
      term.textContent = 'Running docker run...\n';

      try {
        // 1. Start Docker container
        const dockerRes = await fetch('/api/connections/docker-new', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            port: wizState.port, grpcPort: wizState.grpcPort,
            apiKey: wizState.apiKey, containerName: wizState.containerName,
            volumeName: wizState.volumeName,
          }),
        });
        const dockerData = await dockerRes.json();
        if (!dockerRes.ok) {
          throw new Error(dockerData.error || 'Failed to start container');
        }
        term.textContent += (dockerData.output || 'Container started.') + '\n';

        if (!dockerData.ready) {
          throw new Error('Container started but Qdrant is not responding. Check Docker logs.');
        }

        statusText.textContent = 'Container ready. Creating collection...';
        term.textContent += 'Qdrant is ready on port ' + wizState.port + '\n';

        // 2. Create collection
        const colRes = await fetch('/api/connections/create-collection', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url: wizState.url, apiKey: wizState.apiKey, collection: wizState.collection }),
        });
        const colData = await colRes.json();
        if (!colRes.ok) {
          throw new Error(colData.error || 'Failed to create collection');
        }

        term.textContent += colData.message + '\n';
        dot.className = 'wiz-status-dot green';
        statusText.textContent = 'Collection ready!';
        btn.textContent = 'Done';
        wizState.dockerReady = true;
        wizState.collectionCreated = true;
        updateNextBtn();
      } catch (err) {
        dot.className = 'wiz-status-dot red';
        statusText.textContent = err.message;
        term.textContent += 'ERROR: ' + err.message + '\n';
        btn.textContent = 'Retry';
        btn.disabled = false;
      }
    });

    // --- Step 2: Existing action ---
    wiz.querySelector('#wiz-existing-btn').addEventListener('click', async () => {
      const btn = wiz.querySelector('#wiz-existing-btn');
      const statusEl = wiz.querySelector('#wiz-existing-status');
      const dot = wiz.querySelector('#wiz-existing-dot');
      const statusText = wiz.querySelector('#wiz-existing-status-text');

      btn.disabled = true;
      btn.textContent = 'Creating...';
      statusEl.style.display = 'flex';
      dot.className = 'wiz-status-dot spin';
      statusText.textContent = 'Testing connection & creating collection...';

      try {
        const res = await fetch('/api/connections/create-collection', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url: wizState.url, apiKey: wizState.apiKey, collection: wizState.collection }),
        });
        const data = await res.json();
        if (!res.ok) {
          throw new Error(data.error || 'Failed to create collection');
        }

        dot.className = 'wiz-status-dot green';
        statusText.textContent = data.existed ? 'Collection already exists — ready!' : 'Collection created!';
        btn.textContent = 'Done';
        wizState.collectionCreated = true;
        updateNextBtn();
      } catch (err) {
        dot.className = 'wiz-status-dot red';
        statusText.textContent = err.message;
        btn.textContent = 'Retry';
        btn.disabled = false;
      }
    });

    // --- Step 3: Summary & Save ---
    function buildSummary() {
      const summary = wiz.querySelector('#wiz-summary');
      summary.innerHTML = `
        <div class="wiz-summary-row"><span class="wsr-label">Label</span><span class="wsr-value">${wizState.label}</span></div>
        <div class="wiz-summary-row"><span class="wsr-label">URL</span><span class="wsr-value">${wizState.url}</span></div>
        <div class="wiz-summary-row"><span class="wsr-label">Collection</span><span class="wsr-value">${wizState.collection}</span></div>
        <div class="wiz-summary-row"><span class="wsr-label">Mode</span><span class="wsr-value">${wizState.mode === 'docker' ? 'New Docker Container' : 'Existing Instance'}</span></div>
      `;
    }

    wiz.querySelector('#wiz-save-btn').addEventListener('click', async () => {
      const btn = wiz.querySelector('#wiz-save-btn');
      btn.disabled = true;
      btn.textContent = 'Saving...';

      const id = wizState.label.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');

      try {
        const res = await fetch('/api/connections', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            id, label: wizState.label, url: wizState.url,
            apiKey: wizState.apiKey, collection: wizState.collection,
          }),
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || 'Failed to save connection');

        // Refresh the connections list in-place
        try {
          const connRes = await fetch('/api/connections');
          const connData = await connRes.json();
          if (connData.connections) {
            const list = overlay.querySelector('#conn-list');
            const allConns = connData.connections;
            if (allConns.length === 0) {
              list.innerHTML = '<div class="conn-empty">No connections configured</div>';
            } else {
              list.innerHTML = allConns.map(c => `
                <div class="conn-item${c.active ? ' active' : ''}${!c.reachable ? ' unreachable' : ''}" data-conn-id="${c.id}">
                  <div class="conn-item-dot"></div>
                  <div class="conn-item-info">
                    <div class="conn-item-name">${c.label || c.collection}</div>
                    <div class="conn-item-meta">${c.collection}</div>
                  </div>
                  ${c.reachable ? `<span class="conn-item-count">${c.points} pts</span>` : ''}
                  ${!c.reachable && /localhost|127\\.0\\.0\\.1/.test(c.url) ? `
                    <button class="conn-item-start" data-conn-id="${c.id}" data-tooltip="Start Container">
                      <svg viewBox="0 0 24 24"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                    </button>
                  ` : ''}
                  ${c.reachable ? `
                    <button class="conn-item-action conn-item-backup" data-conn-id="${c.id}" data-tooltip="Backup">
                      <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                    </button>
                    <button class="conn-item-action conn-item-restore" data-conn-id="${c.id}" data-tooltip="Restore">
                      <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                    </button>
                  ` : ''}
                  <button class="conn-item-delete" data-conn-id="${c.id}" data-conn-label="${c.label || c.collection}" data-tooltip="Remove">
                    <svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                  </button>
                </div>
              `).join('');
            }
          }
        } catch {}

        closeWiz();
      } catch (err) {
        btn.textContent = 'Add Collection';
        btn.disabled = false;
        alert(err.message);
      }
    });

    // --- Navigation ---
    $next.addEventListener('click', () => {
      if (currentStep === 0) {
        showConfigPanel();
        goToStep(1);
      } else if (currentStep === 1) {
        if (validateStep1()) {
          wizState.dockerReady = false;
          wizState.collectionCreated = false;
          goToStep(2);
        }
      } else if (currentStep === 2) {
        buildSummary();
        goToStep(3);
      }
    });

    $back.addEventListener('click', () => {
      if (currentStep > 0) goToStep(currentStep - 1);
    });

    // Initial viewport size
    resizeViewport(0);
  });

  // ── Claude Code tab handlers ──

  // Helper: toggle hook and refresh the item UI
  // Collapsible panel headers
  overlay.querySelectorAll('[data-cc-collapse]').forEach(header => {
    header.addEventListener('click', (e) => {
      // Don't collapse when clicking action buttons inside the body
      if (e.target.closest('.cc-panel-actions')) return;
      const panel = header.closest('.cc-panel');
      if (panel) panel.classList.toggle('open');
    });
  });

  // Update the "X of Y active" count on the Connections tab's Claude Code panel
  function updateProjectCount() {
    const allPanels = overlay.querySelectorAll('.cc-panel[data-cc-idx]');
    const activePanels = overlay.querySelectorAll('.cc-panel[data-cc-idx].enabled');
    const countEl = overlay.querySelector('.cc-project-count');
    if (countEl) countEl.textContent = `${activePanels.length} of ${allPanels.length} active`;
  }

  // Update the global Claude Code panel header badge based on individual hook states
  function updateGlobalHookBadge() {
    const globalPanel = overlay.querySelector('.cc-panel[data-cc-target="global"]');
    if (!globalPanel) return;
    const toggles = globalPanel.querySelectorAll('.cc-toggle[data-cc-scope="global"]');
    const onCount = [...toggles].filter(t => t.classList.contains('on')).length;
    const badge = globalPanel.querySelector('.cc-panel-status');
    if (badge) {
      if (onCount === toggles.length) {
        badge.textContent = 'Connected';
        badge.className = 'cc-panel-status active';
      } else if (onCount > 0) {
        badge.textContent = 'Partial';
        badge.className = 'cc-panel-status active';
      } else {
        badge.textContent = 'Off';
        badge.className = 'cc-panel-status inactive';
      }
    }
    globalPanel.classList.toggle('enabled', onCount > 0);
  }

  async function ccToggleHook(target, projectPath, toggleBtn, panel, hookEvent) {
    const isOn = toggleBtn.classList.contains('on');
    const method = isOn ? 'DELETE' : 'POST';
    const body = { target };
    if (projectPath) body.projectPath = projectPath;
    if (hookEvent) body.hook = hookEvent;

    try {
      toggleBtn.style.opacity = '0.4';
      toggleBtn.style.pointerEvents = 'none';
      const res = await fetch('/api/claude-code/integrations', {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      const data = await res.json();
      if (data.ok) {
        const nowOn = !isOn;
        toggleBtn.classList.toggle('on');
        // Update the integration-item row highlight
        const row = toggleBtn.closest('.cc-integration-item');
        if (row) row.classList.toggle('enabled', nowOn);

        if (target === 'global') {
          updateGlobalHookBadge();
        } else {
          // For project-level toggles (button-style)
          toggleBtn.textContent = nowOn ? 'Enabled' : 'Enable';
          if (panel) panel.classList.toggle('enabled');
          const badge = panel?.querySelector('.cc-panel-status');
          if (badge) {
            badge.textContent = nowOn ? 'Active' : 'Off';
            badge.className = 'cc-panel-status ' + (nowOn ? 'active' : 'inactive');
          }
          updateProjectCount();
        }
      } else {
        alert(data.error || 'Failed to toggle hook');
      }
    } catch (err) {
      alert('Failed: ' + err.message);
    } finally {
      toggleBtn.style.opacity = '';
      toggleBtn.style.pointerEvents = '';
    }
  }

  // Per-hook toggles (global scope)
  overlay.querySelectorAll('.cc-toggle[data-cc-scope="global"]').forEach(toggle => {
    toggle.addEventListener('click', () => {
      const hookEvent = toggle.dataset.ccHook;
      const panel = overlay.querySelector('.cc-panel[data-cc-target="global"]');
      ccToggleHook('global', null, toggle, panel, hookEvent);
    });
  });

  // Feature toggles (hook features like conversation memory)
  overlay.querySelectorAll('.cc-toggle[data-cc-feature]').forEach(toggle => {
    toggle.addEventListener('click', async () => {
      const feature = toggle.dataset.ccFeature;
      const isOn = toggle.classList.contains('on');
      try {
        toggle.style.opacity = '0.4';
        toggle.style.pointerEvents = 'none';
        const res = await fetch('/api/claude-code/hook-features', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ feature, enabled: !isOn }),
        });
        const data = await res.json();
        if (data.ok) {
          toggle.classList.toggle('on');
          const row = toggle.closest('.cc-integration-item');
          if (row) row.classList.toggle('enabled', !isOn);
        } else {
          alert(data.error || 'Failed to toggle feature');
        }
      } catch (err) {
        alert('Failed: ' + err.message);
      } finally {
        toggle.style.opacity = '';
        toggle.style.pointerEvents = '';
      }
    });
  });

  // Per-hook toggles (project scope)
  overlay.querySelectorAll('.cc-toggle[data-cc-scope="project"]').forEach(toggle => {
    toggle.addEventListener('click', () => {
      const hookEvent = toggle.dataset.ccHook;
      const projectPath = toggle.dataset.ccProject;
      ccToggleHook('project', projectPath, toggle, null, hookEvent);
    });
  });

  // Per-project toggles
  overlay.querySelectorAll('.cc-enable-btn[data-cc-project-toggle]').forEach(btn => {
    btn.addEventListener('click', () => {
      const idx = btn.dataset.ccProjectToggle;
      const panel = overlay.querySelector(`.cc-panel[data-cc-idx="${idx}"]`);
      const projectPath = panel?.dataset.ccPath;
      if (projectPath) ccToggleHook('project', projectPath, btn, panel);
    });
  });

  // Toast helper
  function showCCToast(msg, duration = 3000) {
    let toast = document.querySelector('.cc-toast');
    if (!toast) {
      toast = document.createElement('div');
      toast.className = 'cc-toast';
      document.body.appendChild(toast);
    }
    toast.textContent = msg;
    toast.classList.add('show');
    clearTimeout(toast._timer);
    toast._timer = setTimeout(() => toast.classList.remove('show'), duration);
  }

  // Skill toggles
  overlay.querySelectorAll('.cc-toggle[data-cc-skill]').forEach(toggle => {
    toggle.addEventListener('click', async () => {
      const skillName = toggle.dataset.ccSkill;
      const isOn = toggle.classList.contains('on');
      const method = isOn ? 'DELETE' : 'POST';
      try {
        toggle.style.opacity = '0.4';
        toggle.style.pointerEvents = 'none';
        const res = await fetch('/api/claude-code/skills', {
          method,
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: skillName }),
        });
        const data = await res.json();
        if (data.ok) {
          toggle.classList.toggle('on');
          const row = toggle.closest('.cc-skill-row');
          if (row) row.classList.toggle('installed', !isOn);
          showCCToast(isOn ? 'Skill uninstalled — restart Claude Code to apply' : 'Skill installed — restart Claude Code to apply');
        } else {
          alert(data.error || 'Failed to toggle skill');
        }
      } catch (err) {
        alert('Failed: ' + err.message);
      } finally {
        toggle.style.opacity = '';
        toggle.style.pointerEvents = '';
      }
    });
  });

  // MCP toggle
  const mcpToggle = overlay.querySelector('#cc-mcp-toggle');
  if (mcpToggle) {
    mcpToggle.addEventListener('click', async () => {
      const isOn = mcpToggle.classList.contains('on');
      const method = isOn ? 'DELETE' : 'POST';
      try {
        mcpToggle.style.opacity = '0.4';
        mcpToggle.style.pointerEvents = 'none';
        const res = await fetch('/api/claude-code/mcp', { method });
        const data = await res.json();
        if (data.ok) {
          const nowOn = !isOn;
          mcpToggle.classList.toggle('on');
          const row = overlay.querySelector('#cc-mcp-row');
          if (row) {
            row.classList.toggle('enabled', nowOn);
            const path = row.querySelector('.cc-integration-path');
            if (path) path.textContent = nowOn ? 'Registered in ~/.claude.json' : 'Not connected';
          }
        } else {
          alert(data.error || 'Failed');
        }
      } catch (err) {
        alert('Failed: ' + err.message);
      } finally {
        mcpToggle.style.opacity = '';
        mcpToggle.style.pointerEvents = '';
      }
    });
  }

  // Copy CLI command
  const mcpCopy = overlay.querySelector('#cc-mcp-copy');
  if (mcpCopy) {
    mcpCopy.addEventListener('click', () => {
      const cmd = ccIntegrations.mcp?.cliCommand || '';
      if (!cmd) { alert('CLI command not available'); return; }
      navigator.clipboard.writeText(cmd);
      mcpCopy.innerHTML = '<svg viewBox="0 0 24 24" style="width:12px;height:12px"><polyline points="20 6 9 17 4 12"/></svg> Copied!';
      setTimeout(() => {
        mcpCopy.innerHTML = '<svg viewBox="0 0 24 24" style="width:12px;height:12px"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy CLI Command';
      }, 2000);
    });
  }

  // Ruleset preview + copy
  const rulesetPreview = overlay.querySelector('#cc-ruleset-preview');
  const rulesetCopy = overlay.querySelector('#cc-ruleset-copy');
  let cachedRuleset = '';
  if (rulesetPreview) {
    fetch('/api/claude-code/ruleset').then(r => r.json()).then(data => {
      if (data.ok && data.ruleset) {
        cachedRuleset = data.ruleset;
        // Show truncated preview
        const lines = data.ruleset.split('\n');
        const preview = lines.slice(0, 20).join('\n') + (lines.length > 20 ? '\n...' : '');
        rulesetPreview.textContent = preview;
      } else {
        rulesetPreview.textContent = 'Could not load ruleset.';
      }
    }).catch(() => { rulesetPreview.textContent = 'Failed to load.'; });
  }
  if (rulesetCopy) {
    rulesetCopy.addEventListener('click', () => {
      if (!cachedRuleset) { alert('Ruleset not loaded yet'); return; }
      navigator.clipboard.writeText(cachedRuleset);
      rulesetCopy.innerHTML = '<svg viewBox="0 0 24 24" style="width:12px;height:12px"><polyline points="20 6 9 17 4 12"/></svg> Copied!';
      setTimeout(() => {
        rulesetCopy.innerHTML = '<svg viewBox="0 0 24 24" style="width:12px;height:12px"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy SynaBun\'s CLAUDE.md Ruleset';
      }, 2000);
    });
  }

  // Tunnel toggle
  const tunnelToggle = overlay.querySelector('#cc-tunnel-toggle');
  if (tunnelToggle) {
    tunnelToggle.addEventListener('click', async () => {
      const isOn = tunnelToggle.classList.contains('on');
      const endpoint = isOn ? '/api/tunnel/stop' : '/api/tunnel/start';
      try {
        tunnelToggle.style.opacity = '0.4';
        tunnelToggle.style.pointerEvents = 'none';
        const res = await fetch(endpoint, { method: 'POST' });
        const data = await res.json();
        if (data.ok) {
          if (isOn) {
            // Stopped
            tunnelToggle.classList.remove('on');
            const row = overlay.querySelector('#cc-tunnel-row');
            if (row) row.classList.remove('enabled');
            const label = overlay.querySelector('#cc-tunnel-label');
            if (label) label.textContent = 'Ready';
            const urlEl = overlay.querySelector('#cc-tunnel-url');
            if (urlEl) urlEl.textContent = 'Expose MCP to Claude web via public URL';
          } else {
            // Starting - poll for URL
            tunnelToggle.classList.add('on');
            const row = overlay.querySelector('#cc-tunnel-row');
            if (row) row.classList.add('enabled');
            const label = overlay.querySelector('#cc-tunnel-label');
            if (label) label.textContent = 'Starting...';
            const urlEl = overlay.querySelector('#cc-tunnel-url');
            if (urlEl) urlEl.textContent = 'Waiting for tunnel URL...';

            // Poll /api/tunnel/status until URL appears (max 30s)
            let attempts = 0;
            const poll = setInterval(async () => {
              attempts++;
              try {
                const sr = await fetch('/api/tunnel/status');
                const sd = await sr.json();
                if (sd.url) {
                  clearInterval(poll);
                  if (label) label.textContent = 'Running';
                  if (urlEl) urlEl.textContent = sd.url;
                  // Inject copy URL button if not present
                  let copyBtn = overlay.querySelector('#cc-tunnel-copy-url');
                  if (!copyBtn) {
                    const wrapper = document.createElement('div');
                    wrapper.style.cssText = 'margin-top:6px;display:flex;gap:6px;align-items:center';
                    wrapper.innerHTML = `<button class="conn-add-btn" id="cc-tunnel-copy-url" style="margin:0;flex:1;font-size:12px;padding:6px 10px">
                      <svg viewBox="0 0 24 24" style="width:12px;height:12px"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
                      Copy MCP URL
                    </button>`;
                    row.parentNode.insertBefore(wrapper, row.nextSibling);
                    copyBtn = wrapper.querySelector('#cc-tunnel-copy-url');
                    copyBtn.addEventListener('click', () => {
                      const tunnelMcpUrl = (urlEl?.textContent || '') + '/mcp';
                      navigator.clipboard.writeText(tunnelMcpUrl);
                      copyBtn.innerHTML = '<svg viewBox="0 0 24 24" style="width:12px;height:12px"><polyline points="20 6 9 17 4 12"/></svg> Copied!';
                      setTimeout(() => {
                        copyBtn.innerHTML = '<svg viewBox="0 0 24 24" style="width:12px;height:12px"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy MCP URL';
                      }, 2000);
                    });
                  }
                } else if (attempts >= 30) {
                  clearInterval(poll);
                  if (label) label.textContent = 'Timeout';
                  if (urlEl) urlEl.textContent = 'Failed to get tunnel URL - check cloudflared';
                }
              } catch (e) { /* ignore poll errors */ }
            }, 1000);
          }
        } else {
          alert(data.error || 'Failed');
        }
      } catch (err) {
        alert('Failed: ' + err.message);
      } finally {
        tunnelToggle.style.opacity = '';
        tunnelToggle.style.pointerEvents = '';
      }
    });
  }

  // Copy tunnel MCP URL (includes key in path if configured)
  const tunnelCopy = overlay.querySelector('#cc-tunnel-copy-url');
  if (tunnelCopy) {
    tunnelCopy.addEventListener('click', () => {
      const urlEl = overlay.querySelector('#cc-tunnel-url');
      const baseUrl = (urlEl?.textContent || '');
      if (!baseUrl) { alert('Tunnel URL not available'); return; }
      const tunnelMcpUrl = mcpKeyInfo.key
        ? baseUrl + '/mcp/' + mcpKeyInfo.key
        : baseUrl + '/mcp';
      navigator.clipboard.writeText(tunnelMcpUrl);
      tunnelCopy.innerHTML = '<svg viewBox="0 0 24 24" style="width:12px;height:12px"><polyline points="20 6 9 17 4 12"/></svg> Copied!';
      setTimeout(() => {
        tunnelCopy.innerHTML = '<svg viewBox="0 0 24 24" style="width:12px;height:12px"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy MCP URL';
      }, 2000);
    });
  }

  // API key generate
  const apikeyGenBtn = overlay.querySelector('#cc-apikey-generate');
  if (apikeyGenBtn) {
    apikeyGenBtn.addEventListener('click', async () => {
      const existing = overlay.querySelector('#cc-apikey-row')?.classList.contains('enabled');
      if (existing && !confirm('This will revoke the current key and generate a new one. Continue?')) return;
      apikeyGenBtn.style.opacity = '0.4';
      apikeyGenBtn.style.pointerEvents = 'none';
      try {
        const res = await fetch('/api/mcp-key', { method: 'POST' });
        const data = await res.json();
        if (data.ok && data.key) {
          // Update mcpKeyInfo so copy button includes key in URL
          mcpKeyInfo = { hasKey: true, key: data.key, maskedKey: '***' + data.key.slice(-8) };
          // Show the key once
          const reveal = overlay.querySelector('#cc-apikey-reveal');
          const valueEl = overlay.querySelector('#cc-apikey-value');
          const statusEl = overlay.querySelector('#cc-apikey-status');
          const row = overlay.querySelector('#cc-apikey-row');
          if (valueEl) valueEl.textContent = data.key;
          if (reveal) reveal.style.display = '';
          if (statusEl) statusEl.textContent = '***' + data.key.slice(-8);
          if (row) row.classList.add('enabled');
          apikeyGenBtn.textContent = 'Regenerate';
        } else {
          alert(data.error || 'Failed to generate key');
        }
      } catch (err) {
        alert('Failed: ' + err.message);
      } finally {
        apikeyGenBtn.style.opacity = '';
        apikeyGenBtn.style.pointerEvents = '';
      }
    });
  }

  // API key copy
  const apikeyCopyBtn = overlay.querySelector('#cc-apikey-copy');
  if (apikeyCopyBtn) {
    apikeyCopyBtn.addEventListener('click', () => {
      const key = overlay.querySelector('#cc-apikey-value')?.textContent || '';
      if (!key) return;
      navigator.clipboard.writeText(key);
      apikeyCopyBtn.innerHTML = '<svg viewBox="0 0 24 24" style="width:12px;height:12px"><polyline points="20 6 9 17 4 12"/></svg> Copied!';
      setTimeout(() => {
        apikeyCopyBtn.innerHTML = '<svg viewBox="0 0 24 24" style="width:12px;height:12px"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy Key';
      }, 2000);
    });
  }

  // API key revoke
  const apikeyRevokeBtn = overlay.querySelector('#cc-apikey-revoke');
  if (apikeyRevokeBtn) {
    apikeyRevokeBtn.addEventListener('click', async () => {
      if (!confirm('Revoke this API key? The MCP endpoint will become open.')) return;
      try {
        const res = await fetch('/api/mcp-key', { method: 'DELETE' });
        const data = await res.json();
        if (data.ok) {
          // Clear mcpKeyInfo so copy button uses bare /mcp URL
          mcpKeyInfo = { hasKey: false };
          const reveal = overlay.querySelector('#cc-apikey-reveal');
          const statusEl = overlay.querySelector('#cc-apikey-status');
          const row = overlay.querySelector('#cc-apikey-row');
          const genBtn = overlay.querySelector('#cc-apikey-generate');
          if (reveal) reveal.style.display = 'none';
          if (statusEl) statusEl.textContent = 'No key configured - tunnel is open';
          if (row) row.classList.remove('enabled');
          if (genBtn) genBtn.textContent = 'Generate Key';
        }
      } catch (err) {
        alert('Failed: ' + err.message);
      }
    });
  }

  // Remove project from list
  overlay.querySelectorAll('.cc-remove-panel-btn[data-cc-remove]').forEach(btn => {
    btn.addEventListener('click', async (e) => {
      e.stopPropagation();
      const idx = btn.dataset.ccRemove;
      const panel = overlay.querySelector(`.cc-panel[data-cc-idx="${idx}"]`);
      const label = panel?.querySelector('.cc-panel-title')?.textContent || 'this project';

      if (!confirm(`Remove "${label}" from tracked projects?\nThis also disables the hook if active.`)) return;

      try {
        // Disable hook first if installed
        const projectPath = panel?.dataset.ccPath;
        if (projectPath && panel.classList.contains('enabled')) {
          await fetch('/api/claude-code/integrations', {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ target: 'project', projectPath }),
          });
        }
        // Remove from tracked list
        const res = await fetch(`/api/claude-code/projects/${idx}`, { method: 'DELETE' });
        const data = await res.json();
        if (data.ok) {
          panel.style.transition = 'opacity 0.2s, transform 0.2s';
          panel.style.opacity = '0';
          panel.style.transform = 'translateX(10px)';
          setTimeout(() => {
            panel.remove();
            updateProjectCount();
            if (!overlay.querySelector('.cc-panel[data-cc-idx]')) {
              overlay.querySelector('#cc-project-list').innerHTML = '<div class="cc-hint" style="text-align:center;padding:14px">No projects registered yet.</div>';
            }
          }, 200);
        } else {
          alert(data.error || 'Failed to remove project');
        }
      } catch (err) {
        alert('Failed: ' + err.message);
      }
    });
  });

  // Add project button
  overlay.querySelector('#cc-add-project').addEventListener('click', () => {
    const addOverlay = document.createElement('div');
    addOverlay.className = 'tag-delete-overlay';
    addOverlay.style.zIndex = '10001';
    addOverlay.innerHTML = `
      <div class="tag-delete-modal settings-modal" style="max-width:420px">
        <h3><svg viewBox="0 0 24 24" style="width:16px;height:16px;stroke:var(--accent-blue);stroke-width:2;fill:none"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>Add Project</h3>
        <div class="settings-field">
          <label>Project Path</label>
          <input type="text" id="cc-proj-path" placeholder="C:/Users/me/MyProject" autocomplete="off" spellcheck="false" style="font-family:'JetBrains Mono',monospace;font-size:12px">
        </div>
        <div class="settings-field">
          <label>Label <span style="color:var(--t-muted);font-weight:normal">(optional)</span></label>
          <input type="text" id="cc-proj-label" placeholder="My Project" autocomplete="off" spellcheck="false">
        </div>
        <div class="cc-hint">The hook will be added to <code style="font-size:12px;background:var(--s-medium);padding:2px 5px;border-radius:4px">.claude/settings.json</code> inside this directory.</div>
        <div class="settings-actions" style="margin-top:12px">
          <button class="settings-btn-cancel" id="cc-proj-cancel">Cancel</button>
          <button class="settings-btn-save" id="cc-proj-save">Add &amp; Enable</button>
        </div>
      </div>
    `;
    document.body.appendChild(addOverlay);

    const closeAdd = () => addOverlay.remove();
    addOverlay.querySelector('#cc-proj-cancel').addEventListener('click', closeAdd);
    addOverlay.addEventListener('click', e => { if (e.target === addOverlay) closeAdd(); });

    addOverlay.querySelector('#cc-proj-save').addEventListener('click', async () => {
      const projPath = addOverlay.querySelector('#cc-proj-path').value.trim();
      const label = addOverlay.querySelector('#cc-proj-label').value.trim();

      if (!projPath) { alert('Project path is required.'); return; }

      try {
        const saveBtn = addOverlay.querySelector('#cc-proj-save');
        saveBtn.textContent = 'Adding...';
        saveBtn.disabled = true;

        const res = await fetch('/api/claude-code/integrations', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ target: 'project', projectPath: projPath, label }),
        });
        const data = await res.json();
        if (data.ok) {
          closeAdd();
          close();
          openSettingsModal().then(() => {
            // Switch back to projects tab after reopen
            const panel = document.getElementById('settings-panel');
            if (panel) {
              panel.querySelectorAll('.settings-nav-item').forEach(n => n.classList.remove('active'));
              panel.querySelectorAll('.settings-tab-body').forEach(b => b.classList.remove('active'));
              const nav = panel.querySelector('.settings-nav-item[data-tab="projects"]');
              const tab = panel.querySelector('.settings-tab-body[data-tab="projects"]');
              if (nav) nav.classList.add('active');
              if (tab) tab.classList.add('active');
            }
          });
        } else {
          alert(data.error || 'Failed to add project');
          saveBtn.textContent = 'Add & Enable';
          saveBtn.disabled = false;
        }
      } catch (err) {
        alert('Failed: ' + err.message);
        const saveBtn = addOverlay.querySelector('#cc-proj-save');
        saveBtn.textContent = 'Add & Enable';
        saveBtn.disabled = false;
      }
    });
  });
}

document.getElementById('settings-btn').addEventListener('click', () => openSettingsModal());
document.getElementById('titlebar-settings-btn').addEventListener('click', () => openSettingsModal());

// ═══════════════════════════════════════════
// MEMORY SYNC
// ═══════════════════════════════════════════
window.checkSyncStatus = checkSyncStatus;
window.copySyncPrompt = copySyncPrompt;

async function checkSyncStatus() {
  const btn = document.getElementById('sync-check-btn');
  const results = document.getElementById('sync-results');
  if (!btn || !results) return;

  btn.classList.add('loading');
  btn.disabled = true;
  results.innerHTML = '';

  try {
    const res = await fetch('/api/sync/check');
    const data = await res.json();

    if (data.total_stale === 0) {
      results.innerHTML = `
        <div class="sync-summary clean">
          <strong>All clear</strong> — checked ${data.total_with_files} memories with related files, none are stale.
        </div>`;
      return;
    }

    let html = `
      <div class="sync-summary">
        <strong>${data.total_stale}</strong> of ${data.total_with_files} memories are stale
        <button class="sync-select-all" id="sync-select-all">Deselect all</button>
      </div>`;

    for (const mem of data.stale) {
      const preview = mem.content.length > 120
        ? mem.content.slice(0, 120) + '...'
        : mem.content;
      const files = mem.stale_files.map(f => `<span>${f.path}</span>`).join(', ');

      html += `
        <div class="sync-card selected" data-sync-id="${mem.id}">
          <div class="sync-card-header">
            <div class="sync-card-check"></div>
            <span class="sync-card-category">${mem.category}</span>
            <span class="sync-card-importance">imp ${mem.importance}</span>
          </div>
          <div class="sync-card-content">${escapeHtml(preview)}</div>
          <div class="sync-card-files">Changed: ${files}</div>
        </div>`;
    }

    html += `<button class="sync-copy-btn" id="sync-copy-all" onclick="copySyncPrompt()">Copy sync prompt (${data.total_stale})</button>`;
    results.innerHTML = html;

    // Stash data for the copy button
    results._syncData = data;

    // Card selection toggle
    results.querySelectorAll('.sync-card').forEach(card => {
      card.addEventListener('click', () => {
        card.classList.toggle('selected');
        updateSyncCopyBtn();
      });
    });

    // Select all / Deselect all
    document.getElementById('sync-select-all').addEventListener('click', () => {
      const cards = results.querySelectorAll('.sync-card');
      const allSelected = [...cards].every(c => c.classList.contains('selected'));
      cards.forEach(c => c.classList.toggle('selected', !allSelected));
      updateSyncCopyBtn();
    });
  } catch (err) {
    results.innerHTML = `<div class="sync-summary" style="color:var(--accent-red)">Error: ${err.message}</div>`;
  } finally {
    btn.classList.remove('loading');
    btn.disabled = false;
  }
}

function updateSyncCopyBtn() {
  const results = document.getElementById('sync-results');
  const btn = document.getElementById('sync-copy-all');
  const selectAllBtn = document.getElementById('sync-select-all');
  if (!results || !btn) return;

  const cards = results.querySelectorAll('.sync-card');
  const selected = results.querySelectorAll('.sync-card.selected');
  const count = selected.length;

  btn.textContent = count ? `Copy sync prompt (${count})` : 'Copy sync prompt';
  btn.disabled = count === 0;

  if (selectAllBtn) {
    const allSelected = selected.length === cards.length;
    selectAllBtn.textContent = allSelected ? 'Deselect all' : 'Select all';
  }
}

function copySyncPrompt() {
  const results = document.getElementById('sync-results');
  const data = results?._syncData;
  if (!data || !data.stale.length) return;

  // Get selected IDs
  const selectedIds = new Set(
    [...results.querySelectorAll('.sync-card.selected')].map(c => c.dataset.syncId)
  );
  const selected = data.stale.filter(m => selectedIds.has(m.id));
  if (!selected.length) return;

  let prompt = `The following ${selected.length} memories have stale related files and need updating. For each memory, read the current file content, compare it with the memory, and use the reflect tool to update the memory content to match the current code.\n\n`;

  for (const mem of selected) {
    prompt += `Memory ${mem.id}:\n`;
    prompt += `- Category: ${mem.category}\n`;
    prompt += `- Importance: ${mem.importance}\n`;
    prompt += `- Related files: ${mem.related_files.join(', ')}\n`;
    prompt += `- Changed files: ${mem.stale_files.map(f => f.path).join(', ')}\n`;
    prompt += `- Current content:\n${mem.content}\n\n`;
  }

  navigator.clipboard.writeText(prompt).then(() => {
    showSyncCopiedModal(selected.length);
  });
}

function showSyncCopiedModal(count) {
  const overlay = document.createElement('div');
  overlay.className = 'tag-delete-overlay';
  overlay.style.background = 'rgba(0,0,0,0.6)';
  overlay.innerHTML = `
    <div class="tag-delete-modal" style="max-width:380px">
      <div class="tag-delete-modal-title">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6L9 17l-5-5"/></svg>
        Prompt copied
      </div>
      <p style="font-size:var(--fs-sm);color:var(--t-secondary);margin-bottom:6px">
        ${count} ${count === 1 ? 'memory' : 'memories'} ready to sync.
      </p>
      <p style="font-size:var(--fs-sm);color:var(--t-secondary);margin-bottom:6px">
        Paste this prompt into your preferred model to update the stale memories.
      </p>
      <p style="font-size:var(--fs-xs);color:var(--t-muted);margin-bottom:18px">
        The model you choose affects output accuracy — more capable models produce better rewrites.
      </p>
      <div class="tag-delete-modal-actions">
        <button class="action-btn action-btn--ghost" id="sync-modal-close">Got it</button>
      </div>
    </div>
  `;
  document.body.appendChild(overlay);
  requestAnimationFrame(() => overlay.classList.add('visible'));

  const close = () => {
    overlay.classList.remove('visible');
    setTimeout(() => overlay.remove(), 200);
  };
  overlay.querySelector('#sync-modal-close').addEventListener('click', close);
  overlay.addEventListener('click', (e) => { if (e.target === overlay) close(); });
}

function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// ═══════════════════════════════════════════
// VIEW SWITCH (3D → 2D)
// ═══════════════════════════════════════════
{
  const switchBtn = document.querySelector('.view-toggle-btn:not(.active)');
  if (switchBtn) {
    switchBtn.addEventListener('click', (e) => {
      e.preventDefault();
      if (selectedNodeId) sessionStorage.setItem('neural-selected-node-switch', selectedNodeId);
      window.location.href = switchBtn.getAttribute('href');
    });
  }
}

// ═══════════════════════════════════════════
// BOOT
// ═══════════════════════════════════════════
init();
</script>
</body>
</html>
